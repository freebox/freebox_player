diff -ruw linux-2.6.32.27/arch/x86/include/asm/bootparam.h linux-2.6.32.27-fbx/arch/x86/include/asm/bootparam.h
--- linux-2.6.32.27/arch/x86/include/asm/bootparam.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/include/asm/bootparam.h	2011-08-29 16:28:17.641712956 +0200
@@ -13,6 +13,12 @@
 #define SETUP_NONE			0
 #define SETUP_E820_EXT			1
 
+/*
+ * use a number that likely won't clash with newer extensions.
+ */
+#define SETUP_FBXSERIAL_EXT		0x42000001
+#define SETUP_FBXBOOTINFO		0x42000002
+
 /* extensible setup data list node */
 struct setup_data {
 	__u64 next;
diff -ruw linux-2.6.32.27/arch/x86/include/asm/pci_x86.h linux-2.6.32.27-fbx/arch/x86/include/asm/pci_x86.h
--- linux-2.6.32.27/arch/x86/include/asm/pci_x86.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/include/asm/pci_x86.h	2011-08-29 16:28:17.671713223 +0200
@@ -106,6 +106,7 @@
 extern void pci_direct_init(int type);
 extern void pci_pcbios_init(void);
 extern int pci_olpc_init(void);
+extern int pci_gen3_init(void);
 extern void __init dmi_check_pciprobe(void);
 extern void __init dmi_check_skip_isa_align(void);
 
diff -ruw linux-2.6.32.27/arch/x86/include/asm/serial.h linux-2.6.32.27-fbx/arch/x86/include/asm/serial.h
--- linux-2.6.32.27/arch/x86/include/asm/serial.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/include/asm/serial.h	2011-08-29 16:28:17.681713312 +0200
@@ -8,7 +8,11 @@
  * clock, since the 16550A is capable of handling a top speed of 1.5
  * megabits/second; but this requires the faster clock.
  */
+#ifdef CONFIG_GEN3_UART
+#define BASE_BAUD ( 14745600 / 16 )
+#else
 #define BASE_BAUD ( 1843200 / 16 )
+#endif
 
 /* Standard COM flags (except for COM4, because of the 8514 problem) */
 #ifdef CONFIG_SERIAL_DETECT_IRQ
@@ -19,11 +23,28 @@
 #define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF
 #endif
 
+#ifdef CONFIG_GEN3_UART
+#if (CONFIG_SERIAL_8250_NR_UARTS > 2)
+#error Too many UART ports defined
+#endif
+
+#ifdef CONFIG_ACPI
+#define	UART_IRQ	38
+#else
+#define UART_IRQ	4
+#endif
+
+#define SERIAL_PORT_DFNS			\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, BASE_BAUD, 0x3F8, UART_IRQ, STD_COM_FLAGS },/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, UART_IRQ, STD_COM_FLAGS },/* ttyS1 */
+#else
 #define SERIAL_PORT_DFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
 	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
 	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
+#endif /* CONFIG_GEN3_UART */
 
 #endif /* _ASM_X86_SERIAL_H */
diff -ruw linux-2.6.32.27/arch/x86/include/asm/x86_init.h linux-2.6.32.27-fbx/arch/x86/include/asm/x86_init.h
--- linux-2.6.32.27/arch/x86/include/asm/x86_init.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/include/asm/x86_init.h	2011-08-29 16:28:17.701713490 +0200
@@ -130,4 +130,10 @@
 extern void x86_init_noop(void);
 extern void x86_init_uint_noop(unsigned int unused);
 
+#ifdef CONFIG_ARCH_GEN3
+extern int sdv_i2c_fixup_ck505(void);
+#else
+static inline int sdv_i2c_fixup_ck505(void) { return 0; }
+#endif
+
 #endif
diff -ruw linux-2.6.32.27/arch/x86/Kconfig linux-2.6.32.27-fbx/arch/x86/Kconfig
--- linux-2.6.32.27/arch/x86/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/Kconfig	2011-09-09 16:29:22.029838807 +0200
@@ -444,6 +444,24 @@
 	select ARCH_SUPPORTS_MEMORY_FAILURE
 	default y
 
+menu "Intel Media SOC Gen3 support"
+
+config ARCH_GEN3
+	bool "Enable Intel Media SOC Gen3 support"
+	default y
+
+choice
+	prompt "IntelCE target Board"
+	depends on ARCH_GEN3
+
+config BOARD_FBX6HD
+	bool "Freebox v6 HD"
+	select FBXSERIAL
+
+endchoice
+
+endmenu
+
 config X86_VISWS
 	bool "SGI 320/540 (Visual Workstation)"
 	depends on X86_32 && PCI && X86_MPPARSE && PCI_GODIRECT
@@ -2096,3 +2114,8 @@
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+config CROSS_PATH
+	string "cross path"
+	default "i686-cm-linux-"
+
diff -ruw linux-2.6.32.27/arch/x86/kernel/Makefile linux-2.6.32.27-fbx/arch/x86/kernel/Makefile
--- linux-2.6.32.27/arch/x86/kernel/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/kernel/Makefile	2011-08-29 16:28:17.701713490 +0200
@@ -87,6 +87,7 @@
 obj-$(CONFIG_KGDB)		+= kgdb.o
 obj-$(CONFIG_VM86)		+= vm86_32.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
+obj-$(CONFIG_ARCH_GEN3)		+= i2c-intelce.o
 
 obj-$(CONFIG_HPET_TIMER) 	+= hpet.o
 
@@ -109,6 +110,8 @@
 
 obj-$(CONFIG_OLPC)		+= olpc.o
 obj-$(CONFIG_X86_MRST)		+= mrst.o
+obj-$(CONFIG_FBXSERIAL)		+= fbxserial.o
+obj-$(CONFIG_BOARD_FBX6HD)	+= fbxbootinfo.o
 
 microcode-y				:= microcode_core.o
 microcode-$(CONFIG_MICROCODE_INTEL)	+= microcode_intel.o
diff -ruw linux-2.6.32.27/arch/x86/kernel/quirks.c linux-2.6.32.27-fbx/arch/x86/kernel/quirks.c
--- linux-2.6.32.27/arch/x86/kernel/quirks.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/kernel/quirks.c	2011-08-29 16:28:17.761714024 +0200
@@ -174,6 +174,20 @@
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x3a16,	/* ICH10 */
 			 ich_force_enable_hpet);
 
+static void intelce_force_enable_hpet(struct pci_dev *dev)
+{
+	if (hpet_address || force_hpet_address)
+		return;
+	
+	force_hpet_address = 0xFED00000;
+	dev_printk(KERN_DEBUG, &dev->dev, "Force enabled HPET at "
+		"0x%lx\n", force_hpet_address);
+	return;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SODAVILLE,
+			intelce_force_enable_hpet);
+
 static struct pci_dev *cached_dev;
 
 static void hpet_print_force_info(void)
diff -ruw linux-2.6.32.27/arch/x86/kernel/reboot_fixups_32.c linux-2.6.32.27-fbx/arch/x86/kernel/reboot_fixups_32.c
--- linux-2.6.32.27/arch/x86/kernel/reboot_fixups_32.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/kernel/reboot_fixups_32.c	2011-08-29 16:28:17.761714024 +0200
@@ -43,6 +43,11 @@
 	outb(1, 0x92);
 }
 
+static void sodaville_reset(struct pci_dev *dev)
+{
+	outb(0x2, 0xcf9);
+}
+
 struct device_fixup {
 	unsigned int vendor;
 	unsigned int device;
@@ -54,6 +59,7 @@
 { PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, cs5536_warm_reset },
 { PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_SC1100_BRIDGE, cs5530a_warm_reset },
 { PCI_VENDOR_ID_RDC, PCI_DEVICE_ID_RDC_R6030, rdc321x_reset },
+{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SODAVILLE, sodaville_reset },
 };
 
 /*
diff -ruw linux-2.6.32.27/arch/x86/kernel/setup.c linux-2.6.32.27-fbx/arch/x86/kernel/setup.c
--- linux-2.6.32.27/arch/x86/kernel/setup.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/kernel/setup.c	2011-08-29 16:28:17.761714024 +0200
@@ -420,6 +420,8 @@
 {
 	struct setup_data *data;
 	u64 pa_data;
+	extern void parse_fbxserial_ext(struct setup_data *d);
+	extern void parse_fbxbootinfo(struct setup_data *d);
 
 	if (boot_params.hdr.version < 0x0209)
 		return;
@@ -430,6 +432,12 @@
 		case SETUP_E820_EXT:
 			parse_e820_ext(data, pa_data);
 			break;
+		case SETUP_FBXSERIAL_EXT:
+			parse_fbxserial_ext(data);
+			break;
+		case SETUP_FBXBOOTINFO:
+			parse_fbxbootinfo(data);
+			break;
 		default:
 			break;
 		}
diff -ruw linux-2.6.32.27/arch/x86/kernel/tsc.c linux-2.6.32.27-fbx/arch/x86/kernel/tsc.c
--- linux-2.6.32.27/arch/x86/kernel/tsc.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/kernel/tsc.c	2011-08-29 16:28:17.771714113 +0200
@@ -213,6 +213,7 @@
 	pitcnt = 0;
 	tscmax = 0;
 	tscmin = ULONG_MAX;
+
 	while ((inb(0x61) & 0x20) == 0) {
 		t2 = get_cycles();
 		delta = t2 - tsc;
@@ -952,10 +953,14 @@
 void __init tsc_init(void)
 {
 	u64 lpj;
-	int cpu;
+	int cpu, ret;
 
 	x86_init.timers.tsc_pre_init();
 
+	ret = sdv_i2c_fixup_ck505();
+	if (ret)
+		printk(KERN_WARNING "unable to fixup ck505\n");
+
 	if (!cpu_has_tsc)
 		return;
 
diff -ruw linux-2.6.32.27/arch/x86/Makefile linux-2.6.32.27-fbx/arch/x86/Makefile
--- linux-2.6.32.27/arch/x86/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/Makefile	2011-08-29 16:28:17.621712778 +0200
@@ -12,6 +12,10 @@
 # e.g.: obj-y += foo_$(BITS).o
 export BITS
 
+ifneq ($(CONFIG_CROSS_PATH),)
+        CROSS_COMPILE := $(patsubst "%",%,$(CONFIG_CROSS_PATH))
+endif
+
 ifeq ($(CONFIG_X86_32),y)
         BITS := 32
         UTS_MACHINE := i386
diff -ruw linux-2.6.32.27/arch/x86/pci/init.c linux-2.6.32.27-fbx/arch/x86/pci/init.c
--- linux-2.6.32.27/arch/x86/pci/init.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/pci/init.c	2011-08-29 16:28:17.821714558 +0200
@@ -15,6 +15,10 @@
 	if (!(pci_probe & PCI_PROBE_NOEARLY))
 		pci_mmcfg_early_init();
 
+#ifdef CONFIG_ARCH_GEN3
+	if (!pci_gen3_init())
+		return 0;
+#endif
 #ifdef CONFIG_PCI_OLPC
 	if (!pci_olpc_init())
 		return 0;	/* skip additional checks if it's an XO */
diff -ruw linux-2.6.32.27/arch/x86/pci/Makefile linux-2.6.32.27-fbx/arch/x86/pci/Makefile
--- linux-2.6.32.27/arch/x86/pci/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/arch/x86/pci/Makefile	2011-08-29 16:28:17.821714558 +0200
@@ -4,6 +4,7 @@
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig_$(BITS).o direct.o mmconfig-shared.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
 obj-$(CONFIG_PCI_OLPC)		+= olpc.o
+obj-$(CONFIG_ARCH_GEN3)		+= intel_media_proc_gen3.o
 
 obj-y				+= fixup.o
 obj-$(CONFIG_ACPI)		+= acpi.o
diff -ruw linux-2.6.32.27/crypto/algboss.c linux-2.6.32.27-fbx/crypto/algboss.c
--- linux-2.6.32.27/crypto/algboss.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/crypto/algboss.c	2011-08-29 16:28:17.861714912 +0200
@@ -214,7 +214,9 @@
 	if (type & CRYPTO_ALG_TESTED)
 		goto skiptest;
 
+#ifdef CONFIG_CRYPTO_BUILTIN_TEST
 	err = alg_test(param->driver, param->alg, type, CRYPTO_ALG_TESTED);
+#endif
 
 skiptest:
 	crypto_alg_tested(param->driver, err);
diff -ruw linux-2.6.32.27/crypto/Kconfig linux-2.6.32.27-fbx/crypto/Kconfig
--- linux-2.6.32.27/crypto/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/crypto/Kconfig	2011-08-29 16:28:17.861714912 +0200
@@ -82,6 +82,10 @@
 	tristate
 	select CRYPTO_ALGAPI2
 
+config CRYPTO_BUILTIN_TEST
+	bool "Include builtin tests"
+	default y
+
 config CRYPTO_MANAGER
 	tristate "Cryptographic algorithm manager"
 	select CRYPTO_MANAGER2
diff -ruw linux-2.6.32.27/crypto/Makefile linux-2.6.32.27-fbx/crypto/Makefile
--- linux-2.6.32.27/crypto/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/crypto/Makefile	2011-08-29 16:28:17.861714912 +0200
@@ -28,7 +28,10 @@
 
 obj-$(CONFIG_CRYPTO_PCOMP) += pcompress.o
 
-cryptomgr-objs := algboss.o testmgr.o
+cryptomgr-objs := algboss.o
+ifeq ($(CONFIG_CRYPTO_BUILTIN_TEST),y)
+cryptomgr-objs += testmgr.o
+endif
 
 obj-$(CONFIG_CRYPTO_MANAGER2) += cryptomgr.o
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
diff -ruw linux-2.6.32.27/drivers/ata/ahci.c linux-2.6.32.27-fbx/drivers/ata/ahci.c
--- linux-2.6.32.27/drivers/ata/ahci.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/ata/ahci.c	2011-08-29 16:28:18.001716158 +0200
@@ -2398,6 +2398,16 @@
 	writel(cmd, port_mmio + PORT_CMD);
 
 	pp->intr_mask |= PORT_IRQ_BAD_PMP;
+
+	/*
+	 * We must not change the port interrupt mask register if the
+	 * port is marked frozen, the value in pp->intr_mask will be
+	 * restored later when the port is thawed.
+	 *
+	 * Note that during initialization, the port is marked as
+	 * frozen since the irq handler is not yet registered.
+	 */
+	if (!(ap->pflags & ATA_PFLAG_FROZEN))
 	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
 }
 
@@ -2412,6 +2422,9 @@
 	writel(cmd, port_mmio + PORT_CMD);
 
 	pp->intr_mask &= ~PORT_IRQ_BAD_PMP;
+
+	/* see comment above in ahci_pmp_attach() */
+	if (!(ap->pflags & ATA_PFLAG_FROZEN))
 	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
 }
 
diff -ruw linux-2.6.32.27/drivers/ata/libata-core.c linux-2.6.32.27-fbx/drivers/ata/libata-core.c
--- linux-2.6.32.27/drivers/ata/libata-core.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/ata/libata-core.c	2011-08-29 16:28:18.011716247 +0200
@@ -5702,7 +5702,7 @@
 	if (!ap)
 		return NULL;
 
-	ap->pflags |= ATA_PFLAG_INITIALIZING;
+	ap->pflags |= ATA_PFLAG_INITIALIZING | ATA_PFLAG_FROZEN;
 	ap->lock = &host->lock;
 	ap->flags = ATA_FLAG_DISABLED;
 	ap->print_id = -1;
diff -ruw linux-2.6.32.27/drivers/char/Kconfig linux-2.6.32.27-fbx/drivers/char/Kconfig
--- linux-2.6.32.27/drivers/char/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/char/Kconfig	2011-08-29 16:28:18.141717402 +0200
@@ -97,6 +97,15 @@
 	  kind of kernel debugging operations.
 	  When in doubt, say "N".
 
+config DEVPHYSMEM
+	bool "/dev/physmem virtual device support"
+	default y if X86
+	help
+	  Say Y here if you want to support the /dev/physmem device. The
+	  /dev/physmem device allows unprivileged access to physical memory
+	  unused by the kernel.
+	  When in doubt, say "N".
+
 config BFIN_JTAG_COMM
 	tristate "Blackfin JTAG Communication"
 	depends on BLACKFIN
diff -ruw linux-2.6.32.27/drivers/char/mem.c linux-2.6.32.27-fbx/drivers/char/mem.c
--- linux-2.6.32.27/drivers/char/mem.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/char/mem.c	2011-08-29 16:28:18.211718025 +0200
@@ -377,6 +377,16 @@
 }
 #endif
 
+#ifdef CONFIG_DEVPHYSMEM
+static int mmap_physmem(struct file * file, struct vm_area_struct * vma)
+{
+	if (vma->vm_pgoff < max_pfn && !capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	return mmap_mem(file, vma);
+}
+#endif
+
 #ifdef CONFIG_CRASH_DUMP
 /*
  * Read memory corresponding to the old kernel.
@@ -768,6 +778,13 @@
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
+#ifdef CONFIG_DEVPHYSMEM
+static int open_physmem(struct inode * inode, struct file * filp)
+{
+	return 0;
+}
+#endif
+
 #define zero_lseek	null_lseek
 #define full_lseek      null_lseek
 #define write_zero	write_null
@@ -842,6 +859,14 @@
 };
 #endif
 
+#ifdef CONFIG_DEVPHYSMEM
+static const struct file_operations physmem_fops = {
+	.mmap		= mmap_physmem,
+	.open		= open_physmem,
+	.get_unmapped_area = get_unmapped_area_mem,
+};
+#endif
+
 static ssize_t kmsg_write(struct file * file, const char __user * buf,
 			  size_t count, loff_t *ppos)
 {
@@ -889,6 +914,9 @@
 #ifdef CONFIG_CRASH_DUMP
 	[12] = { "oldmem", 0, &oldmem_fops, NULL },
 #endif
+#ifdef CONFIG_DEVPHYSMEM
+	[16] = { "physmem", 0, &physmem_fops, &directly_mappable_cdev_bdi },
+#endif
 };
 
 static int memory_open(struct inode *inode, struct file *filp)
diff -ruw linux-2.6.32.27/drivers/char/random.c linux-2.6.32.27-fbx/drivers/char/random.c
--- linux-2.6.32.27/drivers/char/random.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/char/random.c	2011-08-29 16:28:18.241718292 +0200
@@ -551,6 +551,12 @@
 	spin_unlock_irqrestore(&r->lock, flags);
 }
 
+void add_raw_randomness(u8 *buf, int nbytes)
+{
+	mix_pool_bytes(&input_pool, buf, nbytes);
+	credit_entropy_bits(&input_pool, nbytes);
+}
+
 /*********************************************************************
  *
  * Entropy input management
diff -ruw linux-2.6.32.27/drivers/hwmon/adt7475.c linux-2.6.32.27-fbx/drivers/hwmon/adt7475.c
--- linux-2.6.32.27/drivers/hwmon/adt7475.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/hwmon/adt7475.c	2011-08-29 16:28:18.501720602 +0200
@@ -113,11 +113,12 @@
 #define TEMP_OFFSET_REG(idx) (REG_TEMP_OFFSET_BASE + (idx))
 #define TEMP_TRANGE_REG(idx) (REG_TEMP_TRANGE_BASE + (idx))
 
-static unsigned short normal_i2c[] = { 0x2e, I2C_CLIENT_END };
+static unsigned short normal_i2c[] = { 0x2c, 0x2d, 0x2e, I2C_CLIENT_END };
 
-I2C_CLIENT_INSMOD_1(adt7475);
+I2C_CLIENT_INSMOD_2(adt7473, adt7475);
 
 static const struct i2c_device_id adt7475_id[] = {
+	{ "adt7473", adt7473 },
 	{ "adt7475", adt7475 },
 	{ }
 };
@@ -222,6 +223,9 @@
 {
 	u16 val;
 
+	if (need_resched())
+		yield();
+
 	val = i2c_smbus_read_byte_data(client, reg);
 	val |= (i2c_smbus_read_byte_data(client, reg + 1) << 8);
 
@@ -768,7 +772,7 @@
 
 	data->range[sattr->index] =
 		adt7475_read(TEMP_TRANGE_REG(sattr->index));
-	data->range[sattr->index] &= ~7;
+	data->range[sattr->index] &= ~0xf;
 	data->range[sattr->index] |= out;
 
 	i2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),
@@ -970,21 +974,27 @@
 			  struct i2c_board_info *info)
 {
 	struct i2c_adapter *adapter = client->adapter;
+	int vendid, devid;
+	const char *name;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
 		return -ENODEV;
 
-	if (kind <= 0) {
-		if (adt7475_read(REG_VENDID) != 0x41 ||
-		    adt7475_read(REG_DEVID) != 0x75) {
-			dev_err(&adapter->dev,
-				"Couldn't detect a adt7475 part at 0x%02x\n",
-				(unsigned int)client->addr);
+	vendid = adt7475_read(REG_VENDID);
+	devid = adt7475_read(REG_DEVID);
+
+	if (vendid == 0x41 && devid == 0x73)
+		name = "adt7473";
+	else if (vendid == 0x41 && devid == 0x75 && client->addr == 0x2e)
+		name = "adt7475";
+	else {
+		dev_dbg(&adapter->dev,
+			"Couldn't detect an ADT7473 or ADT7475 part at "
+			"0x%02x\n", (unsigned int)client->addr);
 			return -ENODEV;
 		}
-	}
 
-	strlcpy(info->type, adt7475_id[0].name, I2C_NAME_SIZE);
+	strlcpy(info->type, name, I2C_NAME_SIZE);
 
 	return 0;
 }
diff -ruw linux-2.6.32.27/drivers/hwmon/coretemp.c linux-2.6.32.27-fbx/drivers/hwmon/coretemp.c
--- linux-2.6.32.27/drivers/hwmon/coretemp.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/hwmon/coretemp.c	2011-08-29 16:28:18.501720602 +0200
@@ -177,14 +177,21 @@
 		usemsr_ee = 0;
 
 		host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
-
-		if (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL
-		    && (host_bridge->device == 0xa000	/* NM10 based nettop */
-		    || host_bridge->device == 0xa010))	/* NM10 based netbook */
+		if (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL) {
+			switch (host_bridge->device) {
+			/* NM10 based nettop */
+			case 0xa000:
+			case 0xa010:
 			tjmax = 100000;
-		else
-			tjmax = 90000;
-
+				break;
+			/* CE3100 / CE4100 */
+			case 0x0708:
+				tjmax = 110000;
+				break;
+			default:
+				break;
+			}
+		}
 		pci_dev_put(host_bridge);
 	}
 
diff -ruw linux-2.6.32.27/drivers/hwmon/Kconfig linux-2.6.32.27-fbx/drivers/hwmon/Kconfig
--- linux-2.6.32.27/drivers/hwmon/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/hwmon/Kconfig	2011-08-29 16:28:18.491720513 +0200
@@ -191,21 +191,25 @@
 	  will be called adt7470.
 
 config SENSORS_ADT7473
-	tristate "Analog Devices ADT7473"
+	tristate "Analog Devices ADT7473 (DEPRECATED)"
 	depends on I2C && EXPERIMENTAL
+	select SENSORS_ADT7475
 	help
 	  If you say yes here you get support for the Analog Devices
 	  ADT7473 temperature monitoring chips.
 
+	  This driver is deprecated, you should use the adt7475 driver
+	  instead.
+
 	  This driver can also be built as a module. If so, the module
 	  will be called adt7473.
 
 config SENSORS_ADT7475
-	tristate "Analog Devices ADT7475"
+	tristate "Analog Devices ADT7473 and ADT7475"
 	depends on I2C && EXPERIMENTAL
 	help
 	  If you say yes here you get support for the Analog Devices
-	  ADT7475 hardware monitoring chips.
+	  ADT7473 and ADT7475 hardware monitoring chips.
 
 	  This driver can also be build as a module.  If so, the module
 	  will be called adt7475.
diff -ruw linux-2.6.32.27/drivers/i2c/busses/i2c-pxa.c linux-2.6.32.27-fbx/drivers/i2c/busses/i2c-pxa.c
--- linux-2.6.32.27/drivers/i2c/busses/i2c-pxa.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/i2c/busses/i2c-pxa.c	2011-08-29 16:28:30.601828018 +0200
@@ -5,6 +5,7 @@
  *
  *  Copyright (C) 2002 Intrinsyc Software Inc.
  *  Copyright (C) 2004-2005 Deep Blue Solutions Ltd.
+ *  Copyright (C) 2009 Florian Fainelli <ffainelli@freebox.fr>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
@@ -33,10 +34,22 @@
 #include <linux/platform_device.h>
 #include <linux/err.h>
 #include <linux/clk.h>
+#include <linux/pci.h>
 
 #include <asm/irq.h>
 #include <asm/io.h>
+#ifdef CONFIG_ARCH_PXA
 #include <plat/i2c.h>
+#else
+#include "../../../arch/arm/plat-pxa/include/plat/i2c.h"
+#endif
+
+#define INTELCE_I2C_IO_SIZE		256
+#define INTELCE_I2C_MAX_BUS_NUM		3
+#define INTELCE_I2C_POLL_COUNT		0x1000
+
+#define DRV_NAME                        KBUILD_MODNAME
+#define DRV_VERSION                     "0.5"
 
 /*
  * I2C register offsets will be shifted 0 or 1 bit left, depending on
@@ -98,11 +111,11 @@
 	unsigned int		msg_num;
 	unsigned int		msg_idx;
 	unsigned int		msg_ptr;
-	unsigned int		slave_addr;
+	unsigned int		found_slaves;
 
 	struct i2c_adapter	adap;
-	struct clk		*clk;
 #ifdef CONFIG_I2C_PXA_SLAVE
+	unsigned int		slave_addr;
 	struct i2c_slave_client *slave;
 #endif
 
@@ -111,21 +124,46 @@
 	u32			icrlog[32];
 
 	void __iomem		*reg_base;
+#ifdef CONFIG_ARCH_PXA
+	struct clk		*clk;
 	unsigned int		reg_shift;
 
 	unsigned long		iobase;
 	unsigned long		iosize;
 
 	int			irq;
+#endif
 	unsigned int		use_pio :1;
 	unsigned int		fast_mode :1;
+#ifdef CONFIG_PCI
+	struct pci_dev		*pdev;
+#endif
 };
 
+static struct pxa_i2c intelce_adapters[INTELCE_I2C_MAX_BUS_NUM];
+
+#ifdef CONFIG_ARCH_PXA
 #define _IBMR(i2c)	((i2c)->reg_base + (0x0 << (i2c)->reg_shift))
 #define _IDBR(i2c)	((i2c)->reg_base + (0x4 << (i2c)->reg_shift))
 #define _ICR(i2c)	((i2c)->reg_base + (0x8 << (i2c)->reg_shift))
 #define _ISR(i2c)	((i2c)->reg_base + (0xc << (i2c)->reg_shift))
 #define _ISAR(i2c)	((i2c)->reg_base + (0x10 << (i2c)->reg_shift))
+#endif
+
+/* Intel CE I2C controller has a slightly
+ * different register offsets layout
+ */
+#ifdef CONFIG_PCI
+#define _ICR(i2c)	((i2c)->reg_base + (0x00))
+#define _ISR(i2c)	((i2c)->reg_base + (0x04))
+#define _ISAR(i2c)	((i2c)->reg_base + (0x08))
+#define _IDBR(i2c)	((i2c)->reg_base + (0x0c))
+#define _IBMR(i2c)	((i2c)->reg_base + (0x14))
+
+/* We are doing PCI, override default accessors */
+#define readl	ioread32
+#define writel	iowrite32
+#endif
 
 /*
  * I2C Slave mode address
@@ -224,16 +262,19 @@
 static void i2c_pxa_scream_blue_murder(struct pxa_i2c *i2c, const char *why)
 {
 	unsigned int i;
-	printk(KERN_ERR "i2c: error: %s\n", why);
-	printk(KERN_ERR "i2c: msg_num: %d msg_idx: %d msg_ptr: %d\n",
+
+	if (i2c_debug > 1) {
+		printk(KERN_DEBUG "i2c: error: %s\n", why);
+		printk(KERN_DEBUG "i2c: msg_num: %d msg_idx: %d msg_ptr: %d\n",
 		i2c->msg_num, i2c->msg_idx, i2c->msg_ptr);
-	printk(KERN_ERR "i2c: ICR: %08x ISR: %08x\n",
+		printk(KERN_DEBUG "i2c: ICR: %08x ISR: %08x\n",
 	       readl(_ICR(i2c)), readl(_ISR(i2c)));
 	printk(KERN_DEBUG "i2c: log: ");
 	for (i = 0; i < i2c->irqlogidx; i++)
 		printk("[%08x:%08x] ", i2c->isrlog[i], i2c->icrlog[i]);
 	printk("\n");
 }
+}
 
 static inline int i2c_pxa_is_slavemode(struct pxa_i2c *i2c)
 {
@@ -404,7 +445,39 @@
 #define i2c_pxa_set_slave(i2c, err)	do { } while (0)
 #endif
 
-static void i2c_pxa_reset(struct pxa_i2c *i2c)
+#ifdef CONFIG_PCI
+static int i2c_pxa_pci_hw_reset(struct pxa_i2c *i2c)
+{
+	int i;
+	u32 val = 0;
+
+	/* Set ICR to default mode */
+	val |= ICR_UR;
+	writel(val, _ICR(i2c));
+	writel(I2C_ISR_INIT, _ISR(i2c));
+	writel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));
+
+	/* Check that bus enters idle state after reset */
+	for (i = 0; i < INTELCE_I2C_POLL_COUNT; i++) {
+		val = readl(_ISR(i2c));
+		if (!(val & ISR_IBB))
+			goto out;
+	}
+
+	/* Perform an aditionnal check on the BUS busy bit */
+	if (readl(_ISR(i2c)) & ISR_IBB)
+		dev_err(&i2c->adap.dev, "HW still not reset!\n");
+
+	dev_err(&i2c->adap.dev, "timeout while resetting HW\n");
+	return -1;
+out:
+	dev_info(&i2c->adap.dev, "HW reset successful\n");
+	return 0;
+}
+#endif
+
+
+static int i2c_pxa_reset(struct pxa_i2c *i2c)
 {
 	pr_debug("Resetting I2C Controller Unit\n");
 
@@ -412,25 +485,38 @@
 	i2c_pxa_abort(i2c);
 
 	/* reset according to 9.8 */
+#ifdef CONFIG_ARCH_PXA
 	writel(ICR_UR, _ICR(i2c));
 	writel(I2C_ISR_INIT, _ISR(i2c));
 	writel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));
 
-	writel(i2c->slave_addr, _ISAR(i2c));
-
 	/* set control register values */
 	writel(I2C_ICR_INIT | (i2c->fast_mode ? ICR_FM : 0), _ICR(i2c));
 
 #ifdef CONFIG_I2C_PXA_SLAVE
+	writel(i2c->slave_addr, _ISAR(i2c));
 	dev_info(&i2c->adap.dev, "Enabling slave mode\n");
 	writel(readl(_ICR(i2c)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(i2c));
 #endif
+#endif	/* CONFIG_ARCH_PXA */
+
+#ifdef CONFIG_PCI
+	if (i2c_pxa_pci_hw_reset(i2c))
+		return 1;
+#endif
+
 
 	i2c_pxa_set_slave(i2c, 0);
 
+#ifdef CONFIG_PCI
+	/* set control register values */
+	writel(ICR_SCLE | (i2c->fast_mode ? ICR_FM : 0), _ICR(i2c));
+#endif
+
 	/* enable unit */
 	writel(readl(_ICR(i2c)) | ICR_IUE, _ICR(i2c));
 	udelay(100);
+	return 0;
 }
 
 
@@ -752,6 +838,16 @@
 		if (ret != I2C_RETRY)
 			goto out;
 
+		if (i == 1 &&
+		    (readl(_ISR(i2c)) & ISR_UB) &&
+		    (readl(_IBMR(i2c)) != 3)) {
+			/* last try and bus is still busy, try
+			 * reset */
+			dev_err(&i2c->adap.dev, "%s: unit still busy after "
+				"hw reset\n", __func__);
+			i2c_pxa_reset(i2c);
+		}
+
 		if (i2c_debug)
 			dev_dbg(&adap->dev, "Retrying transmission\n");
 		udelay(100);
@@ -993,6 +1089,7 @@
 	.functionality	= i2c_pxa_functionality,
 };
 
+#ifdef CONFIG_ARCH_PXA
 static int i2c_pxa_probe(struct platform_device *dev)
 {
 	struct pxa_i2c *i2c;
@@ -1186,8 +1283,186 @@
 	platform_driver_unregister(&i2c_pxa_driver);
 }
 
-MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:pxa2xx-i2c");
 
 subsys_initcall(i2c_adap_pxa_init);
 module_exit(i2c_adap_pxa_exit);
+#endif
+#ifdef CONFIG_PCI
+static int __devinit intelce_i2c_add_one_adapter(struct pci_dev *pdev,
+						int bar)
+{
+	int err;
+	void __iomem *ioaddr;
+	struct pxa_i2c *i2c = &intelce_adapters[bar];
+
+	/* IO Size check */
+	if (pci_resource_len(pdev, bar) < INTELCE_I2C_IO_SIZE) {
+		printk(KERN_ERR DRV_NAME ": Insufficient PCI resources,"
+					"aborting\n");
+		err = -EIO;
+		goto err_out;
+	}
+
+	err = pci_request_region(pdev, bar, DRV_NAME);
+	if (err) {
+		printk(KERN_ERR DRV_NAME " failed to request PCI region\n");
+		goto err_out;
+	}
+
+	ioaddr = pci_iomap(pdev, bar, INTELCE_I2C_IO_SIZE);
+	if (!ioaddr) {
+		printk(KERN_ERR DRV_NAME " ioremap failed for device: %s"
+					"at bar: %d\n",
+					pci_name(pdev), bar);
+		err = -EIO;
+		goto err_release_region;
+	}
+
+	i2c->reg_base = ioaddr;
+	i2c->pdev = pdev;
+	spin_lock_init(&i2c->lock);
+	init_waitqueue_head(&i2c->wait);
+
+	/* 
+	 * Since the adapters share the same IRQ line
+	 * and do not work reliably in interrupt mode
+	 * let's use polling for all of them
+	 */
+	sprintf(i2c->adap.name, "%s-%d", DRV_NAME, bar);
+	i2c->adap.owner			= THIS_MODULE;
+	i2c->adap.class			= I2C_CLASS_HWMON;
+	i2c->adap.algo_data		= i2c;
+	i2c->adap.algo			= &i2c_pxa_pio_algorithm;
+	i2c->adap.dev.parent		= &pdev->dev;
+	i2c->adap.nr			= bar;
+	i2c->adap.retries		= 5;
+	i2c->fast_mode			= 0;
+	i2c->use_pio			= 1;
+
+	/* Set adapter data */
+	i2c_set_adapdata(&i2c->adap, i2c);
+
+	/* Add i2c adapter */
+	err = i2c_add_numbered_adapter(&i2c->adap);
+	if (err) {
+		printk(KERN_ERR DRV_NAME " fail to add adapter %d\n",
+					i2c->adap.nr);
+		goto err_unmap;
+	}
+
+	err = i2c_pxa_reset(i2c);
+	if (err) {
+		dev_err(&i2c->adap.dev, " failed to reset HW\n");
+		goto err_adapt;
+	}
+
+	dev_info(&i2c->pdev->dev, "(0x%p, v%s, mode: %s)\n",
+					i2c->reg_base, DRV_VERSION,
+					i2c->fast_mode ? "Fast" : "Normal");
+	return 0;
+
+err_adapt:
+	i2c_del_adapter(&i2c->adap);
+err_unmap:
+	pci_iounmap(pdev, ioaddr);
+err_release_region:
+	pci_release_region(pdev, bar);
+err_out:
+	return err;
+}
+
+static int __devinit intelce_i2c_probe(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	int err, bar;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto err_out;
+
+	/* this should always be supported */
+	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+	if (err) {
+		printk(KERN_ERR DRV_NAME ": 32-bit PCI DMA addresses"
+				"not supported by the card\n");
+		goto err_out;
+	}
+
+	err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+	if (err) {
+		printk(KERN_ERR DRV_NAME ": 32-bit PCI DMA addresses"
+				"not supported by the card\n");
+		goto err_out;
+	}
+
+	pci_set_master(pdev);
+
+	/* Add the adapters */
+	for (bar = 2; bar < INTELCE_I2C_MAX_BUS_NUM; bar++) {
+		err = intelce_i2c_add_one_adapter(pdev, bar);
+		if (err)
+			goto err_out;
+	}
+
+	pci_set_drvdata(pdev, intelce_adapters);
+
+	return 0;
+
+err_out:
+	return err;
+}
+
+static void __exit intelce_i2c_remove_one_adapter(struct pci_dev *pdev,
+			struct pxa_i2c *i2c, int bar)
+{
+	i2c_del_adapter(&i2c->adap);
+	pci_iounmap(pdev, i2c->reg_base);
+	pci_release_region(pdev, bar);
+}
+
+
+static void __exit intelce_i2c_remove(struct pci_dev *pdev)
+{
+	struct pxa_i2c *intelce_adapters = pci_get_drvdata(pdev);
+	int bar;
+
+	/* Unregister our adapters */
+	for (bar = 2; bar < INTELCE_I2C_MAX_BUS_NUM; bar++)
+		intelce_i2c_remove_one_adapter(pdev,
+				&intelce_adapters[bar], bar);
+
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+}
+
+static struct pci_device_id intelce_i2c_id_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2e68) },
+	{ 0 }
+};
+
+static struct pci_driver intelce_i2c_driver = {
+	.name		= DRV_NAME,
+	.id_table	= intelce_i2c_id_tbl,
+	.probe		= intelce_i2c_probe,
+	.remove		= __devexit_p(intelce_i2c_remove),
+};
+
+static int __init intelce_i2c_init(void)
+{
+	return pci_register_driver(&intelce_i2c_driver);
+}
+
+static void __exit intelce_i2c_exit(void)
+{
+	pci_unregister_driver(&intelce_i2c_driver);
+}
+
+module_init(intelce_i2c_init);
+module_exit(intelce_i2c_exit);
+
+MODULE_AUTHOR("Florian Fainelli <ffainelli@freebox.fr>");
+MODULE_DESCRIPTION("I2C driver for the Intel Sodaville SoC (PXA compatible)");
+MODULE_VERSION(DRV_VERSION);
+#endif
+MODULE_LICENSE("GPL");
diff -ruw linux-2.6.32.27/drivers/i2c/busses/Kconfig linux-2.6.32.27-fbx/drivers/i2c/busses/Kconfig
--- linux-2.6.32.27/drivers/i2c/busses/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/i2c/busses/Kconfig	2011-08-29 16:28:18.531720869 +0200
@@ -479,7 +479,7 @@
 
 config I2C_PXA
 	tristate "Intel PXA2XX I2C adapter"
-	depends on ARCH_PXA || ARCH_MMP
+	depends on ARCH_PXA || ARCH_MMP || PCI
 	help
 	  If you have devices in the PXA I2C bus, say yes to this option.
 	  This driver can also be built as a module.  If so, the module
diff -ruw linux-2.6.32.27/drivers/ide/Kconfig linux-2.6.32.27-fbx/drivers/ide/Kconfig
--- linux-2.6.32.27/drivers/ide/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/ide/Kconfig	2011-08-29 16:28:18.551721047 +0200
@@ -717,6 +717,11 @@
        depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
 endchoice
 
+config BLK_DEV_IDE_TANGO2
+	tristate "IDE for Tango2"
+	depends on TANGO2
+	select BLK_DEV_IDEDMA_SFF
+
 config BLK_DEV_IDE_TX4938
 	tristate "TX4938 internal IDE support"
 	depends on SOC_TX4938
diff -ruw linux-2.6.32.27/drivers/ide/Makefile linux-2.6.32.27-fbx/drivers/ide/Makefile
--- linux-2.6.32.27/drivers/ide/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/ide/Makefile	2011-08-29 16:28:18.551721047 +0200
@@ -117,3 +117,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_TX4938)	+= tx4938ide.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= tx4939ide.o
 obj-$(CONFIG_BLK_DEV_IDE_AT91)		+= at91_ide.o
+obj-$(CONFIG_BLK_DEV_IDE_TANGO2)	+= tango2ide.o
diff -ruw linux-2.6.32.27/drivers/input/misc/Kconfig linux-2.6.32.27-fbx/drivers/input/misc/Kconfig
--- linux-2.6.32.27/drivers/input/misc/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/input/misc/Kconfig	2011-08-29 16:28:18.671722113 +0200
@@ -317,4 +317,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called pcap_keys.
 
+config INPUT_SMSC_CAP1014
+	tristate "SMSC CAP1014 capacitive sensor driver"
+	select I2C
+	select INPUT_POLLDEV
+
+config INPUT_SMSC_CAP1066
+	tristate "SMSC CAP1066 capacitive sensor driver"
+	select I2C
+	select INPUT_POLLDEV
+
 endif
diff -ruw linux-2.6.32.27/drivers/input/misc/Makefile linux-2.6.32.27-fbx/drivers/input/misc/Makefile
--- linux-2.6.32.27/drivers/input/misc/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/input/misc/Makefile	2011-08-29 16:28:18.671722113 +0200
@@ -30,4 +30,5 @@
 obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
-
+obj-$(CONFIG_INPUT_SMSC_CAP1014)	+= smsc_cap1014.o
+obj-$(CONFIG_INPUT_SMSC_CAP1066)	+= smsc_cap1066.o
diff -ruw linux-2.6.32.27/drivers/Kconfig linux-2.6.32.27-fbx/drivers/Kconfig
--- linux-2.6.32.27/drivers/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/Kconfig	2011-08-29 16:28:17.921715446 +0200
@@ -6,8 +6,12 @@
 
 source "drivers/connector/Kconfig"
 
+source "drivers/fbxprocfs/Kconfig"
+
 source "drivers/mtd/Kconfig"
 
+source "drivers/fbxmtd/Kconfig"
+
 source "drivers/of/Kconfig"
 
 source "drivers/parport/Kconfig"
@@ -56,6 +60,10 @@
 
 source "drivers/gpio/Kconfig"
 
+source "drivers/fbxgpio/Kconfig"
+
+source "drivers/fbxjtag/Kconfig"
+
 source "drivers/w1/Kconfig"
 
 source "drivers/power/Kconfig"
@@ -64,6 +72,8 @@
 
 source "drivers/thermal/Kconfig"
 
+source "drivers/fbxwatchdog/Kconfig"
+
 source "drivers/watchdog/Kconfig"
 
 source "drivers/ssb/Kconfig"
@@ -90,6 +100,8 @@
 
 source "drivers/leds/Kconfig"
 
+source "drivers/fbxpanel/Kconfig"
+
 source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
@@ -100,6 +112,8 @@
 
 source "drivers/dma/Kconfig"
 
+source "drivers/fbxdmamux/Kconfig"
+
 source "drivers/dca/Kconfig"
 
 source "drivers/auxdisplay/Kconfig"
@@ -113,4 +127,5 @@
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
 endmenu
diff -ruw linux-2.6.32.27/drivers/leds/Kconfig linux-2.6.32.27-fbx/drivers/leds/Kconfig
--- linux-2.6.32.27/drivers/leds/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/leds/Kconfig	2011-08-29 16:28:18.791723181 +0200
@@ -304,4 +304,11 @@
 comment "iptables trigger is under Netfilter config (LED target)"
 	depends on LEDS_TRIGGERS
 
+config LEDS_TRIGGER_NETDEV
+	tristate "LED Network Device Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by Network Device activity.
+	  If unsure, say Y.
+	  
 endif # NEW_LEDS
diff -ruw linux-2.6.32.27/drivers/leds/led-class.c linux-2.6.32.27-fbx/drivers/leds/led-class.c
--- linux-2.6.32.27/drivers/leds/led-class.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/leds/led-class.c	2011-08-29 16:28:18.791723181 +0200
@@ -72,11 +72,14 @@
 	return sprintf(buf, "%u\n", led_cdev->max_brightness);
 }
 
-static DEVICE_ATTR(brightness, 0644, led_brightness_show, led_brightness_store);
-static DEVICE_ATTR(max_brightness, 0444, led_max_brightness_show, NULL);
+static struct device_attribute led_class_attrs[] = {
+	__ATTR(brightness, 0644, led_brightness_show, led_brightness_store),
+	__ATTR(max_brightness, 0644, led_max_brightness_show, NULL),
 #ifdef CONFIG_LEDS_TRIGGERS
-static DEVICE_ATTR(trigger, 0644, led_trigger_show, led_trigger_store);
+	__ATTR(trigger, 0644, led_trigger_show, led_trigger_store),
 #endif
+	__ATTR_NULL,
+};
 
 /**
  * led_classdev_suspend - suspend an led_classdev.
@@ -127,18 +130,11 @@
  */
 int led_classdev_register(struct device *parent, struct led_classdev *led_cdev)
 {
-	int rc;
-
 	led_cdev->dev = device_create(leds_class, parent, 0, led_cdev,
 				      "%s", led_cdev->name);
 	if (IS_ERR(led_cdev->dev))
 		return PTR_ERR(led_cdev->dev);
 
-	/* register the attributes */
-	rc = device_create_file(led_cdev->dev, &dev_attr_brightness);
-	if (rc)
-		goto err_out;
-
 #ifdef CONFIG_LEDS_TRIGGERS
 	init_rwsem(&led_cdev->trigger_lock);
 #endif
@@ -150,17 +146,9 @@
 	if (!led_cdev->max_brightness)
 		led_cdev->max_brightness = LED_FULL;
 
-	rc = device_create_file(led_cdev->dev, &dev_attr_max_brightness);
-	if (rc)
-		goto err_out_attr_max;
-
 	led_update_brightness(led_cdev);
 
 #ifdef CONFIG_LEDS_TRIGGERS
-	rc = device_create_file(led_cdev->dev, &dev_attr_trigger);
-	if (rc)
-		goto err_out_led_list;
-
 	led_trigger_set_default(led_cdev);
 #endif
 
@@ -168,18 +156,8 @@
 			led_cdev->name);
 
 	return 0;
-
-#ifdef CONFIG_LEDS_TRIGGERS
-err_out_led_list:
-	device_remove_file(led_cdev->dev, &dev_attr_max_brightness);
-#endif
-err_out_attr_max:
-	device_remove_file(led_cdev->dev, &dev_attr_brightness);
-	list_del(&led_cdev->node);
-err_out:
-	device_unregister(led_cdev->dev);
-	return rc;
 }
+
 EXPORT_SYMBOL_GPL(led_classdev_register);
 
 /**
@@ -190,10 +168,7 @@
  */
 void led_classdev_unregister(struct led_classdev *led_cdev)
 {
-	device_remove_file(led_cdev->dev, &dev_attr_max_brightness);
-	device_remove_file(led_cdev->dev, &dev_attr_brightness);
 #ifdef CONFIG_LEDS_TRIGGERS
-	device_remove_file(led_cdev->dev, &dev_attr_trigger);
 	down_write(&led_cdev->trigger_lock);
 	if (led_cdev->trigger)
 		led_trigger_set(led_cdev, NULL);
@@ -215,6 +190,7 @@
 		return PTR_ERR(leds_class);
 	leds_class->suspend = led_suspend;
 	leds_class->resume = led_resume;
+	leds_class->dev_attrs = led_class_attrs;
 	return 0;
 }
 
diff -ruw linux-2.6.32.27/drivers/leds/Makefile linux-2.6.32.27-fbx/drivers/leds/Makefile
--- linux-2.6.32.27/drivers/leds/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/leds/Makefile	2011-08-29 16:28:18.791723181 +0200
@@ -37,6 +37,7 @@
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
 obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK)	+= ledtrig-ide-disk.o
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
diff -ruw linux-2.6.32.27/drivers/Makefile linux-2.6.32.27-fbx/drivers/Makefile
--- linux-2.6.32.27/drivers/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/Makefile	2011-08-29 16:28:17.921715446 +0200
@@ -6,6 +6,8 @@
 #
 
 obj-y				+= gpio/
+obj-$(CONFIG_FREEBOX_GPIO)	+= fbxgpio/
+obj-$(CONFIG_FREEBOX_JTAG)	+= fbxjtag/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -54,6 +56,9 @@
 obj-$(CONFIG_UIO)		+= uio/
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
+
+obj-$(CONFIG_FREEBOX_PROCFS)	+= fbxprocfs/
+obj-$(CONFIG_FREEBOX_MTD)	+= fbxmtd/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
 obj-$(CONFIG_SBUS)		+= sbus/
@@ -79,6 +84,7 @@
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
 obj-$(CONFIG_THERMAL)		+= thermal/
+obj-$(CONFIG_FREEBOX_WATCHDOG)	+= fbxwatchdog/
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_PHONE)		+= telephony/
 obj-$(CONFIG_MD)		+= md/
@@ -95,6 +101,7 @@
 obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
+obj-$(CONFIG_FREEBOX_PANEL)	+= fbxpanel/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
 obj-y				+= firmware/
@@ -102,6 +109,7 @@
 obj-$(CONFIG_SUPERH)		+= sh/
 obj-$(CONFIG_GENERIC_TIME)	+= clocksource/
 obj-$(CONFIG_DMA_ENGINE)	+= dma/
+obj-$(CONFIG_FREEBOX_DMAMUX)	+= fbxdmamux/
 obj-$(CONFIG_DCA)		+= dca/
 obj-$(CONFIG_HID)		+= hid/
 obj-$(CONFIG_PPC_PS3)		+= ps3/
diff -ruw linux-2.6.32.27/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.32.27-fbx/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.32.27/drivers/media/dvb/dvb-core/dvb_frontend.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/dvb-core/dvb_frontend.c	2011-08-29 16:28:18.881723980 +0200
@@ -673,7 +673,6 @@
 	}
 
 	fepriv->thread = NULL;
-	fepriv->exit = 0;
 	mb();
 
 	dvb_frontend_wakeup(fe);
@@ -688,6 +687,7 @@
 
 	fepriv->exit = 1;
 	mb();
+	wake_up_all(&fepriv->events.wait_queue);
 
 	if (!fepriv->thread)
 		return;
@@ -1992,6 +1992,9 @@
 
 	poll_wait (file, &fepriv->events.wait_queue, wait);
 
+	if (fepriv->exit)
+		return POLLERR | POLLHUP;
+
 	if (fepriv->events.eventw != fepriv->events.eventr)
 		return (POLLIN | POLLRDNORM | POLLPRI);
 
diff -ruw linux-2.6.32.27/drivers/media/dvb/dvb-usb/dib0700_devices.c linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dib0700_devices.c
--- linux-2.6.32.27/drivers/media/dvb/dvb-usb/dib0700_devices.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dib0700_devices.c	2011-08-29 16:28:18.891724069 +0200
@@ -1269,6 +1269,57 @@
 	return adap->fe == NULL ? -ENODEV : 0;
 }
 
+/* STK7770P */
+static struct dib7000p_config dib7770p_dib7000p_config = {
+	.output_mpeg2_in_188_bytes = 1,
+
+	.agc_config_count = 1,
+	.agc = &dib7070_agc_config,
+	.bw  = &dib7070_bw_config_12_mhz,
+	.tuner_is_baseband = 1,
+	.spur_protect = 1,
+
+	.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,
+	.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,
+	.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,
+
+	.hostbus_diversity = 1,
+	.enable_current_mirror = 1,
+};
+
+static int stk7770p_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct usb_device_descriptor *p = &adap->dev->udev->descriptor;
+	if (p->idVendor  == cpu_to_le16(USB_VID_PINNACLE) &&
+	    p->idProduct == cpu_to_le16(USB_PID_PINNACLE_PCTV72E))
+		dib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 0);
+	else
+		dib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);
+	msleep(10);
+	dib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);
+
+	dib0700_ctrl_clock(adap->dev, 72, 1);
+
+	msleep(10);
+	dib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);
+	msleep(10);
+	dib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);
+
+	if (dib7000p_i2c_enumeration(&adap->dev->i2c_adap, 1, 18,
+				     &dib7770p_dib7000p_config) != 0) {
+		err("%s: dib7000p_i2c_enumeration failed.  Cannot continue\n",
+		    __func__);
+		return -ENODEV;
+	}
+
+	adap->fe = dvb_attach(dib7000p_attach, &adap->dev->i2c_adap, 0x80,
+		&dib7770p_dib7000p_config);
+	return adap->fe == NULL ? -ENODEV : 0;
+}
+
 /* DIB807x generic */
 static struct dibx000_agc_config dib807x_agc_config[2] = {
 	{
@@ -1861,6 +1912,7 @@
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_STK807XPVR) },
 	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_STK807XP) },
 	{ USB_DEVICE(USB_VID_PIXELVIEW, USB_PID_PIXELVIEW_SBTVD) },
+	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_HOOK_DEFAULT_STK7770P) },
 	{ 0 }		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);
@@ -2322,7 +2374,7 @@
 		.num_adapters = 1,
 		.adapter = {
 			{
-				.frontend_attach  = stk7070p_frontend_attach,
+				.frontend_attach  = stk7770p_frontend_attach,
 				.tuner_attach     = dib7770p_tuner_attach,
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
@@ -2335,7 +2387,7 @@
 		.num_device_descs = 2,
 		.devices = {
 			{   "DiBcom STK7770P reference design",
-				{ &dib0700_usb_id_table[59], NULL },
+				{ &dib0700_usb_id_table[59] },
 				{ NULL },
 			},
 			{   "Terratec Cinergy T USB XXS (HD)/ T3",
@@ -2352,6 +2404,27 @@
 	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
 		.num_adapters = 1,
 		.adapter = {
+			{
+				.frontend_attach  = stk7770p_frontend_attach,
+				.tuner_attach     = dib7770p_tuner_attach,
+
+				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
+
+				.size_of_priv =
+					sizeof(struct dib0700_adapter_state),
+			},
+		},
+
+		.num_device_descs = 1,
+		.devices = {
+			{   "DiBcom STK7770P reference design (2)",
+				{ &dib0700_usb_id_table[64] },
+				{ NULL },
+			},
+		},
+	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
+		.num_adapters = 1,
+		.adapter = {
 			{
 				.frontend_attach  = stk807x_frontend_attach,
 				.tuner_attach     = dib807x_tuner_attach,
diff -ruw linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c
--- linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2011-08-29 16:28:18.891724069 +0200
@@ -177,6 +177,9 @@
 	if (adap->props.frontend_attach(adap) == 0 && adap->fe != NULL) {
 		adap->fe_init  = adap->fe->ops.init;  adap->fe->ops.init  = dvb_usb_fe_wakeup;
 		adap->fe_sleep = adap->fe->ops.sleep; adap->fe->ops.sleep = dvb_usb_fe_sleep;
+		/* only attach the tuner if the demod is there */
+		if (adap->props.tuner_attach != NULL)
+			adap->props.tuner_attach(adap);
 
 		if (dvb_register_frontend(&adap->dvb_adap, adap->fe)) {
 			err("Frontend registration failed.");
@@ -185,9 +188,6 @@
 			return -ENODEV;
 		}
 
-		/* only attach the tuner if the demod is there */
-		if (adap->props.tuner_attach != NULL)
-			adap->props.tuner_attach(adap);
 	} else
 		err("no frontend was attached by '%s'",adap->dev->desc->name);
 
diff -ruw linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb.h linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb.h
--- linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb.h	2011-08-29 16:28:18.891724069 +0200
@@ -238,7 +238,7 @@
 	int generic_bulk_ctrl_endpoint;
 
 	int num_device_descs;
-	struct dvb_usb_device_description devices[12];
+	struct dvb_usb_device_description devices[32];
 };
 
 /**
diff -ruw linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb-ids.h linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
--- linux-2.6.32.27/drivers/media/dvb/dvb-usb/dvb-usb-ids.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/dvb-usb/dvb-usb-ids.h	2011-08-29 16:28:18.891724069 +0200
@@ -87,6 +87,7 @@
 #define USB_PID_CONEXANT_D680_DMB			0x86d6
 #define USB_PID_DIBCOM_HOOK_DEFAULT			0x0064
 #define USB_PID_DIBCOM_HOOK_DEFAULT_REENUM		0x0065
+#define USB_PID_DIBCOM_HOOK_DEFAULT_STK7770P		0x0066
 #define USB_PID_DIBCOM_MOD3000_COLD			0x0bb8
 #define USB_PID_DIBCOM_MOD3000_WARM			0x0bb9
 #define USB_PID_DIBCOM_MOD3001_COLD			0x0bc6
diff -ruw linux-2.6.32.27/drivers/media/dvb/frontends/dib7000p.c linux-2.6.32.27-fbx/drivers/media/dvb/frontends/dib7000p.c
--- linux-2.6.32.27/drivers/media/dvb/frontends/dib7000p.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/frontends/dib7000p.c	2011-08-29 16:28:18.901724158 +0200
@@ -258,6 +258,8 @@
 
 //	dprintk( "908: %x, 909: %x\n", reg_908, reg_909);
 
+	reg_908 |= (state->cfg.enable_current_mirror & 1) << 7;
+
 	dib7000p_write_word(state, 908, reg_908);
 	dib7000p_write_word(state, 909, reg_909);
 }
diff -ruw linux-2.6.32.27/drivers/media/dvb/frontends/dib7000p.h linux-2.6.32.27-fbx/drivers/media/dvb/frontends/dib7000p.h
--- linux-2.6.32.27/drivers/media/dvb/frontends/dib7000p.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/frontends/dib7000p.h	2011-08-29 16:28:18.901724158 +0200
@@ -33,6 +33,9 @@
 	int (*agc_control) (struct dvb_frontend *, u8 before);
 
 	u8 output_mode;
+
+	u8 enable_current_mirror : 1;
+
 };
 
 #define DEFAULT_DIB7000P_I2C_ADDRESS 18
diff -ruw linux-2.6.32.27/drivers/media/dvb/Kconfig linux-2.6.32.27-fbx/drivers/media/dvb/Kconfig
--- linux-2.6.32.27/drivers/media/dvb/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/Kconfig	2011-08-29 16:28:18.871723891 +0200
@@ -64,6 +64,10 @@
 	depends on DVB_CORE && PCI && I2C
 source "drivers/media/dvb/dm1105/Kconfig"
 
+comment "Supported Tango2 Adapters"
+	depends on DVB_CORE && ARCH_FBX5_B
+source "drivers/media/dvb/tango2/Kconfig"
+
 comment "Supported FireWire (IEEE 1394) Adapters"
 	depends on DVB_CORE && IEEE1394
 source "drivers/media/dvb/firewire/Kconfig"
diff -ruw linux-2.6.32.27/drivers/media/dvb/Makefile linux-2.6.32.27-fbx/drivers/media/dvb/Makefile
--- linux-2.6.32.27/drivers/media/dvb/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/Makefile	2011-08-29 16:28:18.871723891 +0200
@@ -2,6 +2,7 @@
 # Makefile for the kernel multimedia device drivers.
 #
 
-obj-y        := dvb-core/ frontends/ ttpci/ ttusb-dec/ ttusb-budget/ b2c2/ bt8xx/ dvb-usb/ pluto2/ siano/ dm1105/ pt1/
+obj-y        := dvb-core/ frontends/ ttpci/ ttusb-dec/ ttusb-budget/ b2c2/ bt8xx/ dvb-usb/ pluto2/ siano/ dm1105/ pt1/ tango2/
+obj-y        := dvb-core/ frontends/ ttpci/ ttusb-dec/ ttusb-budget/ b2c2/ bt8xx/ dvb-usb/ pluto2/ siano/ dm1105/ tango2/
 
 obj-$(CONFIG_DVB_FIREDTV)	+= firewire/
diff -ruw linux-2.6.32.27/drivers/misc/Kconfig linux-2.6.32.27-fbx/drivers/misc/Kconfig
--- linux-2.6.32.27/drivers/misc/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/misc/Kconfig	2011-08-29 16:28:19.221727002 +0200
@@ -246,6 +246,14 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called ep93xx_pwm.
 
+config CRASHZONE
+	bool "crashzone support"
+
+config PI7C9X
+	tristate "Pericom PI7C9X packet switch driver"
+	select I2C
+	select BITREVERSE
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff -ruw linux-2.6.32.27/drivers/misc/Makefile linux-2.6.32.27-fbx/drivers/misc/Makefile
--- linux-2.6.32.27/drivers/misc/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/misc/Makefile	2011-08-29 16:28:19.221727002 +0200
@@ -20,6 +20,8 @@
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_ISL29003)		+= isl29003.o
 obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
+obj-$(CONFIG_PI7C9X)		+= pi7c9x.o
 obj-$(CONFIG_C2PORT)		+= c2port/
+obj-$(CONFIG_CRASHZONE)		+= crash_zone.o
 obj-y				+= eeprom/
 obj-y				+= cb710/
diff -ruw linux-2.6.32.27/drivers/mtd/Kconfig linux-2.6.32.27-fbx/drivers/mtd/Kconfig
--- linux-2.6.32.27/drivers/mtd/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/Kconfig	2011-08-29 16:28:19.261727358 +0200
@@ -33,6 +33,9 @@
 	  should normally be compiled as kernel modules. The modules perform
 	  various checks and verifications when loaded.
 
+config MTD_ERASE_PRINTK
+	bool "write to kernel log when a block is erased"
+
 config MTD_CONCAT
 	tristate "MTD concatenating support"
 	help
@@ -171,6 +174,19 @@
 	---help---
 	  TI AR7 partitioning support
 
+config MTD_FBX6HD_PARTS
+	tristate "Freebox V6 HD partitioning support"
+	depends on (MTD_PARTITIONS && MTD_NAND_DENALI)
+	help
+	  Freebox V6 HD partitioning support
+
+config MTD_FBX6HD_PARTS_WRITE_ALL
+	bool "make all partitions writeable"
+	default n
+	depends on MTD_FBX6HD_PARTS
+	help
+	  Freebox V6 HD partitions support
+
 comment "User Modules And Translation Layers"
 
 config MTD_CHAR
diff -ruw linux-2.6.32.27/drivers/mtd/Makefile linux-2.6.32.27-fbx/drivers/mtd/Makefile
--- linux-2.6.32.27/drivers/mtd/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/Makefile	2011-08-29 16:28:19.261727358 +0200
@@ -13,6 +13,7 @@
 obj-$(CONFIG_MTD_AFS_PARTS)	+= afs.o
 obj-$(CONFIG_MTD_AR7_PARTS)	+= ar7part.o
 obj-$(CONFIG_MTD_OF_PARTS)      += ofpart.o
+obj-$(CONFIG_MTD_FBX6HD_PARTS)	+= fbx6hd-mtdparts.o
 
 # 'Users' - code which presents functionality to userspace.
 obj-$(CONFIG_MTD_CHAR)		+= mtdchar.o
diff -ruw linux-2.6.32.27/drivers/mtd/mtdchar.c linux-2.6.32.27-fbx/drivers/mtd/mtdchar.c
--- linux-2.6.32.27/drivers/mtd/mtdchar.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/mtdchar.c	2011-08-29 16:28:19.281727536 +0200
@@ -553,6 +553,10 @@
 			erase->callback = mtdchar_erase_callback;
 			erase->priv = (unsigned long)&waitq;
 
+#ifdef CONFIG_MTD_ERASE_PRINTK
+			printk(KERN_DEBUG "mtd: %s: ERASE offset=@%08llx\n",
+			       mtd->name, erase->addr);
+#endif
 			/*
 			  FIXME: Allow INTERRUPTIBLE. Which means
 			  not having the wait_queue head on the stack.
diff -ruw linux-2.6.32.27/drivers/mtd/mtdcore.c linux-2.6.32.27-fbx/drivers/mtd/mtdcore.c
--- linux-2.6.32.27/drivers/mtd/mtdcore.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/mtdcore.c	2011-08-29 16:28:30.611828106 +0200
@@ -200,6 +200,33 @@
 }
 static DEVICE_ATTR(name, S_IRUGO, mtd_name_show, NULL);
 
+static ssize_t mtd_nand_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->nand_type);
+}
+static DEVICE_ATTR(nand_type, S_IRUGO, mtd_nand_type_show, NULL);
+
+static ssize_t mtd_nand_manufacturer_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->nand_manufacturer);
+}
+static DEVICE_ATTR(nand_manufacturer, S_IRUGO, mtd_nand_manufacturer_show, NULL);
+
+static ssize_t mtd_nand_onfi_version_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->onfi_version);
+}
+static DEVICE_ATTR(onfi_version, S_IRUGO, mtd_nand_onfi_version_show, NULL);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -210,6 +237,9 @@
 	&dev_attr_oobsize.attr,
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
+	&dev_attr_nand_type.attr,
+	&dev_attr_nand_manufacturer.attr,
+	&dev_attr_onfi_version.attr,
 	NULL,
 };
 
diff -ruw linux-2.6.32.27/drivers/mtd/mtdpart.c linux-2.6.32.27-fbx/drivers/mtd/mtdpart.c
--- linux-2.6.32.27/drivers/mtd/mtdpart.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/mtdpart.c	2011-08-29 16:28:30.611828106 +0200
@@ -351,6 +351,9 @@
 	slave->mtd.oobsize = master->oobsize;
 	slave->mtd.oobavail = master->oobavail;
 	slave->mtd.subpage_sft = master->subpage_sft;
+	slave->mtd.nand_type = master->nand_type;
+	slave->mtd.nand_manufacturer = master->nand_manufacturer;
+	slave->mtd.onfi_version = master->onfi_version;
 
 	slave->mtd.name = part->name;
 	slave->mtd.owner = master->owner;
diff -ruw linux-2.6.32.27/drivers/mtd/nand/Kconfig linux-2.6.32.27-fbx/drivers/mtd/nand/Kconfig
--- linux-2.6.32.27/drivers/mtd/nand/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/Kconfig	2011-08-29 16:28:19.281727536 +0200
@@ -36,6 +36,15 @@
 	  NAND chips (page size 256 byte, erase size 4-8KiB). The IDs
 	  of these chips were reused by later, larger chips.
 
+config MTD_FORCE_BAD_BLOCK_ERASE
+	bool "Force erase on bad blocks (useful for bootloader parts)"
+	depends on MTD_NAND
+	default n
+	help
+	  Enable this option only when you need to force an erase on
+	  blocks being marked as "bad" by Linux (i.e: other ECC/bad block
+	  marker layout).
+
 config MTD_NAND_AUTCPU12
 	tristate "SmartMediaCard on autronix autcpu12 board"
 	depends on ARCH_AUTCPU12
@@ -482,4 +491,9 @@
 	  This enables the driver for the NAND Flash on evaluation board based
 	  on w90p910.
 
+config MTD_NAND_DENALI
+	tristate "NAND Denali controller support"
+	depends on MTD_NAND && PCI
+	default n
+
 endif # MTD_NAND
diff -ruw linux-2.6.32.27/drivers/mtd/nand/Makefile linux-2.6.32.27-fbx/drivers/mtd/nand/Makefile
--- linux-2.6.32.27/drivers/mtd/nand/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/Makefile	2011-08-29 16:28:19.281727536 +0200
@@ -42,5 +42,6 @@
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
+obj-$(CONFIG_MTD_NAND_DENALI)		+= denali_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff -ruw linux-2.6.32.27/drivers/mtd/nand/nand_base.c linux-2.6.32.27-fbx/drivers/mtd/nand/nand_base.c
--- linux-2.6.32.27/drivers/mtd/nand/nand_base.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/nand_base.c	2011-08-29 16:28:30.621828195 +0200
@@ -2237,6 +2237,7 @@
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
+#ifndef CONFIG_MTD_FORCE_BAD_BLOCK_ERASE
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
 			printk(KERN_WARNING "%s: attempt to erase a bad block "
@@ -2244,6 +2245,7 @@
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
+#endif
 
 		/*
 		 * Invalidate the page cache, if we erase the block which
@@ -2461,6 +2463,83 @@
 }
 
 /*
+ * sanitize ONFI strings so we can safely print them
+ */
+static void sanitize_string(uint8_t *s, size_t len)
+{
+	ssize_t i;
+
+	/* null terminate */
+	s[len - 1] = 0;
+
+	/* remove non printable chars */
+	for (i = 0; i < len - 1; i++) {
+		if (s[i] < ' ' || s[i] > 127)
+			s[i] = '?';
+	}
+
+	/* remove trailing spaces */
+	for (i = len - 1; i >= 0; i--) {
+		if (s[i] && s[i] != ' ')
+			break;
+		s[i] = 0;
+	}
+}
+
+/*
+ * Check whether flash support ONFI and read ONFI parameters in that
+ * case
+ */
+static void nand_read_onfi(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct nand_onfi_params *p;
+	uint8_t sig[4];
+	uint16_t val;
+
+	BUG_ON(!chip->cmdfunc);
+	BUG_ON(!chip->read_buf);
+
+	/* read ONFI signature */
+	chip->cmdfunc(mtd, NAND_CMD_READID, NAND_ADDR_ONFI_ID, -1);
+	chip->read_buf(mtd, sig, sizeof(sig));
+
+	if (memcmp(sig, "ONFI", sizeof(sig)))
+		return;
+
+	/* ONFI seems supported */
+	chip->cmdfunc(mtd, NAND_CMD_READ_ONFI_PARAMS, 0, -1);
+	p = &chip->onfi_params;
+	chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
+
+	/* recheck signature */
+	if (memcmp(p->sig, "ONFI", sizeof(p->sig))) {
+		printk(KERN_INFO "%s: bad ONFI params signature\n", __func__);
+		return;
+	}
+
+	/* check version */
+	val = le16_to_cpu(p->revision);
+	if (!is_power_of_2(val) || val == 1 || val > (1 << 4)) {
+		printk(KERN_INFO "%s: unsupported ONFI version\n", __func__);
+		return;
+	}
+
+	if (val & (1 << 1))
+		chip->onfi_version = 10;
+	else if (val & (1 << 2))
+		chip->onfi_version = 20;
+	else if (val & (1 << 3))
+		chip->onfi_version = 21;
+	else
+		chip->onfi_version = 22;
+
+	chip->options |= NAND_ONFI;
+
+	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
+	sanitize_string(p->model, sizeof(p->model));
+}
+
+/*
  * Get the flash and manufacturer id and lookup if the type is supported
  */
 static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
@@ -2470,6 +2549,8 @@
 	struct nand_flash_dev *type = NULL;
 	int i, dev_id, maf_idx;
 	int tmp_id, tmp_manf;
+	char onfi_version[4];
+	int ret;
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
@@ -2613,11 +2694,49 @@
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
+	nand_read_onfi(mtd, chip);
+
 	printk(KERN_INFO "NAND device: Manufacturer ID:"
 	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
 	       nand_manuf_ids[maf_idx].name, type->name);
 
+	mtd->nand_type = kstrdup(type->name, GFP_KERNEL);
+	if (!mtd->nand_type)
+		return ERR_PTR(-ENOMEM);
+
+	mtd->nand_manufacturer = kstrdup(nand_manuf_ids[maf_idx].name, GFP_KERNEL);
+	if (!mtd->nand_manufacturer) {
+		ret = -ENOMEM;
+		goto out_nand_type;
+	}
+
+	snprintf(onfi_version, sizeof(onfi_version), "0");
+
+	if (chip->options & NAND_ONFI) {
+		snprintf(onfi_version, sizeof(onfi_version), "%d.%d",
+						chip->onfi_version / 10,
+						chip->onfi_version % 10);
+		mtd->onfi_version = kstrdup(onfi_version, GFP_KERNEL);
+
+		printk(KERN_INFO "NAND is ONFI %s compliant "
+		       "(man:%s model:%s)\n",
+			onfi_version,
+		       chip->onfi_params.manufacturer,
+		       chip->onfi_params.model);
+	}
+	mtd->onfi_version = kstrdup(onfi_version, GFP_KERNEL);
+	if (!mtd->onfi_version) {
+		ret = -ENOMEM;
+		goto out_nand_manufacturer;
+	}
+
 	return type;
+
+out_nand_manufacturer:
+	kfree(mtd->nand_manufacturer);
+out_nand_type:
+	kfree(mtd->nand_type);
+	return ERR_PTR(ret);
 }
 
 /**
@@ -2635,6 +2754,7 @@
 	int i, busw, nand_maf_id;
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
+	int err;
 
 	/* Get buswidth to select the correct functions */
 	busw = chip->options & NAND_BUSWIDTH_16;
@@ -2647,7 +2767,8 @@
 	if (IS_ERR(type)) {
 		printk(KERN_WARNING "No NAND device found!!!\n");
 		chip->select_chip(mtd, -1);
-		return PTR_ERR(type);
+		err = PTR_ERR(type);
+		goto out_error;
 	}
 
 	/* Check for a chip array */
@@ -2670,6 +2791,16 @@
 	mtd->size = i * chip->chipsize;
 
 	return 0;
+
+out_error:
+	if (mtd->nand_type)
+		kfree(mtd->nand_type);
+	if (mtd->nand_manufacturer)
+		kfree(mtd->nand_manufacturer);
+	if (mtd->onfi_version)
+		kfree(mtd->onfi_version);
+
+	return err;
 }
 
 
@@ -2791,9 +2922,13 @@
 		chip->ecc.read_page = nand_read_page_swecc;
 		chip->ecc.read_subpage = nand_read_subpage;
 		chip->ecc.write_page = nand_write_page_swecc;
+		if (!chip->ecc.read_page_raw)
 		chip->ecc.read_page_raw = nand_read_page_raw;
+		if (!chip->ecc.write_page_raw)
 		chip->ecc.write_page_raw = nand_write_page_raw;
+		if (!chip->ecc.read_oob)
 		chip->ecc.read_oob = nand_read_oob_std;
+		if (!chip->ecc.write_oob)
 		chip->ecc.write_oob = nand_write_oob_std;
 		if (!chip->ecc.size)
 			chip->ecc.size = 256;
@@ -2956,6 +3091,10 @@
 	kfree(chip->bbt);
 	if (!(chip->options & NAND_OWN_BUFFERS))
 		kfree(chip->buffers);
+
+	kfree(mtd->nand_type);
+	kfree(mtd->nand_manufacturer);
+	kfree(mtd->onfi_version);
 }
 
 EXPORT_SYMBOL_GPL(nand_scan);
diff -ruw linux-2.6.32.27/drivers/mtd/nand/nand_ids.c linux-2.6.32.27-fbx/drivers/mtd/nand/nand_ids.c
--- linux-2.6.32.27/drivers/mtd/nand/nand_ids.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/nand_ids.c	2011-08-29 16:28:19.301727714 +0200
@@ -82,6 +82,7 @@
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3,3V 8-bit",	0xD1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
 
diff -ruw linux-2.6.32.27/drivers/net/e1000/e1000_hw.c linux-2.6.32.27-fbx/drivers/net/e1000/e1000_hw.c
--- linux-2.6.32.27/drivers/net/e1000/e1000_hw.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/e1000/e1000_hw.c	2011-08-29 16:28:19.461729136 +0200
@@ -31,6 +31,12 @@
  */
 
 #include "e1000_hw.h"
+#include "gbe_mac_access.h"
+
+int (* gbe_config_media_read)(void  __iomem * config_ram_base_t, int length);
+int (* gbe_config_media_write)(void  __iomem * config_ram_base_t, int length);
+EXPORT_SYMBOL(gbe_config_media_read);
+EXPORT_SYMBOL(gbe_config_media_write);
 
 static s32 e1000_check_downshift(struct e1000_hw *hw);
 static s32 e1000_check_polarity(struct e1000_hw *hw,
@@ -124,6 +130,7 @@
 	case M88E1000_I_PHY_ID:
 	case M88E1011_I_PHY_ID:
 	case M88E1111_I_PHY_ID:
+	case M88E1118_E_PHY_ID:
 		hw->phy_type = e1000_phy_m88;
 		break;
 	case IGP01E1000_I_PHY_ID:
@@ -318,6 +325,9 @@
 	case E1000_DEV_ID_82547GI:
 		hw->mac_type = e1000_82547_rev_2;
 		break;
+	case E1000_DEV_ID_INTEL_CE_GBE:
+		hw->mac_type = e1000_cegbe;
+		break;
 	default:
 		/* Should never have loaded on this device */
 		return -E1000_ERR_MAC_TYPE;
@@ -460,6 +470,7 @@
 		/* Reset is performed on a shadow of the control register */
 		ew32(CTRL_DUP, (ctrl | E1000_CTRL_RST));
 		break;
+	case e1000_cegbe:
 	default:
 		ew32(CTRL, (ctrl | E1000_CTRL_RST));
 		break;
@@ -1342,7 +1353,7 @@
 	s32 ret_val;
 	DEBUGFUNC("e1000_copper_link_postconfig");
 
-	if (hw->mac_type >= e1000_82544) {
+	if (hw->mac_type >= e1000_82544 && (hw->mac_type != e1000_cegbe)) {
 		e1000_config_collision_dist(hw);
 	} else {
 		ret_val = e1000_config_mac_to_phy(hw);
@@ -1426,6 +1437,8 @@
 		if (ret_val)
 			return ret_val;
 
+		hw->cegbe_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
+
 		if (phy_data & MII_SR_LINK_STATUS) {
 			/* Config the MAC and PHY after link is up */
 			ret_val = e1000_copper_link_postconfig(hw);
@@ -1861,7 +1874,7 @@
 
 	/* 82544 or newer MAC, Auto Speed Detection takes care of
 	 * MAC speed/duplex configuration.*/
-	if (hw->mac_type >= e1000_82544)
+	if (hw->mac_type >= e1000_82544 && hw->mac_type != e1000_cegbe)
 		return E1000_SUCCESS;
 
 	/* Read the Device Control Register and set the bits to Force Speed
@@ -2353,6 +2366,8 @@
 		if (ret_val)
 			return ret_val;
 
+		hw->cegbe_is_link_up = (phy_data & MII_SR_LINK_STATUS) != 0;
+
 		if (phy_data & MII_SR_LINK_STATUS) {
 			hw->get_link_status = false;
 			/* Check if there was DownShift, must be checked immediately after
@@ -2402,7 +2417,7 @@
 		 * speed/duplex on the MAC to the current PHY speed/duplex
 		 * settings.
 		 */
-		if (hw->mac_type >= e1000_82544)
+		if (hw->mac_type >= e1000_82544 && hw->mac_type != e1000_cegbe)
 			e1000_config_collision_dist(hw);
 		else {
 			ret_val = e1000_config_mac_to_phy(hw);
@@ -2739,7 +2754,7 @@
 {
 	u32 i;
 	u32 mdic = 0;
-	const u32 phy_addr = 1;
+	const u32 phy_addr = hw->phy_addr;
 
 	DEBUGFUNC("e1000_read_phy_reg_ex");
 
@@ -2753,6 +2768,34 @@
 		 * Control register.  The MAC will take care of interfacing with the
 		 * PHY to retrieve the desired data.
 		 */
+		if (hw->mac_type == e1000_cegbe ) {
+			mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+					(phy_addr << E1000_MDIC_PHY_SHIFT) |
+					(INTEL_CE_GBE_MDIC_OP_READ) |
+					(INTEL_CE_GBE_MDIC_GO));
+
+			writel(mdic, E1000_MDIO_CMD);
+
+			/* Poll the ready bit to see if the MDI read completed */
+			for (i = 0; i < 64; i++) {
+				udelay(50);
+				mdic = readl(E1000_MDIO_CMD);
+				if (!(mdic & INTEL_CE_GBE_MDIC_GO))
+					break;
+			}
+
+			if (mdic & INTEL_CE_GBE_MDIC_GO) {
+				DEBUGOUT("MDI Read did not complete\n");
+				return -E1000_ERR_PHY;
+			}
+
+			mdic = readl(E1000_MDIO_STS);
+			if (mdic & INTEL_CE_GBE_MDIC_READ_ERROR) {
+				DEBUGOUT("MDI Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+			*phy_data = (uint16_t) mdic;
+		} else {
 		mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
 			(phy_addr << E1000_MDIC_PHY_SHIFT) |
 			(E1000_MDIC_OP_READ));
@@ -2775,6 +2818,7 @@
 			return -E1000_ERR_PHY;
 		}
 		*phy_data = (u16) mdic;
+		}
 	} else {
 		/* We must first send a preamble through the MDIO pin to signal the
 		 * beginning of an MII instruction.  This is done by sending 32
@@ -2841,7 +2885,7 @@
 {
 	u32 i;
 	u32 mdic = 0;
-	const u32 phy_addr = 1;
+	const u32 phy_addr = hw->phy_addr;
 
 	DEBUGFUNC("e1000_write_phy_reg_ex");
 
@@ -2855,6 +2899,28 @@
 		 * for the PHY register in the MDI Control register.  The MAC will take
 		 * care of interfacing with the PHY to send the desired data.
 		 */
+		if (hw->mac_type == e1000_cegbe) {
+			mdic = (((uint32_t) phy_data) |
+				(reg_addr << E1000_MDIC_REG_SHIFT) |
+				(phy_addr << E1000_MDIC_PHY_SHIFT) |
+				(INTEL_CE_GBE_MDIC_OP_WRITE) |
+				(INTEL_CE_GBE_MDIC_GO ));
+
+			writel(mdic, E1000_MDIO_CMD);
+
+			/* Poll the ready bit to see if the MDI read completed */
+			for(i = 0; i < 640; i++) {
+				udelay(5);
+				mdic = readl(E1000_MDIO_CMD);
+				if(!(mdic & INTEL_CE_GBE_MDIC_GO))
+					break;
+			}
+
+			if (mdic & INTEL_CE_GBE_MDIC_GO) {
+				DEBUGOUT("MDI Write did not complete\n");
+				return -E1000_ERR_PHY;
+			}
+		} else {
 		mdic = (((u32) phy_data) |
 			(reg_addr << E1000_MDIC_REG_SHIFT) |
 			(phy_addr << E1000_MDIC_PHY_SHIFT) |
@@ -2873,6 +2939,7 @@
 			DEBUGOUT("MDI Write did not complete\n");
 			return -E1000_ERR_PHY;
 		}
+		}
 	} else {
 		/* We'll need to use the SW defined pins to shift the write command
 		 * out to the PHY. We first send a preamble to the PHY to signal the
@@ -3011,6 +3078,7 @@
 {
 	s32 phy_init_status, ret_val;
 	u16 phy_id_high, phy_id_low;
+	int i;
 	bool match = false;
 
 	DEBUGFUNC("e1000_detect_gig_phy");
@@ -3019,9 +3087,14 @@
 		return E1000_SUCCESS;
 
 	/* Read the PHY ID Registers to identify which PHY is onboard. */
+	for (i = 0; i < MAX_PHY_ADDR; i++) {
+		hw->phy_addr = i;
 	ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high);
 	if (ret_val)
-		return ret_val;
+			continue;
+		else
+			break;
+	}
 
 	hw->phy_id = (u32) (phy_id_high << 16);
 	udelay(20);
@@ -3056,6 +3129,10 @@
 		if (hw->phy_id == IGP01E1000_I_PHY_ID)
 			match = true;
 		break;
+	case e1000_cegbe:
+		if (hw->phy_id == M88E1118_E_PHY_ID)
+			match = true;
+		break;
 	default:
 		DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
 		return -E1000_ERR_CONFIG;
@@ -3318,10 +3395,13 @@
 s32 e1000_init_eeprom_params(struct e1000_hw *hw)
 {
 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
-	u32 eecd = er32(EECD);
+	u32 eecd = 0;
 	s32 ret_val = E1000_SUCCESS;
 	u16 eeprom_size;
 
+	if (hw->mac_type != e1000_cegbe)
+		eecd = er32(EECD);
+
 	DEBUGFUNC("e1000_init_eeprom_params");
 
 	switch (hw->mac_type) {
@@ -3743,6 +3823,14 @@
 
 	DEBUGFUNC("e1000_read_eeprom");
 
+	if( hw->mac_type ==  e1000_cegbe ){
+		if(gbe_config_read_words(GBE_CONFIG_BASE_VIRT, offset, words, data))
+			return -E1000_ERR_EEPROM;
+		
+		return E1000_SUCCESS;
+	}
+
+
 	/* If eeprom is not yet detected, do so now */
 	if (eeprom->word_size == 0)
 		e1000_init_eeprom_params(hw);
@@ -3906,6 +3994,14 @@
 
 	DEBUGFUNC("e1000_write_eeprom");
 
+	if( hw->mac_type ==  e1000_cegbe ){
+		if(gbe_config_write_words(GBE_CONFIG_BASE_VIRT, offset, words, data))
+			return -E1000_ERR_EEPROM;
+
+		return E1000_SUCCESS;
+	}
+
+
 	/* If eeprom is not yet detected, do so now */
 	if (eeprom->word_size == 0)
 		e1000_init_eeprom_params(hw);
diff -ruw linux-2.6.32.27/drivers/net/e1000/e1000_hw.h linux-2.6.32.27-fbx/drivers/net/e1000/e1000_hw.h
--- linux-2.6.32.27/drivers/net/e1000/e1000_hw.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/e1000/e1000_hw.h	2011-08-29 16:28:19.461729136 +0200
@@ -51,6 +51,7 @@
 	e1000_82545,
 	e1000_82545_rev_3,
 	e1000_82546,
+	e1000_cegbe,
 	e1000_82546_rev_3,
 	e1000_82541,
 	e1000_82541_rev_2,
@@ -441,6 +442,7 @@
 #define E1000_DEV_ID_82547EI             0x1019
 #define E1000_DEV_ID_82547EI_MOBILE      0x101A
 #define E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3 0x10B5
+#define E1000_DEV_ID_INTEL_CE_GBE	 0x2E6E
 
 #define NODE_ADDRESS_SIZE 6
 #define ETH_LENGTH_OF_ADDRESS 6
@@ -807,6 +809,16 @@
 #define E1000_CTRL_EXT 0x00018	/* Extended Device Control - RW */
 #define E1000_FLA      0x0001C	/* Flash Access - RW */
 #define E1000_MDIC     0x00020	/* MDI Control - RW */
+
+extern void  __iomem * intel_ce_gbe_mdio_base_virt;
+#define INTEL_CE_GBE_MDIO_RCOMP_BASE	(intel_ce_gbe_mdio_base_virt)
+#define E1000_MDIO_STS			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 0 )
+#define E1000_MDIO_CMD			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 4 )
+#define E1000_MDIO_DRV			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 8 )
+#define E1000_MDC_DRV			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 0xC )
+#define E1000_RCOMP_CTL			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 0x20 )
+#define E1000_RCOMP_STS			(INTEL_CE_GBE_MDIO_RCOMP_BASE + 0x24 )
+
 #define E1000_SCTL     0x00024	/* SerDes Control - RW */
 #define E1000_FEXTNVM  0x00028	/* Future Extended NVM register */
 #define E1000_FCAL     0x00028	/* Flow Control Address Low - RW */
@@ -819,6 +831,26 @@
 #define E1000_IMS      0x000D0	/* Interrupt Mask Set - RW */
 #define E1000_IMC      0x000D8	/* Interrupt Mask Clear - WO */
 #define E1000_IAM      0x000E0	/* Interrupt Acknowledge Auto Mask */
+
+#define E1000_CTL_AUX  0x000E0  /* Auxiliary Control Register. This register is Intel Gen3 specific,
+				 * RMII/RGMII function is switched by this register - RW */
+/* Following are bits definitions of the Auxiliary Control Register */
+#define E1000_CTL_AUX_END_SEL_SHIFT            10
+#define E1000_CTL_AUX_ENDIANESS_SHIFT  8
+#define E1000_CTL_AUX_RGMII_RMII_SHIFT 0
+
+#define E1000_CTL_AUX_DES_PKT	(0x0 << E1000_CTL_AUX_END_SEL_SHIFT)/* descriptor and packet transfer use CTL_AUX.ENDIANESS*/
+#define E1000_CTL_AUX_DES	(0x1 << E1000_CTL_AUX_END_SEL_SHIFT)/* descriptor use CTL_AUX.ENDIANESS, packet use default*/
+#define E1000_CTL_AUX_PKT	(0x2 << E1000_CTL_AUX_END_SEL_SHIFT)/* descriptor use default, packet use CTL_AUX.ENDIANESS*/
+#define E1000_CTL_AUX_ALL	(0x3 << E1000_CTL_AUX_END_SEL_SHIFT)/* all use CTL_AUX.ENDIANESS*/
+#define E1000_CTL_AUX_RGMII	(0x0 << E1000_CTL_AUX_RGMII_RMII_SHIFT)
+#define E1000_CTL_AUX_RMII	(0x1 << E1000_CTL_AUX_RGMII_RMII_SHIFT)
+
+#define E1000_CTL_AUX_LWLE_BBE	(0x0 << E1000_CTL_AUX_ENDIANESS_SHIFT)  /* LW little endian, Byte big endian */
+#define E1000_CTL_AUX_LWLE_BLE	(0x1 << E1000_CTL_AUX_ENDIANESS_SHIFT)  /* LW little endian, Byte little endian */
+#define E1000_CTL_AUX_LWBE_BBE	(0x2 << E1000_CTL_AUX_ENDIANESS_SHIFT)  /* LW big endian, Byte big endian */
+#define E1000_CTL_AUX_LWBE_BLE	(0x3 << E1000_CTL_AUX_ENDIANESS_SHIFT)  /* LW big endian, Byte little endian */
+
 #define E1000_RCTL     0x00100	/* RX Control - RW */
 #define E1000_RDTR1    0x02820	/* RX Delay Timer (1) - RW */
 #define E1000_RDBAL1   0x02900	/* RX Descriptor Base Address Low (1) - RW */
@@ -1380,6 +1412,7 @@
 	bool leave_av_bit_off;
 	bool bad_tx_carr_stats_fd;
 	bool has_smbus;
+	bool cegbe_is_link_up;
 };
 
 #define E1000_EEPROM_SWDPIN0   0x0001	/* SWDPIN 0 EEPROM Value */
@@ -1570,6 +1603,11 @@
 #define E1000_MDIC_INT_EN    0x20000000
 #define E1000_MDIC_ERROR     0x40000000
 
+#define INTEL_CE_GBE_MDIC_OP_WRITE	0x04000000
+#define INTEL_CE_GBE_MDIC_OP_READ	0x00000000
+#define INTEL_CE_GBE_MDIC_GO		0x80000000
+#define INTEL_CE_GBE_MDIC_READ_ERROR	0x80000000
+
 #define E1000_KUMCTRLSTA_MASK           0x0000FFFF
 #define E1000_KUMCTRLSTA_OFFSET         0x001F0000
 #define E1000_KUMCTRLSTA_OFFSET_SHIFT   16
@@ -2460,6 +2498,7 @@
 #define PHY_1000T_STATUS 0x0A	/* 1000Base-T Status Reg */
 #define PHY_EXT_STATUS   0x0F	/* Extended Status Reg */
 
+#define MAX_PHY_ADDR		   32   /* Maximum PHY address */
 #define MAX_PHY_REG_ADDRESS        0x1F	/* 5 bit address bus (0-0x1F) */
 #define MAX_PHY_MULTI_PAGE_REG     0xF	/* Registers equal on all pages */
 
@@ -2868,6 +2907,7 @@
 #define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
 #define M88E1011_I_REV_4   0x04
 #define M88E1111_I_PHY_ID  0x01410CC0
+#define M88E1118_E_PHY_ID  0x01410E40
 #define L1LXT971A_PHY_ID   0x001378E0
 
 /* Bits...
diff -ruw linux-2.6.32.27/drivers/net/e1000/e1000_main.c linux-2.6.32.27-fbx/drivers/net/e1000/e1000_main.c
--- linux-2.6.32.27/drivers/net/e1000/e1000_main.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/e1000/e1000_main.c	2011-08-29 16:28:19.471729225 +0200
@@ -27,7 +27,11 @@
 *******************************************************************************/
 
 #include "e1000.h"
+#include "gbe_mac_access.h"
 #include <net/ip6_checksum.h>
+#ifdef CONFIG_FBXSERIAL
+#include <linux/fbxserial.h>
+#endif
 
 char e1000_driver_name[] = "e1000";
 static char e1000_driver_string[] = "Intel(R) PRO/1000 Network Driver";
@@ -35,6 +39,11 @@
 const char e1000_driver_version[] = DRV_VERSION;
 static const char e1000_copyright[] = "Copyright (c) 1999-2006 Intel Corporation.";
 
+static unsigned long intel_ce_gbe_mdio_base_phy;	//Intel Media SOC GbE MDIO physical base address
+void __iomem * intel_ce_gbe_mdio_base_virt;		//Intel Media SOC GbE MDIO virtual base address
+void __iomem * gbe_config_base_virt;			//Intel Media SOC FLASH virtual base address
+
+
 /* e1000_pci_tbl - PCI Device ID Table
  *
  * Last entry must be all 0s
@@ -79,6 +88,7 @@
 	INTEL_E1000_ETHERNET_DEVICE(0x108A),
 	INTEL_E1000_ETHERNET_DEVICE(0x1099),
 	INTEL_E1000_ETHERNET_DEVICE(0x10B5),
+	INTEL_E1000_ETHERNET_DEVICE(0x2E6E),
 	/* required last entry */
 	{0,}
 };
@@ -450,6 +460,7 @@
 		case e1000_82545:
 		case e1000_82545_rev_3:
 		case e1000_82546:
+		case e1000_cegbe:
 		case e1000_82546_rev_3:
 		case e1000_82541:
 		case e1000_82541_rev_2:
@@ -548,6 +559,7 @@
 	case e1000_82545:
 	case e1000_82545_rev_3:
 	case e1000_82546:
+	case e1000_cegbe:
 	case e1000_82546_rev_3:
 		pba = E1000_PBA_48K;
 		break;
@@ -678,6 +690,7 @@
 /**
  *  Dump the eeprom for users having checksum issues
  **/
+#ifndef CONFIG_FBXSERIAL
 static void e1000_dump_eeprom(struct e1000_adapter *adapter)
 {
 	struct net_device *netdev = adapter->netdev;
@@ -732,6 +745,7 @@
 
 	kfree(data);
 }
+#endif
 
 /**
  * e1000_is_need_ioport - determine if an adapter needs ioport resources or not
@@ -926,11 +940,36 @@
 		goto err_eeprom;
 	}
 
+	/* MDIO is at a different location on Intel CE GBE MAC */	
+	if (adapter->hw.mac_type == e1000_cegbe) {
+		intel_ce_gbe_mdio_base_phy = pci_resource_start(pdev, BAR_1);
+		intel_ce_gbe_mdio_base_virt = ioremap(intel_ce_gbe_mdio_base_phy,
+						pci_resource_len(pdev, BAR_1));
+
+		if(!intel_ce_gbe_mdio_base_virt)
+			goto err_mdio_ioremap;
+		
+		gbe_config_base_virt = ioremap(GBE_CONFIG_RAM_BASE, GBE_CONFIG_DATA_LENGTH);
+		if (!gbe_config_base_virt) {
+			gbe_config_base_virt = ioremap(0xC1F00000, GBE_CONFIG_DATA_LENGTH);
+			if(!gbe_config_base_virt)
+				goto err_sw_init;
+		}
+	}
+
 	/* before reading the EEPROM, reset the controller to
 	 * put the device in a known good starting state */
 
 	e1000_reset_hw(hw);
 
+#ifdef CONFIG_FBXSERIAL
+	fbxserialinfo_get_mac_addr(hw->mac_addr);
+	printk("e1000: using mac address %02x:%02x:%02x:%02x:%02x:%02x "
+	       "(fbxserial)\n",
+	       hw->mac_addr[0], hw->mac_addr[1], hw->mac_addr[2],
+	       hw->mac_addr[3], hw->mac_addr[4], hw->mac_addr[5]);
+	(void)e1000_validate_eeprom_checksum;
+#else
 	/* make sure the EEPROM is good */
 	if (e1000_validate_eeprom_checksum(hw) < 0) {
 		DPRINTK(PROBE, ERR, "The EEPROM Checksum Is Not Valid\n");
@@ -949,6 +988,8 @@
 		if (e1000_read_mac_addr(hw))
 			DPRINTK(PROBE, ERR, "EEPROM Read Error\n");
 	}
+#endif
+
 	/* don't block initalization here due to bad MAC address */
 	memcpy(netdev->dev_addr, hw->mac_addr, netdev->addr_len);
 	memcpy(netdev->perm_addr, hw->mac_addr, netdev->addr_len);
@@ -1071,6 +1112,9 @@
 	kfree(adapter->tx_ring);
 	kfree(adapter->rx_ring);
 err_sw_init:
+	iounmap(gbe_config_base_virt);
+err_mdio_ioremap:
+	iounmap(intel_ce_gbe_mdio_base_virt);
 	iounmap(hw->hw_addr);
 err_ioremap:
 	free_netdev(netdev);
@@ -1194,6 +1238,14 @@
 		return -ENOMEM;
 	}
 
+	/*
+	 * for Intel CE SoC MAC controller, it is necessary to keep
+	 * track of the last known state of the link to determine if
+	 * the link experienced a change in state when watchdog
+	 * fires
+	 */
+	adapter->hw.cegbe_is_link_up = false;
+
 	/* Explicitly disable IRQ since the NIC can be in any state. */
 	e1000_irq_disable(adapter);
 
@@ -1360,6 +1412,7 @@
 	/* First rev 82545 and 82546 need to not allow any memory
 	 * write location to cross 64k boundary due to errata 23 */
 	if (hw->mac_type == e1000_82545 ||
+	    hw->mac_type == e1000_cegbe ||
 	    hw->mac_type == e1000_82546) {
 		return ((begin ^ (end - 1)) >> 16) != 0 ? false : true;
 	}
@@ -2243,6 +2296,8 @@
 {
 	struct e1000_hw *hw = &adapter->hw;
 	bool link_active = false;
+	s32 ret_val;
+	u16 link_up;
 
 	/* get_link_status is set on LSC (link status) interrupt or
 	 * rx sequence error interrupt.  get_link_status will stay
@@ -2251,6 +2306,23 @@
 	 */
 	switch (hw->media_type) {
 	case e1000_media_type_copper:
+		/*
+	 	 * Test the PHY for link status on Intel CE SoC MAC.
+	 	 * If the link status is different than the last link status stored
+	 	 * in the adapter->hw structure, then set hw->get_link_status = 1
+	 	 */
+		if (adapter->hw.mac_type == e1000_cegbe) {
+			ret_val = e1000_read_phy_reg(&adapter->hw, PHY_STATUS, &link_up);
+			ret_val = e1000_read_phy_reg(&adapter->hw, PHY_STATUS, &link_up);
+			if (ret_val)
+				DPRINTK(LINK, INFO, "Link status detection from PHY failed!\n");
+		
+			link_up &= MII_SR_LINK_STATUS;
+			if(link_up != adapter->hw.cegbe_is_link_up)
+				adapter->hw.get_link_status = true;
+			else
+				adapter->hw.get_link_status = false;
+		}
 		if (hw->get_link_status) {
 			e1000_check_for_link(hw);
 			link_active = !hw->get_link_status;
@@ -2284,11 +2356,21 @@
 	struct net_device *netdev = adapter->netdev;
 	struct e1000_tx_ring *txdr = adapter->tx_ring;
 	u32 link, tctl;
+	s32 ret_val;
+	u16 link_up;
 
 	link = e1000_has_link(adapter);
 	if ((netif_carrier_ok(netdev)) && link)
 		goto link_up;
 
+	if (adapter->hw.mac_type == e1000_cegbe) {
+		ret_val = e1000_read_phy_reg(&adapter->hw, PHY_STATUS, &link_up);
+		ret_val = e1000_read_phy_reg(&adapter->hw, PHY_STATUS, &link_up);
+		if (ret_val)
+			DPRINTK(LINK, INFO, "Link status detection from PHY failed!\n");
+		link = link_up & MII_SR_LINK_STATUS;
+	}
+
 	if (link) {
 		if (!netif_carrier_ok(netdev)) {
 			u32 ctrl;
diff -ruw linux-2.6.32.27/drivers/net/Kconfig linux-2.6.32.27-fbx/drivers/net/Kconfig
--- linux-2.6.32.27/drivers/net/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/Kconfig	2011-08-29 16:28:19.331727981 +0200
@@ -553,6 +553,21 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called sunhme.
 
+config TANGO2_ENET
+	tristate "SMP863x Builtin Ethernet support"
+	depends on NET_ETHERNET && TANGO2
+	select MII
+	select CRC32
+	help
+	 This option adds support for the SMP863x integrated Ethernet
+	 controller.  This driver uses NAPI and generic Linux MII
+	 support.
+
+config TANGO2_PCINET_H
+	tristate "SMP863x network over PCI support (smp863x side)"
+	depends on NET_ETHERNET && TANGO2
+
+
 config SUNBMAC
 	tristate "Sun BigMAC 10/100baseT support (EXPERIMENTAL)"
 	depends on SBUS && EXPERIMENTAL
@@ -2401,6 +2416,7 @@
 	depends on MV64X60 || PPC32 || PLAT_ORION
 	select INET_LRO
 	select PHYLIB
+	select MII
 	help
 	  This driver supports the gigabit ethernet MACs in the
 	  Marvell Discovery PPC/MIPS chipset family (MV643XX) and
diff -ruw linux-2.6.32.27/drivers/net/Makefile linux-2.6.32.27-fbx/drivers/net/Makefile
--- linux-2.6.32.27/drivers/net/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/Makefile	2011-08-29 16:28:19.331727981 +0200
@@ -52,6 +52,8 @@
 obj-$(CONFIG_SUNLANCE) += sunlance.o
 obj-$(CONFIG_SUNQE) += sunqe.o
 obj-$(CONFIG_SUNBMAC) += sunbmac.o
+obj-$(CONFIG_TANGO2_ENET) += tango2_enet.o
+obj-$(CONFIG_TANGO2_PCINET_H) += tango2_pcinet_h.o
 obj-$(CONFIG_MYRI_SBUS) += myri_sbus.o
 obj-$(CONFIG_SUNGEM) += sungem.o sungem_phy.o
 obj-$(CONFIG_CASSINI) += cassini.o
diff -ruw linux-2.6.32.27/drivers/net/wireless/hostap/Kconfig linux-2.6.32.27-fbx/drivers/net/wireless/hostap/Kconfig
--- linux-2.6.32.27/drivers/net/wireless/hostap/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/wireless/hostap/Kconfig	2011-08-29 16:28:19.971733669 +0200
@@ -95,3 +95,7 @@
 
 	The driver can be compiled as a module and will be named
 	hostap_cs.
+
+config HOSTAP_CS_FBXDMAMUX
+	bool "use fbxdmamux for data transfer"
+	depends on HOSTAP_CS
diff -ruw linux-2.6.32.27/drivers/net/wireless/Kconfig linux-2.6.32.27-fbx/drivers/net/wireless/Kconfig
--- linux-2.6.32.27/drivers/net/wireless/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/net/wireless/Kconfig	2011-08-29 16:28:19.861732690 +0200
@@ -476,6 +476,11 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
 
+config MWL8K_MFG
+	bool "manufacturing mode"
+	depends on MWL8K
+
+
 source "drivers/net/wireless/p54/Kconfig"
 source "drivers/net/wireless/ath/Kconfig"
 source "drivers/net/wireless/ipw2x00/Kconfig"
diff -ruw linux-2.6.32.27/drivers/pci/Kconfig linux-2.6.32.27-fbx/drivers/pci/Kconfig
--- linux-2.6.32.27/drivers/pci/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/pci/Kconfig	2011-08-29 16:28:20.171735445 +0200
@@ -69,3 +69,9 @@
 	  physical resources.
 
 	  If unsure, say N.
+
+config PCI_INTELCE_PM
+	bool "PCI IntelCE Power Management"
+	depends on PCI && ARCH_GEN3
+	help
+	   PCI runtime management for IntelCE hardware
diff -ruw linux-2.6.32.27/drivers/pci/Makefile linux-2.6.32.27-fbx/drivers/pci/Makefile
--- linux-2.6.32.27/drivers/pci/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/pci/Makefile	2011-08-29 16:28:20.171735445 +0200
@@ -52,6 +52,7 @@
 # ACPI Related PCI FW Functions
 #
 obj-$(CONFIG_ACPI)    += pci-acpi.o
+obj-$(CONFIG_ARCH_GEN3)	+= pci-intelce_pm.o
 
 # Cardbus & CompactPCI use setup-bus
 obj-$(CONFIG_HOTPLUG) += setup-bus.o
diff -ruw linux-2.6.32.27/drivers/platform/Kconfig linux-2.6.32.27-fbx/drivers/platform/Kconfig
--- linux-2.6.32.27/drivers/platform/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/Kconfig	2011-08-29 16:28:20.201735712 +0200
@@ -3,3 +3,11 @@
 if X86
 source "drivers/platform/x86/Kconfig"
 endif
+
+if TANGO2
+source "drivers/platform/tango2/Kconfig"
+endif
+
+if ARCH_GEN3
+source "drivers/platform/intelce/Kconfig"
+endif
diff -ruw linux-2.6.32.27/drivers/platform/Makefile linux-2.6.32.27-fbx/drivers/platform/Makefile
--- linux-2.6.32.27/drivers/platform/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/Makefile	2011-08-29 16:28:20.201735712 +0200
@@ -3,3 +3,5 @@
 #
 
 obj-$(CONFIG_X86)		+= x86/
+obj-$(CONFIG_TANGO2)		+= tango2/
+obj-$(CONFIG_INTELCE)		+= intelce/
diff -ruw linux-2.6.32.27/drivers/serial/8250.c linux-2.6.32.27-fbx/drivers/serial/8250.c
--- linux-2.6.32.27/drivers/serial/8250.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/serial/8250.c	2011-08-29 16:28:20.911742021 +0200
@@ -39,6 +39,12 @@
 #include <linux/nmi.h>
 #include <linux/mutex.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/mach-tango2/tango2_gbus.h>
+
+extern unsigned long em8xxx_sys_frequency;
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -299,6 +305,13 @@
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
 		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
 	},
+	[PORT_INTELCE] = {
+		.name		= "IntelCE",
+		.fifo_size	= 32,
+		.tx_loadsz	= 32,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
+		.flags		= UART_CAP_FIFO | UART_CAP_UUE,
+	},
 };
 
 #if defined (CONFIG_SERIAL_8250_AU1X00)
@@ -399,14 +412,44 @@
 
 static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
+#ifdef CONFIG_TANGO2
+	unsigned long v;
+
+	/* no EFR on tango2 */
+	if (offset == UART_EFR)
+		v = 0;
+	else
+		v = gbus_readl((unsigned long)p->membase +
+			       (offset << p->regshift));
+	return v;
+#else
 	offset = map_8250_in_reg(p, offset) << p->regshift;
 	return readb(p->membase + offset);
+#endif
 }
 
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
+#ifdef CONFIG_TANGO2
+	/*
+	 * we add a special case for UART_DL register, since
+	 * register content has a different meaning for us.
+	 */
+	if (offset == UART_DL) {
+		/* select right clock source */
+		value = (em8xxx_sys_frequency / p->uartclk);
+	}
+
+	/* no EFR on tango2 */
+	if (offset != UART_EFR) {
+		offset = offset << p->regshift;
+		gbus_writel((unsigned long)p->membase + offset,
+			    value);
+	}
+#else
 	offset = map_8250_out_reg(p, offset) << p->regshift;
 	writeb(value, p->membase + offset);
+#endif
 }
 
 static void mem32_serial_out(struct uart_port *p, int offset, int value)
@@ -559,6 +602,7 @@
 #define serial_inp(up, offset)		serial_in(up, offset)
 #define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
+#ifndef CONFIG_TANGO2
 /* Uart divisor latch read */
 static inline int _serial_dl_read(struct uart_8250_port *up)
 {
@@ -611,6 +655,7 @@
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
 #endif
+#endif
 
 /*
  * For the 16C950
@@ -744,7 +789,11 @@
 static int size_fifo(struct uart_8250_port *up)
 {
 	unsigned char old_fcr, old_mcr, old_lcr;
+#ifdef CONFIG_TANGO2
+	unsigned short old_dll, old_dlm;
+#else
 	unsigned short old_dl;
+#endif
 	int count;
 
 	old_lcr = serial_inp(up, UART_LCR);
@@ -755,8 +804,14 @@
 		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
 	serial_outp(up, UART_MCR, UART_MCR_LOOP);
 	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+#ifdef CONFIG_TANGO2
+	old_dll = serial_inp(up, UART_DL) & 0xff;
+	old_dlm = serial_inp(up, UART_DL) >> 8;
+	serial_outp(up, UART_DL, 0x01);
+#else
 	old_dl = serial_dl_read(up);
 	serial_dl_write(up, 0x0001);
+#endif
 	serial_outp(up, UART_LCR, 0x03);
 	for (count = 0; count < 256; count++)
 		serial_outp(up, UART_TX, count);
@@ -767,7 +822,11 @@
 	serial_outp(up, UART_FCR, old_fcr);
 	serial_outp(up, UART_MCR, old_mcr);
 	serial_outp(up, UART_LCR, UART_LCR_DLAB);
+#ifdef CONFIG_TANGO2
+	serial_outp(up, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	serial_dl_write(up, old_dl);
+#endif
 	serial_outp(up, UART_LCR, old_lcr);
 
 	return count;
@@ -786,6 +845,16 @@
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
+#ifdef CONFIG_TANGO2
+	old_dll = serial_inp(p, UART_DL) & 0xff;
+	old_dlm = serial_inp(p, UART_DL) >> 8;
+
+	serial_outp(p, UART_DL, 0);
+
+	id = serial_inp(p, UART_DL);
+
+	serial_outp(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
 
@@ -796,6 +865,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -997,7 +1067,11 @@
 
 			serial_outp(up, UART_LCR, 0xE0);
 
+#ifdef CONFIG_TANGO2
+			quot = serial_inp(up, UART_DL);
+#else
 			quot = serial_dl_read(up);
+#endif
 			quot <<= 3;
 
 			status1 = serial_in(up, 0x04); /* EXCR2 */
@@ -1005,8 +1079,11 @@
 			status1 |= 0x10;  /* 1.625 divisor for baud_base --> 921600 */
 			serial_outp(up, 0x04, status1);
 
+#ifdef CONFIG_TANGO2
+			serial_outp(up, UART_DL, quot);
+#else
 			serial_dl_write(up, quot);
-
+#endif
 			serial_outp(up, UART_LCR, 0);
 
 			up->port.uartclk = 921600*16;
@@ -1058,11 +1135,15 @@
 		serial_outp(up, UART_IER, iersave | UART_IER_UUE);
 		if (serial_in(up, UART_IER) & UART_IER_UUE) {
 			/*
-			 * It's an Xscale.
+			 * It's an Xscale or an Intel Gen3/4 SoC
 			 * We'll leave the UART_IER_UUE bit set to 1 (enabled).
 			 */
 			DEBUG_AUTOCONF("Xscale ");
+#ifndef __i386__
 			up->port.type = PORT_XSCALE;
+#else
+			up->port.type = PORT_INTELCE;
+#endif
 			up->capabilities |= UART_CAP_UUE;
 			return;
 		}
@@ -1543,6 +1624,15 @@
 }
 
 /*
+ * The UART Tx interrupts are not set under some conditions and therefore serial
+ * transmission hangs. This is a silicon issue and has not been root caused. The
+ * workaround for this silicon issue checks UART_LSR_THRE bit and UART_LSR_TEMT
+ * bit of LSR register in interrupt handler to see whether at least one of these
+ * two bits is set, if so then process the transmit request. If this workaround
+ * is not applied, then the serial transmission may hang. This workaround is for
+ * errata number 9 in Errata - B step.
+*/
+/*
  * This is the serial driver's interrupt routine.
  *
  * Arjan thinks the old way was overly complex, so it got simplified.
@@ -1561,6 +1651,7 @@
 	struct irq_info *i = dev_id;
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
+	unsigned int flag;
 
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
@@ -1576,6 +1667,7 @@
 		iir = serial_in(up, UART_IIR);
 		if (!(iir & UART_IIR_NO_INT)) {
 			serial8250_handle_port(up);
+			flag |= 0x01;
 
 			handled = 1;
 
@@ -1593,7 +1685,8 @@
 			handled = 1;
 
 			end = NULL;
-		} else if (end == NULL)
+		}
+		else if (end == NULL)
 			end = l;
 
 		l = l->next;
@@ -2388,7 +2481,11 @@
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	}
 
+#ifdef CONFIG_TANGO2
+	serial_outp(up, UART_DL, quot);
+#else
 	serial_dl_write(up, quot);
+#endif
 
 	/*
 	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
@@ -2746,11 +2843,15 @@
 	 *	First save the IER then disable the interrupts
 	 */
 	ier = serial_in(up, UART_IER);
-
+#ifdef CONFIG_GEN3_UART
+	/* Should enable UUE (Uart Unit Enable) bit. */
+	serial_out(up, UART_IER, UART_IER_UUE);
+#else
 	if (up->capabilities & UART_CAP_UUE)
 		serial_out(up, UART_IER, UART_IER_UUE);
 	else
 		serial_out(up, UART_IER, 0);
+#endif
 
 	uart_console_write(&up->port, s, count, serial8250_console_putchar);
 
diff -ruw linux-2.6.32.27/drivers/serial/8250_early.c linux-2.6.32.27-fbx/drivers/serial/8250_early.c
--- linux-2.6.32.27/drivers/serial/8250_early.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/serial/8250_early.c	2011-08-29 16:28:20.911742021 +0200
@@ -106,8 +106,13 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGO2
+	dll = serial_in(port, UART_DL) & 0xff;
+	dlm = serial_in(port, UART_DL) >> 8;
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -128,8 +133,13 @@
 	divisor = port->uartclk / (16 * device->baud);
 	c = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, c | UART_LCR_DLAB);
+
+#ifdef CONFIG_TANGO2
+	serial_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial_out(port, UART_DLL, divisor & 0xff);
 	serial_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -ruw linux-2.6.32.27/drivers/serial/Kconfig linux-2.6.32.27-fbx/drivers/serial/Kconfig
--- linux-2.6.32.27/drivers/serial/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/serial/Kconfig	2011-08-29 16:28:20.911742021 +0200
@@ -37,6 +37,13 @@
 	  Most people will say Y or M here, so that they can use serial mice,
 	  modems and similar devices connecting to the standard serial ports.
 
+config GEN3_UART
+	bool "Intel Media SOC Gen3 UART support"
+	depends on SERIAL_8250 && ARCH_GEN3 
+	default y
+	help
+	  This option enables Intel Media SOC Gen3 UART support. 
+
 config SERIAL_8250_CONSOLE
 	bool "Console on 8250/16550 and compatible serial port"
 	depends on SERIAL_8250=y
diff -ruw linux-2.6.32.27/drivers/spi/Kconfig linux-2.6.32.27-fbx/drivers/spi/Kconfig
--- linux-2.6.32.27/drivers/spi/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/spi/Kconfig	2011-08-29 16:28:20.941742288 +0200
@@ -189,6 +189,12 @@
 	help
 	  This selects a driver for the PPC4xx SPI Controller.
 
+config SPI_TDM_ORION
+	tristate "Orion TDM SPI master"
+	depends on PLAT_ORION
+	help
+	  This enables using the TDM SPI master controller on the Orion chips.
+
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
 	depends on ARCH_PXA && EXPERIMENTAL
diff -ruw linux-2.6.32.27/drivers/spi/Makefile linux-2.6.32.27-fbx/drivers/spi/Makefile
--- linux-2.6.32.27/drivers/spi/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/spi/Makefile	2011-08-29 16:28:20.941742288 +0200
@@ -24,6 +24,7 @@
 obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
 obj-$(CONFIG_SPI_PL022)			+= amba-pl022.o
+obj-$(CONFIG_SPI_TDM_ORION)		+= orion_tdm_spi.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
 obj-$(CONFIG_SPI_MPC8xxx)		+= spi_mpc8xxx.o
 obj-$(CONFIG_SPI_PPC4xx)		+= spi_ppc4xx.o
diff -ruw linux-2.6.32.27/drivers/usb/gadget/Kconfig linux-2.6.32.27-fbx/drivers/usb/gadget/Kconfig
--- linux-2.6.32.27/drivers/usb/gadget/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/gadget/Kconfig	2011-08-29 16:28:21.391746285 +0200
@@ -121,6 +121,17 @@
 #
 # Integrated controllers
 #
+config USB_GADGET_VOX160
+	boolean "IKANOS VX160"
+	help
+	   This driver provides USB Device Controller driver for IKanos's VX160
+
+config USB_VOX160
+	tristate
+	depends on USB_GADGET_VOX160
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 
 config USB_GADGET_AT91
 	boolean "Atmel AT91 USB Device Port"
diff -ruw linux-2.6.32.27/drivers/usb/gadget/Makefile linux-2.6.32.27-fbx/drivers/usb/gadget/Makefile
--- linux-2.6.32.27/drivers/usb/gadget/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/gadget/Makefile	2011-08-29 16:28:21.391746285 +0200
@@ -28,6 +28,7 @@
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_VOX160)	+= vox160_udc.o
 
 #
 # USB gadget drivers
diff -ruw linux-2.6.32.27/drivers/usb/host/ehci.h linux-2.6.32.27-fbx/drivers/usb/host/ehci.h
--- linux-2.6.32.27/drivers/usb/host/ehci.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/host/ehci.h	2011-08-29 16:28:21.471746995 +0200
@@ -608,6 +608,11 @@
 #define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
 #endif
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_BCM63XX)
+#define readl_be(addr)		__raw_readl((__force unsigned *)addr)
+#define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
+#endif
+
 static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
 		__u32 __iomem * regs)
 {
diff -ruw linux-2.6.32.27/drivers/usb/host/ehci-hcd.c linux-2.6.32.27-fbx/drivers/usb/host/ehci-hcd.c
--- linux-2.6.32.27/drivers/usb/host/ehci-hcd.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/host/ehci-hcd.c	2011-08-29 16:28:21.451746818 +0200
@@ -82,7 +82,11 @@
 #define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
+#ifdef CONFIG_ARCH_GEN3
+#define EHCI_IO_JIFFIES		(HZ/100)	/* io watchdog > irq_thresh */
+#else
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
+#endif
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
 
@@ -1142,6 +1146,16 @@
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_BCM63XX
+#include "ehci-bcm63xx.c"
+#define	PLATFORM_DRIVER		ehci_hcd_bcm63xx_driver
+#endif
+
+#ifdef CONFIG_TANGO2
+#include "ehci-tango2.c"
+#define	PLATFORM_DRIVER		ehci_hcd_tango2_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff -ruw linux-2.6.32.27/drivers/usb/host/ehci-hub.c linux-2.6.32.27-fbx/drivers/usb/host/ehci-hub.c
--- linux-2.6.32.27/drivers/usb/host/ehci-hub.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/host/ehci-hub.c	2011-08-29 16:28:21.461746906 +0200
@@ -758,11 +758,13 @@
 			 * power switching; they're allowed to just limit the
 			 * current.  khubd will turn the power back on.
 			 */
+#ifndef CONFIG_BCM63XX
 			if (HCS_PPC (ehci->hcs_params)){
 				ehci_writel(ehci,
 					temp & ~(PORT_RWC_BITS | PORT_POWER),
 					status_reg);
 			}
+#endif
 		}
 
 		/* whoever resumes must GetPortStatus to complete it!! */
diff -ruw linux-2.6.32.27/drivers/usb/host/ehci-q.c linux-2.6.32.27-fbx/drivers/usb/host/ehci-q.c
--- linux-2.6.32.27/drivers/usb/host/ehci-q.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/host/ehci-q.c	2011-08-29 16:28:21.461746906 +0200
@@ -1132,6 +1132,33 @@
 	return rc;
 }
 
+#ifdef CONFIG_TANGO2
+/*-------------------------------------------------------------------------*/
+
+/* The TangoX USB2.0 core has a bug related async qh unlinking. */
+static void tango2_unlink_async_fix(struct ehci_hcd *ehci)
+{
+	struct ehci_qh_hw *next    =NULL;
+	int async_list		= 0;
+	int cmd = readl (&ehci->regs->command);
+
+	/* Disable ASYNC */
+	writel (cmd & ~CMD_ASE, &ehci->regs->command);
+	udelay(250);
+	async_list =(u32)phys_to_virt(readl (&ehci->regs->async_next));
+	next = (struct ehci_qh_hw *) async_list;
+	if(next->hw_next)
+		writel(next->hw_next, &ehci->regs->async_next);
+	else
+		writel ((u32)ehci->async->qh_dma, &ehci->regs->async_next);
+	wmb();
+
+	/* Enable ASYNC */
+	writel (cmd | CMD_ASE, &ehci->regs->command);
+	(void) readl (&ehci->regs->command);
+}
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* the async qh for the qtds being reclaimed are now unlinked from the HC */
@@ -1191,6 +1218,10 @@
 		BUG ();
 #endif
 
+#ifdef CONFIG_TANGO2
+	tango2_unlink_async_fix(ehci);
+#endif
+
 	/* stop async schedule right now? */
 	if (unlikely (qh == ehci->async)) {
 		/* can't get here without STS_ASS set */
@@ -1266,6 +1297,7 @@
 				}
 			}
 
+#ifndef CONFIG_TANGO2
 			/* unlink idle entries, reducing DMA usage as well
 			 * as HCD schedule-scanning costs.  delay for any qh
 			 * we just scanned, there's a not-unusual case that it
@@ -1281,6 +1313,7 @@
 				else
 					action = TIMER_ASYNC_SHRINK;
 			}
+#endif
 
 			qh = qh->qh_next.qh;
 		} while (qh);
diff -ruw linux-2.6.32.27/drivers/usb/host/ehci-sched.c linux-2.6.32.27-fbx/drivers/usb/host/ehci-sched.c
--- linux-2.6.32.27/drivers/usb/host/ehci-sched.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/host/ehci-sched.c	2011-08-29 16:28:21.471746995 +0200
@@ -2348,9 +2348,13 @@
 				 * No need to check for activity unless the
 				 * frame is current.
 				 */
+#ifdef CONFIG_ARCH_GEN3
+				if (live && (q.sitd->hw_results & SITD_ACTIVE(ehci))) {
+#else
 				if (frame == clock_frame && live &&
 						(q.sitd->hw_results &
 							SITD_ACTIVE(ehci))) {
+#endif
 					incomplete = true;
 					q_p = &q.sitd->sitd_next;
 					hw_p = &q.sitd->hw_next;
diff -ruw linux-2.6.32.27/drivers/usb/storage/usb.c linux-2.6.32.27-fbx/drivers/usb/storage/usb.c
--- linux-2.6.32.27/drivers/usb/storage/usb.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/usb/storage/usb.c	2011-08-29 16:28:21.561747796 +0200
@@ -74,7 +74,7 @@
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
 MODULE_LICENSE("GPL");
 
-static unsigned int delay_use = 5;
+static unsigned int delay_use = 1;
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
diff -ruw linux-2.6.32.27/drivers/video/Kconfig linux-2.6.32.27-fbx/drivers/video/Kconfig
--- linux-2.6.32.27/drivers/video/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/video/Kconfig	2011-08-29 16:28:21.571747885 +0200
@@ -493,6 +493,28 @@
 	  this driver, say Y or M; otherwise say N. You must specify the
 	  GPIO IO address to be used for setting control and data.
 
+config FB_SSD1305
+	tristate "SSD1305 OLED driver"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select FB_BACKLIGHT
+	select SPI
+	default n
+
+config FB_SSD1327
+	tristate "SSD1327 OLED driver"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select FB_BACKLIGHT
+	select SPI
+	default n
+
 config FB_ATARI
 	bool "Atari native chipset support"
 	depends on (FB = y) && ATARI
diff -ruw linux-2.6.32.27/drivers/video/Makefile linux-2.6.32.27-fbx/drivers/video/Makefile
--- linux-2.6.32.27/drivers/video/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/video/Makefile	2011-08-29 16:28:21.571747885 +0200
@@ -30,6 +30,8 @@
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
+obj-$(CONFIG_FB_SSD1305)          += ssd1305.o
+obj-$(CONFIG_FB_SSD1327)          += ssd1327.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
 obj-$(CONFIG_FB_CYBER2000)        += cyber2000fb.o
 obj-$(CONFIG_FB_PM2)              += pm2fb.o
diff -ruw linux-2.6.32.27/firmware/Makefile linux-2.6.32.27-fbx/firmware/Makefile
--- linux-2.6.32.27/firmware/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/firmware/Makefile	2011-08-29 16:28:22.181753302 +0200
@@ -66,6 +66,8 @@
 fw-shipped-$(CONFIG_DVB_TTUSB_BUDGET) += ttusb-budget/dspbootcode.bin
 fw-shipped-$(CONFIG_E100) += e100/d101m_ucode.bin e100/d101s_ucode.bin \
 			     e100/d102e_ucode.bin
+fw-shipped-$(CONFIG_MWL8K) += mwl8k/helper_8366.fw mwl8k/fmimage_8366_ap.fw
+fw-shipped-$(CONFIG_MWL8K_MFG) += mwl8k/mfg_fmimage_8366.fw
 fw-shipped-$(CONFIG_MYRI_SBUS) += myricom/lanai.bin
 fw-shipped-$(CONFIG_PCMCIA_PCNET) += cis/LA-PCM.cis cis/PCMLM28.cis \
 				     cis/DP83903.cis cis/NE2K.cis \
diff -ruw linux-2.6.32.27/fs/exec.c linux-2.6.32.27-fbx/fs/exec.c
--- linux-2.6.32.27/fs/exec.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/exec.c	2011-08-29 16:28:22.421755434 +0200
@@ -62,6 +62,14 @@
 #include <asm/tlb.h>
 #include "internal.h"
 
+enum {
+	CORE_ENV_PID,
+	CORE_ENV_SIGNAL,
+	CORE_ENV_EXECUTABLE,
+	CORE_ENV_TIME,
+	CORE_ENV_NR,
+};
+
 int core_uses_pid;
 char core_pattern[CORENAME_MAX_SIZE] = "core";
 unsigned int core_pipe_limit;
@@ -1797,10 +1805,15 @@
 	int flag = 0;
 	int ispipe = 0;
 	unsigned long core_limit = current->signal->rlim[RLIMIT_CORE].rlim_cur;
+	char *helper_envp[CORE_ENV_NR + 1];
 	char **helper_argv = NULL;
 	int helper_argc = 0;
 	int dump_count = 0;
 	static atomic_t core_dump_count = ATOMIC_INIT(0);
+	char *delimit;
+	int i;
+
+	memset(helper_envp, 0, sizeof (helper_envp));
 
 	audit_core_dumps(signr);
 
@@ -1860,6 +1873,8 @@
 		goto fail_unlock;
 
  	if (ispipe) {
+		struct timeval tv;
+
 		if (core_limit == 0) {
 			/*
 			 * Normally core limits are irrelevant to pipes, since
@@ -1899,9 +1914,22 @@
 
 		core_limit = RLIM_INFINITY;
 
+		/* Set pipe helper environment */
+		do_gettimeofday(&tv);
+
+		helper_envp[CORE_ENV_PID] = kasprintf(GFP_KERNEL,
+			"CORE_PID=%d", current->tgid);
+		helper_envp[CORE_ENV_SIGNAL] = kasprintf(GFP_KERNEL,
+			"CORE_SIGNAL=%ld", signr);
+		helper_envp[CORE_ENV_EXECUTABLE] = kasprintf(GFP_KERNEL,
+			"CORE_EXECUTABLE=%s", current->comm);
+		helper_envp[CORE_ENV_TIME] = kasprintf(GFP_KERNEL,
+			"CORE_TIME=%lu", tv.tv_sec);
+		helper_envp[CORE_ENV_NR] = NULL;
+
 		/* SIGPIPE can happen, but it's just never processed */
-		if (call_usermodehelper_pipe(helper_argv[0], helper_argv, NULL,
-				&file)) {
+		if (call_usermodehelper_pipe(corename+1, helper_argv,
+				helper_envp, &file)) {
  			printk(KERN_INFO "Core dump to %s pipe failed\n",
 			       corename);
 			goto fail_dropcount;
@@ -1950,6 +1978,8 @@
 fail_unlock:
 	if (helper_argv)
 		argv_free(helper_argv);
+	for (i = 0; i < CORE_ENV_NR; i++)
+		kfree(helper_envp[i]);
 
 	revert_creds(old_cred);
 	put_cred(cred);
diff -ruw linux-2.6.32.27/fs/Kconfig linux-2.6.32.27-fbx/fs/Kconfig
--- linux-2.6.32.27/fs/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/Kconfig	2011-08-29 16:28:22.231753747 +0200
@@ -147,6 +147,17 @@
 config HUGETLB_PAGE
 	def_bool HUGETLBFS
 
+config RAMFS_XATTR
+	bool
+	default n
+ 
+config RAMFS_XATTR_USER
+	bool "Enable user extended attributes on RAMFS filesystem"
+	select RAMFS_XATTR
+	help
+	  Select this to enable extended user attributes on RAMFS
+	  filesystem.
+
 source "fs/configfs/Kconfig"
 
 endmenu
diff -ruw linux-2.6.32.27/fs/namespace.c linux-2.6.32.27-fbx/fs/namespace.c
--- linux-2.6.32.27/fs/namespace.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/namespace.c	2011-08-29 16:28:22.561756678 +0200
@@ -1424,7 +1424,7 @@
 {
 	struct vfsmount *m, *mnt = path->mnt;
 	int recurse = flag & MS_REC;
-	int type = flag & ~MS_REC;
+	int type = flag & (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE);
 	int err = 0;
 
 	if (!capable(CAP_SYS_ADMIN))
diff -ruw linux-2.6.32.27/fs/ramfs/file-mmu.c linux-2.6.32.27-fbx/fs/ramfs/file-mmu.c
--- linux-2.6.32.27/fs/ramfs/file-mmu.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/ramfs/file-mmu.c	2011-08-29 16:28:22.741758276 +0200
@@ -27,6 +27,7 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/ramfs.h>
+#include <linux/xattr.h>
 
 #include "internal.h"
 
@@ -51,4 +52,11 @@
 
 const struct inode_operations ramfs_file_inode_operations = {
 	.getattr	= simple_getattr,
+#ifdef CONFIG_RAMFS_XATTR
+	.setxattr	= generic_setxattr,
+	.getxattr	= generic_getxattr,
+	.listxattr	= generic_listxattr,
+	.removexattr	= generic_removexattr,
+#endif
 };
+
diff -ruw linux-2.6.32.27/fs/ramfs/inode.c linux-2.6.32.27-fbx/fs/ramfs/inode.c
--- linux-2.6.32.27/fs/ramfs/inode.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/ramfs/inode.c	2011-08-29 16:28:22.741758276 +0200
@@ -36,12 +36,14 @@
 #include <linux/parser.h>
 #include <linux/magic.h>
 #include <asm/uaccess.h>
+#include <linux/xattr.h>
 #include "internal.h"
 
 #define RAMFS_DEFAULT_MODE	0755
 
 static const struct super_operations ramfs_ops;
 static const struct inode_operations ramfs_dir_inode_operations;
+static struct kmem_cache *ramfs_inode_cache;
 
 static struct backing_dev_info ramfs_backing_dev_info = {
 	.name		= "ramfs",
@@ -51,6 +53,28 @@
 			  BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
 };
 
+static struct inode *ramfs_alloc_inode(struct super_block *sb)
+{
+	struct ramfs_inode_info *rii;
+
+	rii = kmem_cache_alloc(ramfs_inode_cache, GFP_KERNEL);
+	if (!rii)
+		return NULL;
+	return &rii->vfs_inode;
+}
+
+static void ramfs_destroy_inode(struct inode *ino)
+{
+	struct ramfs_inode_info *rii;
+
+	rii = RAMFS_I(ino);
+
+#ifdef CONFIG_RAMFS_XATTR
+	ramfs_inode_purge_xattrs(rii);
+#endif
+	kmem_cache_free(ramfs_inode_cache, rii);
+}
+
 struct inode *ramfs_get_inode(struct super_block *sb, int mode, dev_t dev)
 {
 	struct inode * inode = new_inode(sb);
@@ -155,9 +179,17 @@
 	.rmdir		= simple_rmdir,
 	.mknod		= ramfs_mknod,
 	.rename		= simple_rename,
+#ifdef CONFIG_RAMFS_XATTR
+	.setxattr	= generic_setxattr,
+	.getxattr	= generic_getxattr,
+	.listxattr	= generic_listxattr,
+	.removexattr	= generic_removexattr,
+#endif
 };
 
 static const struct super_operations ramfs_ops = {
+	.alloc_inode	= ramfs_alloc_inode,
+	.destroy_inode	= ramfs_destroy_inode,
 	.statfs		= simple_statfs,
 	.drop_inode	= generic_delete_inode,
 	.show_options	= generic_show_options,
@@ -239,6 +271,9 @@
 	sb->s_magic		= RAMFS_MAGIC;
 	sb->s_op		= &ramfs_ops;
 	sb->s_time_gran		= 1;
+#ifdef CONFIG_RAMFS_XATTR
+	sb->s_xattr = ramfs_xattr_handlers;
+#endif
 
 	inode = ramfs_get_inode(sb, S_IFDIR | fsi->mount_opts.mode, 0);
 	if (!inode) {
@@ -291,6 +326,16 @@
 	.kill_sb	= kill_litter_super,
 };
 
+static void ramfs_inode_init_once(void *ptr)
+{
+	struct ramfs_inode_info *p = (struct ramfs_inode_info *)ptr;
+
+	inode_init_once(&p->vfs_inode);
+#ifdef CONFIG_RAMFS_XATTR_USER
+	INIT_LIST_HEAD(&p->xattr_user_list);
+#endif
+}
+
 static int __init init_ramfs_fs(void)
 {
 	return register_filesystem(&ramfs_fs_type);
@@ -312,10 +357,19 @@
 	if (err)
 		return err;
 
-	err = register_filesystem(&rootfs_fs_type);
-	if (err)
+	ramfs_inode_cache = kmem_cache_create("ramfs_inode_cache",
+					      sizeof (struct ramfs_inode_info),
+					      0, 0, ramfs_inode_init_once);
+	if (!ramfs_inode_cache) {
 		bdi_destroy(&ramfs_backing_dev_info);
+		return -ENOMEM;
+	}
 
+	err = register_filesystem(&rootfs_fs_type);
+	if (err) {
+		kmem_cache_destroy(ramfs_inode_cache);
+		bdi_destroy(&ramfs_backing_dev_info);
+	}
 	return err;
 }
 
diff -ruw linux-2.6.32.27/fs/ramfs/internal.h linux-2.6.32.27-fbx/fs/ramfs/internal.h
--- linux-2.6.32.27/fs/ramfs/internal.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/ramfs/internal.h	2011-08-29 16:28:22.741758276 +0200
@@ -9,6 +9,42 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#ifndef RAMFS_INTERNAL_H
+# define RAMFS_INTERNALH
+
+/* need list_head */
+#include <linux/list.h>
 
 extern const struct address_space_operations ramfs_aops;
 extern const struct inode_operations ramfs_file_inode_operations;
+
+
+struct ramfs_xattr
+{
+	char *name;
+	void *data;
+	size_t data_len;
+
+	struct list_head list;
+};
+
+struct ramfs_inode_info
+{
+	struct inode vfs_inode;
+#ifdef CONFIG_RAMFS_XATTR_USER
+	struct list_head xattr_user_list;
+#endif
+};
+
+static inline struct ramfs_inode_info *RAMFS_I(struct inode *inode)
+{
+	return container_of(inode, struct ramfs_inode_info, vfs_inode);
+}
+
+#ifdef CONFIG_RAMFS_XATTR
+void ramfs_inode_purge_xattrs(struct ramfs_inode_info *rii);
+extern struct xattr_handler *ramfs_xattr_handlers[];
+#endif
+
+
+#endif /* !RAMFS_INTERNAL_H */
diff -ruw linux-2.6.32.27/fs/ramfs/Makefile linux-2.6.32.27-fbx/fs/ramfs/Makefile
--- linux-2.6.32.27/fs/ramfs/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/ramfs/Makefile	2011-01-06 02:17:56.091558666 +0100
@@ -6,4 +6,5 @@
 
 file-mmu-y := file-nommu.o
 file-mmu-$(CONFIG_MMU) := file-mmu.o
-ramfs-objs += inode.o $(file-mmu-y)
+ramfs-xattr-$(CONFIG_RAMFS_XATTR) += xattr.o
+ramfs-objs += inode.o $(file-mmu-y) $(ramfs-xattr-y)
diff -ruw linux-2.6.32.27/fs/squashfs/Kconfig linux-2.6.32.27-fbx/fs/squashfs/Kconfig
--- linux-2.6.32.27/fs/squashfs/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/squashfs/Kconfig	2011-08-29 16:28:22.761758454 +0200
@@ -1,7 +1,6 @@
 config SQUASHFS
 	tristate "SquashFS 4.0 - Squashed file system support"
 	depends on BLOCK
-	select ZLIB_INFLATE
 	help
 	  Saying Y here includes support for SquashFS 4.0 (a Compressed
 	  Read-Only File System).  Squashfs is a highly compressed read-only
@@ -26,6 +25,18 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_SUPPORT_ZLIB
+	bool
+	prompt "Support ZLIB compression" if SQUASHFS_SUPPORT_LZMA
+	select ZLIB_INFLATE
+	depends on SQUASHFS
+	default y
+
+config SQUASHFS_SUPPORT_LZMA
+	bool "Support LZMA compression"
+	depends on SQUASHFS
+	select DECOMPRESS_LZMASDK
+
 config SQUASHFS_EMBEDDED
 
 	bool "Additional option for memory-constrained systems" 
diff -ruw linux-2.6.32.27/fs/xfs/linux-2.6/xfs_buf.c linux-2.6.32.27-fbx/fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.32.27/fs/xfs/linux-2.6/xfs_buf.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/xfs/linux-2.6/xfs_buf.c	2011-08-29 16:28:22.801758810 +0200
@@ -449,6 +449,100 @@
 	return error;
 }
 
+#ifdef CONFIG_MIPS
+static void cache_flush_buf_page(xfs_buf_t *bp, int page_id)
+{
+	struct page *page;
+	void *vmaddr, *addr;
+
+	if (!(bp->b_flags & XBF_MAPPED))
+		return;
+
+	if (bp->b_page_count <= 1)
+		return;
+
+	page = bp->b_pages[page_id];
+	vmaddr = bp->b_addr - bp->b_offset + (page_id * PAGE_CACHE_SIZE);
+	addr = page_address(page);
+
+	if (pages_do_alias((unsigned long)addr, (unsigned long)vmaddr)) {
+		local_flush_data_cache_page(vmaddr);
+		local_flush_data_cache_page(addr);
+	}
+}
+
+static void cache_flush_buf(xfs_buf_t *bp)
+{
+	unsigned int i;
+
+	for (i = 0; i < bp->b_page_count; i++)
+		cache_flush_buf_page(bp, i);
+}
+#elif CONFIG_ARM
+#include <asm/cacheflush.h>
+static void cache_flush_buf_page(xfs_buf_t *bp, int page_id)
+{
+	struct page *page;
+	void *vmaddr, *addr;
+
+	if (!(bp->b_flags & XBF_MAPPED))
+		return;
+
+	if (bp->b_page_count <= 1)
+		return;
+
+	page = bp->b_pages[page_id];
+	vmaddr = bp->b_addr - bp->b_offset + (page_id * PAGE_CACHE_SIZE);
+	addr = page_address(page);
+
+	if ((cache_is_vivt() || cache_is_vipt_aliasing())) {
+		__cpuc_flush_dcache_page(vmaddr);
+		__cpuc_flush_dcache_page(addr);
+	}
+}
+
+static void cache_flush_buf(xfs_buf_t *bp)
+{
+	unsigned int i;
+
+	for (i = 0; i < bp->b_page_count; i++)
+		cache_flush_buf_page(bp, i);
+}
+#elif CONFIG_ARM
+#include <asm/cacheflush.h>
+static void cache_flush_buf_page(xfs_buf_t *bp, int page_id)
+{
+	struct page *page;
+	void *vmaddr, *addr;
+
+	if (!(bp->b_flags & XBF_MAPPED))
+		return;
+
+	if (bp->b_page_count <= 1)
+		return;
+
+	page = bp->b_pages[page_id];
+	vmaddr = bp->b_addr - bp->b_offset + (page_id * PAGE_CACHE_SIZE);
+	addr = page_address(page);
+
+	if ((cache_is_vivt() || cache_is_vipt_aliasing())) {
+		__cpuc_flush_dcache_page(vmaddr);
+		__cpuc_flush_dcache_page(addr);
+	}
+}
+
+static void cache_flush_buf(xfs_buf_t *bp)
+{
+	unsigned int i;
+
+	for (i = 0; i < bp->b_page_count; i++)
+		cache_flush_buf_page(bp, i);
+}
+#else
+static inline void cache_flush_buf_page(xfs_buf_t *bp, int page_id) { }
+static inline void cache_flush_buf(xfs_buf_t *bp) { }
+#endif
+
 /*
  *	Map buffer into kernel address-space if nessecary.
  */
@@ -470,6 +564,7 @@
 			return -ENOMEM;
 		bp->b_addr += bp->b_offset;
 		bp->b_flags |= XBF_MAPPED;
+		cache_flush_buf(bp);
 	}
 
 	return 0;
@@ -1202,6 +1297,7 @@
 		bio->bi_end_io = xfs_buf_bio_end_io;
 		bio->bi_private = bp;
 
+		cache_flush_buf_page(bp, 0);
 		bio_add_page(bio, bp->b_pages[0], PAGE_CACHE_SIZE, 0);
 		size = 0;
 
@@ -1228,6 +1324,7 @@
 		if (nbytes > size)
 			nbytes = size;
 
+		cache_flush_buf_page(bp, map_i);
 		rbytes = bio_add_page(bio, bp->b_pages[map_i], nbytes, offset);
 		if (rbytes < nbytes)
 			break;
diff -ruw linux-2.6.32.27/fs/xfs/xfs_dir2_block.c linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_block.c
--- linux-2.6.32.27/fs/xfs/xfs_dir2_block.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_block.c	2011-08-29 16:28:22.841759164 +0200
@@ -485,6 +485,9 @@
 	 * Each object is a real entry (dep) or an unused one (dup).
 	 */
 	while (ptr < endptr) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		dup = (xfs_dir2_data_unused_t *)ptr;
 		/*
 		 * Unused, skip it.
@@ -509,11 +512,18 @@
 		cook = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
 					    (char *)dep - (char *)block);
 
+		if (xfs_iget(mp, NULL, be64_to_cpu(dep->inumber), 0, 0,
+			     &inode, 0) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iput(inode, 0);
+		} else
+			type = DT_UNKNOWN;
+
 		/*
 		 * If it didn't fit, set the final offset to here & return.
 		 */
 		if (filldir(dirent, dep->name, dep->namelen, cook & 0x7fffffff,
-			    be64_to_cpu(dep->inumber), DT_UNKNOWN)) {
+			    be64_to_cpu(dep->inumber), type)) {
 			*offset = cook & 0x7fffffff;
 			xfs_da_brelse(NULL, bp);
 			return 0;
diff -ruw linux-2.6.32.27/fs/xfs/xfs_dir2_leaf.c linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_leaf.c
--- linux-2.6.32.27/fs/xfs/xfs_dir2_leaf.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_leaf.c	2011-08-29 16:28:22.841759164 +0200
@@ -816,6 +816,9 @@
 	 * Get more blocks and readahead as necessary.
 	 */
 	while (curoff < XFS_DIR2_LEAF_OFFSET) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		/*
 		 * If we have no buffer, or we're off the end of the
 		 * current buffer, need to get another one.
@@ -1079,9 +1082,16 @@
 		dep = (xfs_dir2_data_entry_t *)ptr;
 		length = xfs_dir2_data_entsize(dep->namelen);
 
+		if (xfs_iget(mp, NULL, be64_to_cpu(dep->inumber), 0, 0,
+			     &inode, 0) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iput(inode, 0);
+		} else
+			type = DT_UNKNOWN;
+
 		if (filldir(dirent, dep->name, dep->namelen,
 			    xfs_dir2_byte_to_dataptr(mp, curoff) & 0x7fffffff,
-			    be64_to_cpu(dep->inumber), DT_UNKNOWN))
+			    be64_to_cpu(dep->inumber), type))
 			break;
 
 		/*
diff -ruw linux-2.6.32.27/fs/xfs/xfs_dir2_sf.c linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_sf.c
--- linux-2.6.32.27/fs/xfs/xfs_dir2_sf.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/fs/xfs/xfs_dir2_sf.c	2011-08-29 16:28:22.841759164 +0200
@@ -770,6 +770,9 @@
 	 */
 	sfep = xfs_dir2_sf_firstentry(sfp);
 	for (i = 0; i < sfp->hdr.count; i++) {
+		struct xfs_inode *inode;
+		unsigned int type;
+
 		off = xfs_dir2_db_off_to_dataptr(mp, mp->m_dirdatablk,
 				xfs_dir2_sf_get_offset(sfep));
 
@@ -779,8 +782,15 @@
 		}
 
 		ino = xfs_dir2_sf_get_inumber(sfp, xfs_dir2_sf_inumberp(sfep));
+
+		if (xfs_iget(mp, NULL, ino, 0, 0, &inode, 0) == 0) {
+			type = (inode->i_d.di_mode >> 12) & 0xf;
+			xfs_iput(inode, 0);
+		} else
+			type = DT_UNKNOWN;
+
 		if (filldir(dirent, sfep->name, sfep->namelen,
-			    off & 0x7fffffff, ino, DT_UNKNOWN)) {
+			    off & 0x7fffffff, ino, type)) {
 			*offset = off & 0x7fffffff;
 			return 0;
 		}
diff -ruw linux-2.6.32.27/include/linux/if_tunnel.h linux-2.6.32.27-fbx/include/linux/if_tunnel.h
--- linux-2.6.32.27/include/linux/if_tunnel.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/if_tunnel.h	2011-08-29 16:28:23.001760586 +0200
@@ -34,6 +34,11 @@
 	__be16			o_flags;
 	__be32			i_key;
 	__be32			o_key;
+
+	/* this is the first bits to match on ipv6 address */
+	struct in6_addr		fbx6to4_zone;
+	__u8			fbx6to4_prefix;
+
 	struct iphdr		iph;
 };
 
diff -ruw linux-2.6.32.27/include/linux/Kbuild linux-2.6.32.27-fbx/include/linux/Kbuild
--- linux-2.6.32.27/include/linux/Kbuild	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/Kbuild	2011-08-29 16:28:22.951760141 +0200
@@ -65,6 +65,8 @@
 header-y += elf-em.h
 header-y += fadvise.h
 header-y += falloc.h
+header-y += fbxatm.h
+header-y += fbxmtd_map_ioctl.h
 header-y += fd.h
 header-y += fdreg.h
 header-y += fib_rules.h
@@ -384,3 +386,5 @@
 objhdr-y += version.h
 header-y += wimax.h
 header-y += wimax/
+
+header-y += remoti/
diff -ruw linux-2.6.32.27/include/linux/kernel.h linux-2.6.32.27-fbx/include/linux/kernel.h
--- linux-2.6.32.27/include/linux/kernel.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/kernel.h	2011-08-29 16:28:23.011760675 +0200
@@ -247,6 +247,7 @@
 				   unsigned int interval_msec);
 
 extern int printk_delay_msec;
+extern void console_emergency_dump(char *buf, int *len);
 
 /*
  * Print a one-time message (analogous to WARN_ONCE() et al):
@@ -279,6 +280,9 @@
 static inline void log_buf_kexec_setup(void)
 {
 }
+
+static inline void console_emergency_dump(char *buf, int *len) { }
+
 #endif
 
 extern int printk_needs_cpu(int cpu);
diff -ruw linux-2.6.32.27/include/linux/libata.h linux-2.6.32.27-fbx/include/linux/libata.h
--- linux-2.6.32.27/include/linux/libata.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/libata.h	2011-08-29 16:28:23.021760763 +0200
@@ -750,6 +750,7 @@
 	struct ata_host		*host;
 	struct device 		*dev;
 
+
 	void			*port_task_data;
 	struct delayed_work	port_task;
 	struct delayed_work	hotplug_task;
diff -ruw linux-2.6.32.27/include/linux/major.h linux-2.6.32.27-fbx/include/linux/major.h
--- linux-2.6.32.27/include/linux/major.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/major.h	2011-01-06 02:17:56.342097661 +0100
@@ -171,7 +171,16 @@
 
 #define VIOTAPE_MAJOR		230
 
-#define BLOCK_EXT_MAJOR		259
+/*
+ * Until userland gets decent support for large majors number (if the
+ * day ever comes), use 242 for BLOCK_EXT_MAJOR. According to
+ * devices.txt area 240 to 254 is assigned for "LOCAL/EXPERIMENTAL
+ * USE". This kind of hack would fall in this category.
+ */
+/* #define BLOCK_EXT_MAJOR		259 */
+#define BLOCK_EXT_MAJOR		242
+
+
 #define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
 
 #endif
diff -ruw linux-2.6.32.27/include/linux/mtd/mtd.h linux-2.6.32.27-fbx/include/linux/mtd/mtd.h
--- linux-2.6.32.27/include/linux/mtd/mtd.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/mtd/mtd.h	2011-08-29 16:28:30.651828462 +0200
@@ -133,6 +133,11 @@
 	unsigned int erasesize_mask;
 	unsigned int writesize_mask;
 
+	/* NAND related attributes */
+	const char *nand_type;
+	const char *nand_manufacturer;
+	const char *onfi_version;
+
 	// Kernel-only stuff starts here.
 	const char *name;
 	int index;
diff -ruw linux-2.6.32.27/include/linux/mtd/nand.h linux-2.6.32.27-fbx/include/linux/mtd/nand.h
--- linux-2.6.32.27/include/linux/mtd/nand.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/mtd/nand.h	2011-08-29 16:28:23.051761029 +0200
@@ -104,6 +104,10 @@
 #define NAND_CMD_STATUS_RESET	0x7f
 #define NAND_CMD_STATUS_CLEAR	0xff
 
+/* Extended commands for ONFI devices */
+#define NAND_CMD_READ_ONFI_PARAMS	0xEC
+#define NAND_ADDR_ONFI_ID	0x20
+
 #define NAND_CMD_NONE		-1
 
 /* Status bits */
@@ -167,6 +171,8 @@
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
+/* Chip supports ONFI */
+#define NAND_ONFI		0x00000400
 
 
 /* Options valid for Samsung large page devices */
@@ -180,7 +186,8 @@
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
 /* Large page NAND with SOFT_ECC should support subpage reads */
 #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
-					&& (chip->page_shift > 9))
+					&& (chip->page_shift > 9) \
+					&& !(chip->options & NAND_NO_RNDOUT))
 
 /* Mask to zero out the chip options, which come from the id table */
 #define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
@@ -194,6 +201,8 @@
 /* This option is defined if the board driver allocates its own buffers
    (e.g. because it needs them DMA-coherent */
 #define NAND_OWN_BUFFERS	0x00040000
+/* NAND controller does not want RNDOUT commands, even in NAND_ECC_SOFT */
+#define NAND_NO_RNDOUT		0x00080000
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
 #define NAND_CONTROLLER_ALLOC	0x80000000
@@ -219,6 +228,61 @@
 /* Keep gcc happy */
 struct nand_chip;
 
+struct nand_onfi_params {
+	/* rev info and features block */
+	uint8_t		sig[4]; /* 'O' 'N' 'F' 'I'  */
+	uint16_t	revision;
+	uint16_t	features;
+	uint16_t	opt_cmd;
+	uint8_t		reserved[22];
+
+	/* manufacturer information block */
+	char		manufacturer[12];
+	char		model[20];
+	uint8_t		jedec_id;
+	uint16_t	date_code;
+	uint8_t		reserved2[13];
+
+	/* memory organization block */
+	uint32_t	byte_per_page;
+	uint16_t	spare_bytes_per_page;
+	uint32_t	data_bytes_per_ppage;
+	uint16_t	sparre_bytes_per_ppage;
+	uint32_t	pages_per_block;
+	uint32_t	blocks_per_lun;
+	uint8_t		lun_count;
+	uint8_t		addr_cycles;
+	uint8_t		bits_per_cell;
+	uint16_t	bb_per_lun;
+	uint16_t	block_endurance;
+	uint8_t		guaranteed_good_blocks;
+	uint16_t	guaranteed_block_endurance;
+	uint8_t		programs_per_page;
+	uint8_t		ppage_attr;
+	uint8_t		ecc_bits;
+	uint8_t		interleaved_bits;
+	uint8_t		interleaved_ops;
+	uint8_t		reserved3[13];
+	uint8_t		io_pin_capacitance_max;
+
+	/* electrical parameter block */
+	uint16_t	async_timing_mode;
+	uint16_t	program_cache_timing_mode;
+	uint16_t	t_prog;
+	uint16_t	t_bers;
+	uint16_t	t_r;
+	uint16_t	t_ccs;
+	uint16_t	src_sync_timing_mode;
+	uint16_t	src_ssync_features;
+	uint16_t	clk_pin_capacitance_typ;
+	uint16_t	io_pin_capacitance_typ;
+	uint16_t	input_pin_capacitance_typ;
+	uint8_t		input_pin_capacitance_max;
+	uint8_t		driver_strenght_support;
+	uint16_t	t_int_r;
+	uint16_t	t_ald;
+} __attribute__((packed));
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -344,6 +408,8 @@
  * @chip_shift:		[INTERN] number of address bits in one chip
  * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
  *			special functionality. See the defines for further explanation
+ * @onfi_version:	Supported ONFI version (10 => ONFI 1.0)
+ * @onfi_params:	ONFI parameters
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
@@ -402,6 +468,9 @@
 	uint8_t		cellinfo;
 	int		badblockpos;
 
+	int		onfi_version;
+	struct nand_onfi_params onfi_params;
+
 	nand_state_t	state;
 
 	uint8_t		*oob_poi;
diff -ruw linux-2.6.32.27/include/linux/netdevice.h linux-2.6.32.27-fbx/include/linux/netdevice.h
--- linux-2.6.32.27/include/linux/netdevice.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/netdevice.h	2011-08-29 16:28:23.051761029 +0200
@@ -892,6 +892,11 @@
 	/* GARP */
 	struct garp_port	*garp_port;
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	struct fbxbridge	*fbx_bridge;
+	struct fbxbridge	*fbx_bridge_port;
+#endif
+
 	/* class/net/name entry */
 	struct device		dev;
 	/* space for optional statistics and wireless sysfs groups */
diff -ruw linux-2.6.32.27/include/linux/netfilter/nf_conntrack_ftp.h linux-2.6.32.27-fbx/include/linux/netfilter/nf_conntrack_ftp.h
--- linux-2.6.32.27/include/linux/netfilter/nf_conntrack_ftp.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/netfilter/nf_conntrack_ftp.h	2011-08-29 16:28:23.051761029 +0200
@@ -26,6 +26,11 @@
 	u_int32_t seq_aft_nl[IP_CT_DIR_MAX][NUM_SEQ_TO_REMEMBER];
 	/* 0 means seq_match_aft_nl not set */
 	int seq_aft_nl_num[IP_CT_DIR_MAX];
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+	unsigned int is_fbxbridge;
+	unsigned long fbxbridge_remote;
+	unsigned long fbxbridge_wan;
+#endif
 };
 
 struct nf_conntrack_expect;
diff -ruw linux-2.6.32.27/include/linux/pci_ids.h linux-2.6.32.27-fbx/include/linux/pci_ids.h
--- linux-2.6.32.27/include/linux/pci_ids.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/pci_ids.h	2011-08-29 16:28:23.071761207 +0200
@@ -2532,6 +2532,7 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_6	0x2930
 #define PCI_DEVICE_ID_INTEL_ICH9_7	0x2916
 #define PCI_DEVICE_ID_INTEL_ICH9_8	0x2918
+#define PCI_DEVICE_ID_INTEL_SODAVILLE	0x2e52
 #define PCI_DEVICE_ID_INTEL_82855PM_HB	0x3340
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG4	0x3429
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG5	0x342a
diff -ruw linux-2.6.32.27/include/linux/ppp_channel.h linux-2.6.32.27-fbx/include/linux/ppp_channel.h
--- linux-2.6.32.27/include/linux/ppp_channel.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/ppp_channel.h	2011-08-29 16:28:23.081761296 +0200
@@ -49,6 +49,9 @@
 /* Called by the channel when it can send some more data. */
 extern void ppp_output_wakeup(struct ppp_channel *);
 
+/* Called by the channel when it want to prevent further transmit on it */
+extern void ppp_output_stop(struct ppp_channel *);
+
 /* Called by the channel to process a received PPP packet.
    The packet should have just the 2-byte PPP protocol header. */
 extern void ppp_input(struct ppp_channel *, struct sk_buff *);
diff -ruw linux-2.6.32.27/include/linux/random.h linux-2.6.32.27-fbx/include/linux/random.h
--- linux-2.6.32.27/include/linux/random.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/random.h	2011-08-29 16:28:23.091761385 +0200
@@ -50,6 +50,8 @@
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq);
 
+extern void add_raw_randomness(u8 *buf, int nbytes);
+
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
diff -ruw linux-2.6.32.27/include/linux/serial_core.h linux-2.6.32.27-fbx/include/linux/serial_core.h
--- linux-2.6.32.27/include/linux/serial_core.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/serial_core.h	2011-08-29 16:28:23.101761474 +0200
@@ -44,7 +44,8 @@
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
-#define PORT_MAX_8250	18	/* max port ID */
+#define PORT_INTELCE	19	/* Intel CE3100/4100 SoC internal UART */
+#define PORT_MAX_8250	19	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
diff -ruw linux-2.6.32.27/include/linux/serial_reg.h linux-2.6.32.27-fbx/include/linux/serial_reg.h
--- linux-2.6.32.27/include/linux/serial_reg.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/serial_reg.h	2011-08-29 16:28:23.101761474 +0200
@@ -18,9 +18,18 @@
  * DLAB=0
  */
 #define UART_RX		0	/* In:  Receive buffer */
+#ifdef CONFIG_TANGO2
+#define UART_TX		1	/* Out: Transmit buffer */
+#else
 #define UART_TX		0	/* Out: Transmit buffer */
+#endif
 
+#ifdef CONFIG_TANGO2
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#else
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#endif
+
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +39,12 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
+#ifdef CONFIG_TANGO2
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#else
 #define UART_IIR	2	/* In:  Interrupt ID Register */
+#endif
+
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -40,7 +54,12 @@
 
 #define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
 
+#ifdef CONFIG_TANGO2
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#else
 #define UART_FCR	2	/* Out: FIFO Control Register */
+#endif
+
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -83,7 +102,12 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
+#ifdef CONFIG_TANGO2
+#define UART_LCR	5	/* Out: Line Control Register */
+#else
 #define UART_LCR	3	/* Out: Line Control Register */
+#endif
+
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -99,7 +123,11 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
+#ifdef CONFIG_TANGO2
+#define UART_MCR	6	/* Out: Modem Control Register */
+#else
 #define UART_MCR	4	/* Out: Modem Control Register */
+#endif
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -110,7 +138,12 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
+#ifdef CONFIG_TANGO2
+#define UART_LSR	7	/* In:  Line Status Register */
+#else
 #define UART_LSR	5	/* In:  Line Status Register */
+#endif
+
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -120,7 +153,11 @@
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 #define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
 
+#ifdef CONFIG_TANGO2
+#define UART_MSR	8	/* In:  Modem Status Register */
+#else
 #define UART_MSR	6	/* In:  Modem Status Register */
+#endif
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -131,18 +168,36 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
+#ifdef CONFIG_TANGO2
+#define UART_SCR	9	/* I/O: Scratch Register */
+#else
 #define UART_SCR	7	/* I/O: Scratch Register */
+#endif
 
 /*
  * DLAB=1
  */
+#ifdef CONFIG_TANGO2
+/*
+ * smp863x has DLM and DLM in one register
+ */
+#define UART_DL		10
+#define UART_CLKSEL     11      /* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
+#ifdef CONFIG_TANGO2
+/* EFR does not exist on TANGO2, we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+#else
 #define UART_EFR	2	/* I/O: Extended Features Register */
+#endif
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
diff -ruw linux-2.6.32.27/include/linux/skbuff.h linux-2.6.32.27-fbx/include/linux/skbuff.h
--- linux-2.6.32.27/include/linux/skbuff.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/skbuff.h	2011-09-09 16:10:59.830460865 +0200
@@ -255,6 +255,13 @@
 typedef unsigned char *sk_buff_data_t;
 #endif
 
+enum {
+	FFN_STATE_INIT = 0,
+	FFN_STATE_FORWARDABLE,
+	FFN_STATE_FAST_FORWARDED,
+	FFN_STATE_INCOMPATIBLE,
+};
+
 /** 
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
@@ -361,6 +368,9 @@
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	struct nf_conntrack	*nfct;
 	struct sk_buff		*nfct_reasm;
+#ifdef CONFIG_IP_FFN
+	int			ffn_state;
+#endif
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct nf_bridge_info	*nf_bridge;
@@ -390,6 +400,7 @@
 	__u32			secmark;
 #endif
 
+	__u32			rx_class;
 	__u32			mark;
 
 	__u16			vlan_tci;
@@ -397,6 +408,15 @@
 	sk_buff_data_t		transport_header;
 	sk_buff_data_t		network_header;
 	sk_buff_data_t		mac_header;
+
+#ifdef CONFIG_SKB_RECYCLE
+	/* callback just before skb header memory is about to be
+	 * released, memory is not freed if callback returns 1 */
+	int			(*recycle)(void *recycle_data,
+					   struct sk_buff *skb);
+	void			*recycle_data;
+#endif
+
 	/* These elements must be at the end, see alloc_skb() for details.  */
 	sk_buff_data_t		tail;
 	sk_buff_data_t		end;
@@ -1366,6 +1386,10 @@
  * Various parts of the networking layer expect at least 32 bytes of
  * headroom, you should not reduce this.
  */
+#ifdef CONFIG_NETSKBPAD
+#define NET_SKB_PAD	CONFIG_NETSKBPAD
+#endif
+
 #ifndef NET_SKB_PAD
 #define NET_SKB_PAD	32
 #endif
@@ -2053,6 +2077,11 @@
 }
 #endif
 
+#ifdef CONFIG_SKB_RECYCLE
+extern void kfree_recycled_skbmem(struct sk_buff *skb);
+void skb_clean_state(struct sk_buff *skb);
+#endif
+
 static inline int skb_is_gso(const struct sk_buff *skb)
 {
 	return skb_shinfo(skb)->gso_size;
diff -ruw linux-2.6.32.27/include/linux/sockios.h linux-2.6.32.27-fbx/include/linux/sockios.h
--- linux-2.6.32.27/include/linux/sockios.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/sockios.h	2011-08-29 16:28:23.101761474 +0200
@@ -125,6 +125,14 @@
 /* hardware time stamping: parameters in linux/net_tstamp.h */
 #define SIOCSHWTSTAMP   0x89b0
 
+/* fbxdiverter call */
+#define SIOCGFBXDIVERT  0x89c0		/* fbxdiverter support          */
+#define SIOCSFBXDIVERT  0x89c1		/* Set fbxdiverter options      */
+
+/* fbxbridge call */
+#define SIOCGFBXBRIDGE	0x89b2		/* fbxbridge support          */
+#define SIOCSFBXBRIDGE	0x89b3		/* Set fbxbridge options      */
+
 /* Device private ioctl calls */
 
 /*
diff -ruw linux-2.6.32.27/include/linux/tty.h linux-2.6.32.27-fbx/include/linux/tty.h
--- linux-2.6.32.27/include/linux/tty.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/tty.h	2011-08-29 16:28:23.131761740 +0200
@@ -5,25 +5,7 @@
  * 'tty.h' defines some structures used by tty_io.c and some defines.
  */
 
-#ifdef __KERNEL__
-#include <linux/fs.h>
-#include <linux/major.h>
-#include <linux/termios.h>
-#include <linux/workqueue.h>
-#include <linux/tty_driver.h>
-#include <linux/tty_ldisc.h>
-#include <linux/mutex.h>
-
-#include <asm/system.h>
-
-
-/*
- * (Note: the *_driver.minor_start values 1, 64, 128, 192 are
- * hardcoded at present.)
- */
-#define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
-#define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
-#define NR_LDISCS		20
+#define NR_LDISCS		21
 
 /* line disciplines */
 #define N_TTY		0
@@ -48,6 +30,26 @@
 #define N_PPS		18	/* Pulse per Second */
 
 #define N_V253		19	/* Codec control over voice modem */
+#define N_REMOTI	20	/* RemoTI over UART */
+
+#ifdef __KERNEL__
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/termios.h>
+#include <linux/workqueue.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_ldisc.h>
+#include <linux/mutex.h>
+
+#include <asm/system.h>
+
+
+/*
+ * (Note: the *_driver.minor_start values 1, 64, 128, 192 are
+ * hardcoded at present.)
+ */
+#define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
+#define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
 
 /*
  * This character is the same as _POSIX_VDISABLE: it cannot be used as
diff -ruw linux-2.6.32.27/include/linux/videodev2.h linux-2.6.32.27-fbx/include/linux/videodev2.h
--- linux-2.6.32.27/include/linux/videodev2.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/videodev2.h	2011-08-29 16:28:23.151761917 +0200
@@ -343,6 +343,8 @@
 #define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
 #define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
 #define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4    */
+#define V4L2_PIX_FMT_MP2T     v4l2_fourcc('M', 'P', '2', 'T') /* MPEG2 Transport */
+#define V4L2_PIX_FMT_H264     v4l2_fourcc('H', '2', '6', '4') /* H264 ES */
 
 /*  Vendor-specific formats   */
 #define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
diff -ruw linux-2.6.32.27/include/net/ip.h linux-2.6.32.27-fbx/include/net/ip.h
--- linux-2.6.32.27/include/net/ip.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/net/ip.h	2011-08-29 16:28:23.171762094 +0200
@@ -353,6 +353,14 @@
 int ip_frag_nqueues(struct net *net);
 
 /*
+ *     Functions provided by ip_ffn.c
+ */
+extern void ip_ffn_init(void);
+extern int ip_ffn_process(struct sk_buff *skb);
+extern void ip_ffn_add(struct sk_buff *skb);
+extern void ip_ffn_flush_all(void);
+
+/*
  *	Functions provided by ip_forward.c
  */
  
diff -ruw linux-2.6.32.27/include/net/netfilter/nf_conntrack.h linux-2.6.32.27-fbx/include/net/netfilter/nf_conntrack.h
--- linux-2.6.32.27/include/net/netfilter/nf_conntrack.h	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/include/net/netfilter/nf_conntrack.h	2011-08-29 16:28:23.171762094 +0200
@@ -270,7 +270,7 @@
 nf_conntrack_alloc(struct net *net,
 		   const struct nf_conntrack_tuple *orig,
 		   const struct nf_conntrack_tuple *repl,
-		   gfp_t gfp);
+		   gfp_t gfp, int secure_pool);
 
 /* It's confirmed if it is, or has been in the hash table. */
 static inline int nf_ct_is_confirmed(struct nf_conn *ct)
diff -ruw linux-2.6.32.27/init/do_mounts.c linux-2.6.32.27-fbx/init/do_mounts.c
--- linux-2.6.32.27/init/do_mounts.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/init/do_mounts.c	2011-09-09 16:10:59.830460865 +0200
@@ -16,6 +16,10 @@
 #include <linux/async.h>
 #include <linux/fs_struct.h>
 
+#ifdef CONFIG_DMCRYPTATBOOT
+#include <linux/dm-ioctl.h>
+#endif
+
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
@@ -359,6 +363,121 @@
 #endif
 }
 
+#ifdef CONFIG_DMCRYPTATBOOT
+/*
+ * Create dm device
+ */
+long dm_ctl_ioctl(struct file *file, uint command, ulong u);
+
+static int dm_run_setup(void)
+{
+	struct dm_ioctl dm, *dmp;
+	struct dm_target_spec *spec;
+	uint64_t size;
+	char *data, *tmp, *major, *minor;
+	uint8_t *target_info;
+	dev_t tomap;
+	int ret, fd;
+	uint8_t key[128];
+
+	/* read config */
+	ret = -EINVAL;
+	tmp = CONFIG_DMCRYPTATBOOT_DEVICE;
+	major = minor = NULL;
+	if (tmp)
+		major = strsep(&tmp, ":");
+	if (tmp)
+		minor = strsep(&tmp, ":");
+	if (!major || !minor)
+		goto end;
+
+	/* create device to map */
+	tomap = MKDEV(simple_strtoul(major, NULL, 10),
+		      simple_strtoul(minor, NULL, 10));
+	if (create_dev("/dev/tomap", tomap))
+		goto end;
+
+	fd = sys_open("/dev/tomap", 0, 0);
+	if (fd < 0)
+		goto end;
+
+	/* fetch its size */
+	if (sys_ioctl(fd, BLKGETSIZE64, (unsigned long)&size)) {
+		sys_close(fd);
+		goto end;
+	}
+	sys_close(fd);
+	size /= 512;
+
+	/* create dm device */
+	memset(&dm, 0, sizeof (dm));
+	dm.version[0] = DM_VERSION_MAJOR;
+	dm.version[1] = DM_VERSION_MINOR;
+	dm.version[2] = DM_VERSION_PATCHLEVEL;
+	dm.data_size = sizeof (dm);
+	strcpy(dm.name, "root");
+
+	ret = dm_ctl_ioctl(NULL, DM_DEV_CREATE, (ulong)&dm);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl create failed\n");
+		goto end;
+	}
+
+	/* create table */
+	data = kmalloc(sizeof (*dmp) + sizeof (*spec) + 128, GFP_KERNEL);
+	if (!data)
+		goto end;
+	dmp = (struct dm_ioctl *)data;
+	spec = (struct dm_target_spec *)(dmp + 1);
+	target_info = (uint8_t *)(spec + 1);
+
+	memset(dmp, 0, sizeof (*dmp));
+	dmp->version[0] = DM_VERSION_MAJOR;
+	dmp->version[1] = DM_VERSION_MINOR;
+	dmp->version[2] = DM_VERSION_PATCHLEVEL;
+	dmp->data_size = sizeof (*dmp) + sizeof (*spec) + 128;
+	dmp->data_start = sizeof (*dmp);
+	dmp->target_count = 1;
+	strcpy(dmp->name, "root");
+
+	memset(spec, 0, sizeof (*spec));
+	spec->sector_start = 0;
+	spec->length = size;
+	strcpy(spec->target_type, "crypt");
+
+	strcpy(key, CONFIG_DMCRYPTATBOOT_KEY);
+
+	memset(target_info, 0, 128);
+	snprintf((char *)target_info, 128, "%s %s 0 /dev/tomap 0",
+		 CONFIG_DMCRYPTATBOOT_CIPHER, key);
+	target_info[127] = 0;
+
+	ret = dm_ctl_ioctl(NULL, DM_TABLE_LOAD, (ulong)data);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl table load failed\n");
+		goto end;
+	}
+
+	/* resume device */
+	memset(&dm, 0, sizeof (dm));
+	dm.version[0] = DM_VERSION_MAJOR;
+	dm.version[1] = DM_VERSION_MINOR;
+	dm.version[2] = DM_VERSION_PATCHLEVEL;
+	dm.data_size = sizeof (dm);
+	strcpy(dm.name, "root");
+
+	ret = dm_ctl_ioctl(NULL, DM_DEV_SUSPEND, (ulong)&dm);
+	if (ret < 0) {
+		printk("dm_ctl_ioctl resume failed\n");
+		goto end;
+	}
+
+	strcpy(saved_root_name, "/dev/dm-0");
+end:
+	return ret;
+}
+#endif
+
 /*
  * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
  */
@@ -383,6 +502,16 @@
 
 	md_run_setup();
 
+#ifdef CONFIG_DMCRYPTATBOOT
+#ifdef CONFIG_DMCRYPTATBOOT_ONLY
+	if (dm_run_setup() != 0)
+		/* disallow other root= value */
+		saved_root_name[0] = 0;
+#else
+	dm_run_setup();
+#endif
+#endif
+
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
 		if (!strncmp(root_device_name, "mtd", 3) ||
diff -ruw linux-2.6.32.27/init/Kconfig linux-2.6.32.27-fbx/init/Kconfig
--- linux-2.6.32.27/init/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/init/Kconfig	2011-08-29 16:28:23.241762717 +0200
@@ -420,6 +420,41 @@
 		     13 =>  8 KB
 		     12 =>  4 KB
 
+
+config DMCRYPTATBOOT
+	bool "Create device-mapper crypt target before root"
+	depends on DM_CRYPT
+	default n
+
+config DMCRYPTATBOOT_DEVICE
+	string "Device major:minor"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_CIPHER
+	string "Cipher"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_KEY
+	string "Key"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_KEY_DECRYPT
+	string "Decryption key"
+	depends on DMCRYPTATBOOT
+
+config DMCRYPTATBOOT_ONLY
+	bool "Refuse to mount something else"
+	depends on DMCRYPTATBOOT
+
+config FBX_DECRYPT_INITRD
+	bool "Decrypt initrd at boot"
+	depends on BLK_DEV_RAM
+	default n
+
+config FBX_DECRYPT_INITRD_KEY
+	string "Decryption key"
+	depends on FBX_DECRYPT_INITRD
+
 #
 # Architectures with an unreliable sched_clock() should select this:
 #
diff -ruw linux-2.6.32.27/init/Makefile linux-2.6.32.27-fbx/init/Makefile
--- linux-2.6.32.27/init/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/init/Makefile	2011-09-09 16:10:59.830460865 +0200
@@ -10,13 +10,16 @@
 endif
 obj-$(CONFIG_GENERIC_CALIBRATE_DELAY) += calibrate.o
 
+obj-$(CONFIG_FBX_DECRYPT_INITRD)+= fbx_decrypt_initrd.o rc4.o
+
 mounts-y			:= do_mounts.o
 mounts-$(CONFIG_BLK_DEV_RAM)	+= do_mounts_rd.o
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
+
 # files to be removed upon make clean
-clean-files := ../include/linux/compile.h
+clean-files := ../include/linux/compile.h dmcryptatboot_decrypt.c
 
 # dependencies on generated files need to be listed explicitly
 
diff -ruw linux-2.6.32.27/kernel/pid.c linux-2.6.32.27-fbx/kernel/pid.c
--- linux-2.6.32.27/kernel/pid.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/kernel/pid.c	2011-08-29 16:28:23.301763249 +0200
@@ -79,7 +79,7 @@
 	.level = 0,
 	.child_reaper = &init_task,
 };
-EXPORT_SYMBOL_GPL(init_pid_ns);
+EXPORT_SYMBOL(init_pid_ns);
 
 int is_container_init(struct task_struct *tsk)
 {
diff -ruw linux-2.6.32.27/kernel/printk.c linux-2.6.32.27-fbx/kernel/printk.c
--- linux-2.6.32.27/kernel/printk.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/kernel/printk.c	2011-08-29 16:28:23.301763249 +0200
@@ -51,6 +51,10 @@
 
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(char *);
+#endif
+
 /* printk's without a loglevel use this.. */
 #define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */
 
@@ -257,6 +261,29 @@
 #endif
 
 /*
+ * dump log buffer content in given buffer
+ */
+void console_emergency_dump(char *buf, int *len)
+{
+	int i, limit;
+
+	if (*len > log_buf_len)
+		*len = log_buf_len;
+	if (*len > logged_chars)
+		*len = logged_chars;
+	limit = log_end;
+
+	for (i = 0; i < *len; i++) {
+		int j;
+
+		j = limit - 1 -i;
+		if (j + log_buf_len < log_end)
+			break;
+		buf[*len - 1 - i] = LOG_BUF(j);
+	}
+}
+
+/*
  * Commands to do_syslog:
  *
  * 	0 -- Close the log.  Currently a NOP.
@@ -714,6 +741,9 @@
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
+#ifdef CONFIG_DEBUG_LL
+	printascii(printk_buf);
+#endif
 
 	p = printk_buf;
 
diff -ruw linux-2.6.32.27/lib/Kconfig linux-2.6.32.27-fbx/lib/Kconfig
--- linux-2.6.32.27/lib/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/lib/Kconfig	2011-08-29 16:28:23.371763871 +0200
@@ -118,6 +118,12 @@
 	tristate
 
 #
+# lzma decompressor from lzma sdk
+#
+config DECOMPRESS_LZMASDK
+	tristate
+
+#
 # Generic allocator support is selected if needed
 #
 config GENERIC_ALLOCATOR
@@ -200,4 +206,7 @@
 config GENERIC_ATOMIC64
        bool
 
+config FBXSERIAL
+	bool
+
 endmenu
diff -ruw linux-2.6.32.27/lib/Makefile linux-2.6.32.27-fbx/lib/Makefile
--- linux-2.6.32.27/lib/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/lib/Makefile	2011-08-29 16:28:23.371763871 +0200
@@ -70,6 +70,8 @@
 lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
 lib-$(CONFIG_DECOMPRESS_LZMA) += decompress_unlzma.o
 
+lib-$(CONFIG_DECOMPRESS_LZMASDK) += LzmaDec.o
+
 obj-$(CONFIG_TEXTSEARCH) += textsearch.o
 obj-$(CONFIG_TEXTSEARCH_KMP) += ts_kmp.o
 obj-$(CONFIG_TEXTSEARCH_BM) += ts_bm.o
@@ -77,6 +79,8 @@
 obj-$(CONFIG_SMP) += percpu_counter.o
 obj-$(CONFIG_AUDIT_GENERIC) += audit.o
 
+obj-$(CONFIG_FBXSERIAL) += fbxserial.o
+
 obj-$(CONFIG_SWIOTLB) += swiotlb.o
 obj-$(CONFIG_IOMMU_HELPER) += iommu-helper.o
 obj-$(CONFIG_FAULT_INJECTION) += fault-inject.o
diff -ruw linux-2.6.32.27/net/8021q/vlan.c linux-2.6.32.27-fbx/net/8021q/vlan.c
--- linux-2.6.32.27/net/8021q/vlan.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/8021q/vlan.c	2011-08-29 16:28:23.431764404 +0200
@@ -292,7 +292,7 @@
 /*  Attach a VLAN device to a mac address (ie Ethernet Card).
  *  Returns 0 if the device was created or a negative error code otherwise.
  */
-static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
+int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
 {
 	struct net_device *new_dev;
 	struct net *net = dev_net(real_dev);
diff -ruw linux-2.6.32.27/net/8021q/vlan_core.c linux-2.6.32.27-fbx/net/8021q/vlan_core.c
--- linux-2.6.32.27/net/8021q/vlan_core.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/8021q/vlan_core.c	2011-08-29 16:28:23.431764404 +0200
@@ -38,6 +38,7 @@
 
 	skb->dev = dev;
 	skb->priority = vlan_get_ingress_priority(dev, skb->vlan_tci);
+	skb->rx_class = skb->priority;
 	skb->vlan_tci = 0;
 
 	stats = &dev->stats;
diff -ruw linux-2.6.32.27/net/8021q/vlan_dev.c linux-2.6.32.27-fbx/net/8021q/vlan_dev.c
--- linux-2.6.32.27/net/8021q/vlan_dev.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/8021q/vlan_dev.c	2011-08-29 16:28:23.431764404 +0200
@@ -170,6 +170,7 @@
 	skb_pull_rcsum(skb, VLAN_HLEN);
 
 	skb->priority = vlan_get_ingress_priority(skb->dev, vlan_tci);
+	skb->rx_class = skb->priority;
 
 	pr_debug("%s: priority: %u for TCI: %hu\n",
 		 __func__, skb->priority, vlan_tci);
diff -ruw linux-2.6.32.27/net/core/dev.c linux-2.6.32.27-fbx/net/core/dev.c
--- linux-2.6.32.27/net/core/dev.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/core/dev.c	2011-08-29 16:28:23.481764847 +0200
@@ -127,6 +127,7 @@
 #include <linux/jhash.h>
 #include <linux/random.h>
 #include <trace/events/napi.h>
+#include <linux/kthread.h>
 
 #include "net-sysfs.h"
 
@@ -171,6 +172,19 @@
 static struct list_head ptype_base[PTYPE_HASH_SIZE] __read_mostly;
 static struct list_head ptype_all __read_mostly;	/* Taps */
 
+#ifdef CONFIG_NETRXTHREAD
+
+#define RXTHREAD_MAX_PROCESS    CONFIG_NETRXTHREAD_MAX_PROCESS
+#define RXTHREAD_MAX_PKTS       128
+
+static struct task_struct *krxd;
+static struct sk_buff_head krxd_pkt_queue[CONFIG_NETRXTHREAD_RX_QUEUE];
+static unsigned int krxd_stats_pkts[CONFIG_NETRXTHREAD_RX_QUEUE];
+static unsigned int krxd_stats_dropped[CONFIG_NETRXTHREAD_RX_QUEUE];
+static wait_queue_head_t krxd_wq;
+static unsigned int krxd_pkts_count;
+#endif
+
 /*
  * The @dev_base_head list is protected by @dev_base_lock and the rtnl
  * semaphore.
@@ -1978,6 +1992,23 @@
 DEFINE_PER_CPU(struct netif_rx_stats, netdev_rx_stat) = { 0, };
 
 
+/* Start Freebox added code */
+#if defined(CONFIG_FREEBOX_DIVERTER) || defined(CONFIG_FREEBOX_DIVERTER_MODULE)
+int (*fbxdiverter_hook)(struct sk_buff *);
+
+static int handle_fbxdiverter(struct sk_buff *skb)
+{
+	/* try_module_get is missing here, so there is a race on
+	 * fbxdiverter module deletion */
+	if (!fbxdiverter_hook)
+		return 0;
+	return fbxdiverter_hook(skb);
+}
+
+EXPORT_SYMBOL(fbxdiverter_hook);
+#endif
+
+
 /**
  *	netif_rx	-	post buffer to the network code
  *	@skb: buffer to post
@@ -2149,6 +2180,37 @@
 #define handle_bridge(skb, pt_prev, ret, orig_dev)	(skb)
 #endif
 
+#if defined(CONFIG_FREEBOX_BRIDGE) || defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+struct sk_buff *(*fbxbridge_handle_frame_hook)(struct fbxbridge *p, struct sk_buff *skb);
+
+struct fbxbridge;
+
+static inline struct sk_buff *handle_fbxbridge(struct sk_buff *skb,
+					       struct packet_type **pt_prev, int *ret,
+					       struct net_device *orig_dev)
+{
+	struct fbxbridge *fbxbr;
+
+	if (skb->pkt_type == PACKET_LOOPBACK ||
+	    (fbxbr = skb->dev->fbx_bridge_port) == NULL)
+		return skb;
+
+	if (skb->protocol != __constant_htons(ETH_P_IP) &&
+	    skb->protocol != __constant_htons(ETH_P_ARP))
+		return skb;
+
+	if (*pt_prev) {
+		*ret = deliver_skb(skb, *pt_prev, orig_dev);
+		*pt_prev = NULL;
+	}
+
+	return fbxbridge_handle_frame_hook(fbxbr, skb);
+}
+#else
+#define handle_fbxbridge(skb, pt_prev, ret, orig_dev)   (skb)
+#endif
+
+
 #if defined(CONFIG_MACVLAN) || defined(CONFIG_MACVLAN_MODULE)
 struct sk_buff *(*macvlan_handle_frame_hook)(struct sk_buff *skb) __read_mostly;
 EXPORT_SYMBOL_GPL(macvlan_handle_frame_hook);
@@ -2266,22 +2328,7 @@
 	rcu_read_unlock();
 }
 
-/**
- *	netif_receive_skb - process receive buffer from network
- *	@skb: buffer to process
- *
- *	netif_receive_skb() is the main receive data processing function.
- *	It always succeeds. The buffer may be dropped during processing
- *	for congestion control or by the protocol layers.
- *
- *	This function may only be called from softirq context and interrupts
- *	should be enabled.
- *
- *	Return values (usually ignored):
- *	NET_RX_SUCCESS: no congestion
- *	NET_RX_DROP: packet was dropped
- */
-int netif_receive_skb(struct sk_buff *skb)
+static int netif_receive_skb_end(struct sk_buff *skb)
 {
 	struct packet_type *ptype, *pt_prev;
 	struct net_device *orig_dev;
@@ -2289,19 +2336,6 @@
 	int ret = NET_RX_DROP;
 	__be16 type;
 
-	if (!skb->tstamp.tv64)
-		net_timestamp(skb);
-
-	if (skb->vlan_tci && vlan_hwaccel_do_receive(skb))
-		return NET_RX_SUCCESS;
-
-	/* if we've gotten here through NAPI, check netpoll */
-	if (netpoll_receive_skb(skb))
-		return NET_RX_DROP;
-
-	if (!skb->iif)
-		skb->iif = skb->dev->ifindex;
-
 	null_or_orig = NULL;
 	orig_dev = skb->dev;
 	if (orig_dev->master) {
@@ -2311,12 +2345,6 @@
 			skb->dev = orig_dev->master;
 	}
 
-	__get_cpu_var(netdev_rx_stat).total++;
-
-	skb_reset_network_header(skb);
-	skb_reset_transport_header(skb);
-	skb->mac_len = skb->network_header - skb->mac_header;
-
 	pt_prev = NULL;
 
 	rcu_read_lock();
@@ -2337,6 +2365,10 @@
 		}
 	}
 
+	skb = handle_fbxbridge(skb, &pt_prev, &ret, orig_dev);
+	if (!skb)
+		goto out;
+
 #ifdef CONFIG_NET_CLS_ACT
 	skb = handle_ing(skb, &pt_prev, &ret, orig_dev);
 	if (!skb)
@@ -2379,6 +2411,205 @@
 }
 EXPORT_SYMBOL(netif_receive_skb);
 
+#ifdef CONFIG_NETRXTHREAD
+
+
+static int krxd_action(void *unused)
+{
+	struct sk_buff *skb;
+	unsigned int maxpkt_in_loop;
+
+	set_user_nice(current, -5);
+	current->flags |= PF_NOFREEZE;
+	__set_current_state(TASK_RUNNING);
+
+	maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+	while (1) {
+		unsigned int i, queue, count;
+
+		local_bh_disable();
+		count = CONFIG_NETRXTHREAD_RX_QUEUE;
+		for (i = 0; i < count; i++) {
+			queue = count - i - 1;
+			skb = skb_dequeue(&krxd_pkt_queue[queue]);
+			if (!skb)
+				continue;
+			krxd_pkts_count--;
+			break;
+		}
+
+		if (!skb) {
+			local_bh_enable();
+			wait_event_interruptible(krxd_wq,
+						 krxd_pkts_count != 0);
+			set_current_state(TASK_RUNNING);
+			maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+			continue;
+		}
+
+		netif_receive_skb_end(skb);
+		local_bh_enable();
+
+		/* only schedule when working on lowest prio queue */
+		if (queue == 0) {
+			if (--maxpkt_in_loop == 0) {
+				maxpkt_in_loop = RXTHREAD_MAX_PROCESS;
+				schedule();
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ *	This is invoked by the /proc filesystem handler to display a device
+ *	in detail.
+ */
+void *krxthread_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	int *queue;
+
+	if (*pos > CONFIG_NETRXTHREAD_RX_QUEUE)
+		return NULL;
+
+	queue = kmalloc(sizeof(*queue), GFP_KERNEL);
+	if (!queue)
+		return NULL;
+	*queue = ((int)*pos - 1);
+
+	return queue;
+}
+
+void *krxthread_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	int *queue = v;
+
+	if (*pos == CONFIG_NETRXTHREAD_RX_QUEUE)
+		return NULL;
+
+	++*queue;
+	*pos = *queue + 1;
+	return queue;
+}
+
+void krxthread_seq_stop(struct seq_file *seq, void *v)
+{
+	kfree(v);
+}
+
+static void krxthread_seq_printf_stats(struct seq_file *seq, int queue)
+{
+	seq_printf(seq, "%8u %12u %12u\n",
+		   queue,
+		   krxd_stats_pkts[queue],
+		   krxd_stats_dropped[queue]);
+}
+
+static int krxthread_seq_show(struct seq_file *seq, void *v)
+{
+	int *queue = v;
+
+	if (*queue == -1)
+		seq_printf(seq, "%8s %12s %12s\n",
+			   "queue", "packets", "drops");
+	else
+		krxthread_seq_printf_stats(seq, *queue);
+	return 0;
+}
+
+static const struct seq_operations krxthread_seq_ops = {
+	.start = krxthread_seq_start,
+	.next  = krxthread_seq_next,
+	.stop  = krxthread_seq_stop,
+	.show  = krxthread_seq_show,
+};
+
+static int krxthread_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &krxthread_seq_ops);
+}
+
+static const struct file_operations krxthread_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open    = krxthread_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+#endif /* PROCFS */
+#endif /* RXTHREAD */
+
+/**
+ *	netif_receive_skb - process receive buffer from network
+ *	@skb: buffer to process
+ *
+ *	netif_receive_skb() is the main receive data processing function.
+ *	It always succeeds. The buffer may be dropped during processing
+ *	for congestion control or by the protocol layers.
+ *
+ *	This function may only be called from softirq context and interrupts
+ *	should be enabled.
+ *
+ *	Return values (usually ignored):
+ *	NET_RX_SUCCESS: no congestion
+ *	NET_RX_DROP: packet was dropped
+ */
+int netif_receive_skb(struct sk_buff *skb)
+{
+#ifdef CONFIG_NETRXTHREAD
+	unsigned int len, queue;
+#endif
+
+	if (!skb->tstamp.tv64)
+		net_timestamp(skb);
+
+	if (skb->vlan_tci && vlan_hwaccel_do_receive(skb))
+		return NET_RX_SUCCESS;
+
+	/* if we've gotten here through NAPI, check netpoll */
+	if (netpoll_receive_skb(skb))
+		return NET_RX_DROP;
+
+	if (!skb->iif)
+		skb->iif = skb->dev->ifindex;
+
+	__get_cpu_var(netdev_rx_stat).total++;
+
+	skb_reset_network_header(skb);
+	skb_reset_transport_header(skb);
+	skb->mac_len = skb->network_header - skb->mac_header;
+
+#if defined(CONFIG_FREEBOX_DIVERTER) || defined(CONFIG_FREEBOX_DIVERTER_MODULE)
+	if (handle_fbxdiverter(skb))
+		return NET_RX_SUCCESS;
+#endif
+
+#ifndef CONFIG_NETRXTHREAD
+	return netif_receive_skb_end(skb);
+#else
+	queue = skb->rx_class;
+	if (queue >= CONFIG_NETRXTHREAD_RX_QUEUE)
+		queue = CONFIG_NETRXTHREAD_RX_QUEUE - 1;
+
+	/* queue the packet to the rx thread */
+	local_bh_disable();
+	len = skb_queue_len(&krxd_pkt_queue[queue]);
+	if (len < RXTHREAD_MAX_PKTS) {
+		__skb_queue_tail(&krxd_pkt_queue[queue], skb);
+		krxd_pkts_count++;
+		krxd_stats_pkts[queue]++;
+		if (!len)
+			wake_up(&krxd_wq);
+	} else {
+		krxd_stats_dropped[queue]++;
+		dev_kfree_skb(skb);
+	}
+	local_bh_enable();
+	return NET_RX_SUCCESS;
+#endif
+}
+
 /* Network device is going away, flush any packets still pending  */
 static void flush_backlog(void *arg)
 {
@@ -3283,7 +3514,11 @@
 		goto out_dev;
 	if (!proc_net_fops_create(net, "ptype", S_IRUGO, &ptype_seq_fops))
 		goto out_softnet;
-
+#ifdef CONFIG_NETRXTHREAD
+	if (!proc_net_fops_create(net, "krxthread", S_IRUGO,
+				  &krxthread_seq_fops))
+		goto out;
+#endif
 	if (wext_proc_init(net))
 		goto out_ptype;
 	rc = 0;
@@ -4990,7 +5225,7 @@
 			rebroadcast_time = jiffies;
 		}
 
-		msleep(250);
+		msleep(1);
 
 		if (time_after(jiffies, warning_time + 10 * HZ)) {
 			printk(KERN_EMERG "unregister_netdevice: "
@@ -5683,6 +5918,19 @@
 	open_softirq(NET_TX_SOFTIRQ, net_tx_action);
 	open_softirq(NET_RX_SOFTIRQ, net_rx_action);
 
+#ifdef CONFIG_NETRXTHREAD
+	for (i = 0; i < CONFIG_NETRXTHREAD_RX_QUEUE; i++)
+		skb_queue_head_init(&krxd_pkt_queue[i]);
+	krxd_pkts_count = 0;
+	init_waitqueue_head(&krxd_wq);
+	krxd = kthread_create(krxd_action, NULL, "krxthread");
+	if (IS_ERR(krxd)) {
+		printk(KERN_ERR "unable to create krxd\n");
+		return -ENOMEM;
+	}
+	wake_up_process(krxd);
+#endif
+
 	hotcpu_notifier(dev_cpu_callback, 0);
 	dst_init();
 	dev_mcast_init();
@@ -5701,3 +5949,6 @@
 
 late_initcall_sync(initialize_hashrnd);
 
+#if defined(CONFIG_FREEBOX_BRIDGE_MODULE)
+EXPORT_SYMBOL(fbxbridge_handle_frame_hook);
+#endif
diff -ruw linux-2.6.32.27/net/core/skbuff.c linux-2.6.32.27-fbx/net/core/skbuff.c
--- linux-2.6.32.27/net/core/skbuff.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/core/skbuff.c	2011-08-29 16:28:23.481764847 +0200
@@ -336,7 +336,19 @@
 		skb_get(list);
 }
 
+#ifdef CONFIG_SKB_RECYCLE
+void kfree_recycled_skbmem(struct sk_buff *skb)
+{
+	kfree(skb->head);
+	kmem_cache_free(skbuff_head_cache, skb);
+}
+
+EXPORT_SYMBOL(kfree_recycled_skbmem);
+
+static int skb_release_data(struct sk_buff *skb, int may_recycle)
+#else
 static void skb_release_data(struct sk_buff *skb)
+#endif
 {
 	if (!skb->cloned ||
 	    !atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,
@@ -350,8 +362,16 @@
 		if (skb_has_frags(skb))
 			skb_drop_fraglist(skb);
 
+#ifdef CONFIG_SKB_RECYCLE
+		if (may_recycle && skb->recycle(skb->recycle_data, skb))
+				return 1;
+#endif
 		kfree(skb->head);
 	}
+
+#ifdef CONFIG_SKB_RECYCLE
+	return 0;
+#endif
 }
 
 /*
@@ -415,10 +435,25 @@
 }
 
 /* Free everything but the sk_buff shell. */
+#ifdef CONFIG_SKB_RECYCLE
+static int skb_release_all(struct sk_buff *skb, int may_recycle)
+#else
 static void skb_release_all(struct sk_buff *skb)
+#endif
 {
 	skb_release_head_state(skb);
+#ifdef CONFIG_SKB_RECYCLE
+	if (skb->fclone == SKB_FCLONE_UNAVAILABLE &&
+	    skb->recycle &&
+	    may_recycle) {
+		if (skb_release_data(skb, 1))
+			return 1;
+	} else
+		skb_release_data(skb, 0);
+	return 0;
+#else
 	skb_release_data(skb);
+#endif
 }
 
 /**
@@ -432,8 +467,13 @@
 
 void __kfree_skb(struct sk_buff *skb)
 {
+#ifdef CONFIG_SKB_RECYCLE
+	if (!skb_release_all(skb, 1))
+		kfree_skbmem(skb);
+#else
 	skb_release_all(skb);
 	kfree_skbmem(skb);
+#endif
 }
 EXPORT_SYMBOL(__kfree_skb);
 
@@ -477,6 +517,29 @@
 }
 EXPORT_SYMBOL(consume_skb);
 
+#ifdef CONFIG_SKB_RECYCLE
+void skb_clean_state(struct sk_buff *skb)
+{
+	struct skb_shared_info *shinfo;
+
+	shinfo = skb_shinfo(skb);
+	atomic_set(&shinfo->dataref, 1);
+	shinfo->nr_frags = 0;
+	shinfo->gso_size = 0;
+	shinfo->gso_segs = 0;
+	shinfo->gso_type = 0;
+	shinfo->ip6_frag_id = 0;
+	shinfo->tx_flags.flags = 0;
+	shinfo->frag_list = NULL;
+	memset(&shinfo->hwtstamps, 0, sizeof(shinfo->hwtstamps));
+
+	memset(skb, 0, offsetof(struct sk_buff, recycle));
+	skb->data = skb->head;
+	skb_reset_tail_pointer(skb);
+	skb->truesize = skb->end - skb->head + sizeof(struct sk_buff);
+}
+#endif
+
 /**
  *	skb_recycle_check - check if skb can be reused for receive
  *	@skb: buffer
@@ -544,7 +607,11 @@
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	new->ipvs_property	= old->ipvs_property;
 #endif
+#ifdef CONFIG_IP_FFN
+	new->ffn_state		= FFN_STATE_INIT;
+#endif
 	new->protocol		= old->protocol;
+	new->rx_class		= old->rx_class;
 	new->mark		= old->mark;
 	new->iif		= old->iif;
 	__nf_copy(new, old);
@@ -560,6 +627,9 @@
 #endif
 	new->vlan_tci		= old->vlan_tci;
 
+#ifdef CONFIG_SKB_RECYCLE
+	new->recycle		= NULL;
+#endif
 	skb_copy_secmark(new, old);
 }
 
@@ -587,6 +657,10 @@
 	C(head);
 	C(data);
 	C(truesize);
+#ifdef CONFIG_SKB_RECYCLE
+	C(recycle);
+	C(recycle_data);
+#endif
 	atomic_set(&n->users, 1);
 
 	atomic_inc(&(skb_shinfo(skb)->dataref));
@@ -608,7 +682,11 @@
  */
 struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
 {
+#ifdef CONFIG_SKB_RECYCLE
+	skb_release_all(dst, 0);
+#else
 	skb_release_all(dst);
+#endif
 	return __skb_clone(dst, src);
 }
 EXPORT_SYMBOL_GPL(skb_morph);
@@ -833,7 +911,12 @@
 	if (skb_has_frags(skb))
 		skb_clone_fraglist(skb);
 
+#ifdef CONFIG_SKB_RECYCLE
+	skb_release_data(skb, 0);
+	skb->recycle = NULL;
+#else
 	skb_release_data(skb);
+#endif
 
 	off = (data + nhead) - skb->head;
 
diff -ruw linux-2.6.32.27/net/ipv4/ipconfig.c linux-2.6.32.27-fbx/net/ipv4/ipconfig.c
--- linux-2.6.32.27/net/ipv4/ipconfig.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/ipconfig.c	2011-08-29 16:28:23.531765291 +0200
@@ -187,6 +187,37 @@
 static struct ic_device *ic_first_dev __initdata = NULL;/* List of open device */
 static struct net_device *ic_dev __initdata = NULL;	/* Selected device */
 
+#ifdef CONFIG_VLAN_8021Q
+int register_vlan_device(struct net_device *real_dev, u16 vlan_id);
+
+static void __init prepare_vlan(void)
+{
+	unsigned short oflags;
+	struct net_device *dev;
+	char *p;
+	u16 vid;
+
+	if (!strchr(user_dev_name, '.'))
+		return;
+
+	p = strchr(user_dev_name, '.');
+	*p = 0;
+	vid = simple_strtoul(p + 1, NULL, 10);
+	dev = __dev_get_by_name(&init_net, user_dev_name);
+	if (!dev)
+		goto fail;
+
+	oflags = dev->flags;
+	if (dev_change_flags(dev, oflags | IFF_UP) < 0)
+		goto fail;
+
+	register_vlan_device(dev, vid);
+
+fail:
+	*p = '.';
+}
+#endif
+
 static int __init ic_open_devs(void)
 {
 	struct ic_device *d, **last;
@@ -204,6 +235,11 @@
 			printk(KERN_ERR "IP-Config: Failed to open %s\n", dev->name);
 	}
 
+#ifdef CONFIG_VLAN_8021Q
+	/* register vlan device if needed */
+	prepare_vlan();
+#endif
+
 	for_each_netdev(&init_net, dev) {
 		if (dev->flags & IFF_LOOPBACK)
 			continue;
@@ -658,8 +694,10 @@
 		e += sizeof(ic_req_params);
 
 		if (*vendor_class_identifier) {
+#ifdef IPCONFIG_DEBUG
 			printk(KERN_INFO "DHCP: sending class identifier \"%s\"\n",
 			       vendor_class_identifier);
+#endif
 			*e++ = 60;	/* Class-identifier */
 			len = strlen(vendor_class_identifier);
 			*e++ = len;
diff -ruw linux-2.6.32.27/net/ipv4/ip_input.c linux-2.6.32.27-fbx/net/ipv4/ip_input.c
--- linux-2.6.32.27/net/ipv4/ip_input.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/ip_input.c	2011-08-29 16:28:23.521765202 +0200
@@ -437,6 +437,11 @@
 		goto drop;
 	}
 
+#ifdef CONFIG_IP_FFN
+	if (!ip_ffn_process(skb))
+		return NET_RX_SUCCESS;
+#endif
+
 	/* Remove any debris in the socket control block */
 	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 
diff -ruw linux-2.6.32.27/net/ipv4/ip_output.c linux-2.6.32.27-fbx/net/ipv4/ip_output.c
--- linux-2.6.32.27/net/ipv4/ip_output.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/ip_output.c	2011-08-29 16:28:23.521765202 +0200
@@ -166,6 +166,7 @@
 	}
 
 	skb->priority = sk->sk_priority;
+	skb->rx_class = 1;
 	skb->mark = sk->sk_mark;
 
 	/* Send it out. */
@@ -201,6 +202,11 @@
 		skb = skb2;
 	}
 
+#ifdef CONFIG_IP_FFN
+	if (skb->ffn_state == FFN_STATE_FORWARDABLE)
+		ip_ffn_add(skb);
+#endif
+
 	if (dst->hh)
 		return neigh_hh_output(dst->hh, skb);
 	else if (dst->neighbour)
@@ -303,6 +309,11 @@
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
 
+#ifdef CONFIG_IP_FFN
+	if (skb->ffn_state == FFN_STATE_FAST_FORWARDED)
+		return ip_finish_output(skb);
+#endif
+
 	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
 			    ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
@@ -386,6 +397,7 @@
 			     (skb_shinfo(skb)->gso_segs ?: 1) - 1);
 
 	skb->priority = sk->sk_priority;
+	skb->rx_class = 1;
 	skb->mark = sk->sk_mark;
 
 	return ip_local_out(skb);
@@ -1296,6 +1308,7 @@
 	iph->daddr = rt->rt_dst;
 
 	skb->priority = sk->sk_priority;
+	skb->rx_class = 1;
 	skb->mark = sk->sk_mark;
 	/*
 	 * Steal rt from cork.dst to avoid a pair of atomic_inc/atomic_dec
@@ -1438,6 +1451,9 @@
 #if defined(CONFIG_IP_MULTICAST) && defined(CONFIG_PROC_FS)
 	igmp_mc_proc_init();
 #endif
+#ifdef CONFIG_IP_FFN
+	ip_ffn_init();
+#endif
 }
 
 EXPORT_SYMBOL(ip_generic_getfrag);
diff -ruw linux-2.6.32.27/net/ipv4/Kconfig linux-2.6.32.27-fbx/net/ipv4/Kconfig
--- linux-2.6.32.27/net/ipv4/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/Kconfig	2011-08-29 16:28:23.501765024 +0200
@@ -324,6 +324,11 @@
 
 	  If unsure, say N.
 
+config INET_XFRM_GC_THRESH
+	int "IP: xfrm garbage collect threshold"
+	depends on XFRM
+	default 1024
+
 config INET_AH
 	tristate "IP: AH transformation"
 	select XFRM
diff -ruw linux-2.6.32.27/net/ipv4/Makefile linux-2.6.32.27-fbx/net/ipv4/Makefile
--- linux-2.6.32.27/net/ipv4/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/Makefile	2011-08-29 16:28:23.501765024 +0200
@@ -14,6 +14,7 @@
 	     inet_fragment.o
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
+obj-$(CONFIG_IP_FFN) += ip_ffn.o
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
diff -ruw linux-2.6.32.27/net/ipv4/netfilter/ip_tables.c linux-2.6.32.27-fbx/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.32.27/net/ipv4/netfilter/ip_tables.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/netfilter/ip_tables.c	2011-08-29 16:28:23.541765380 +0200
@@ -1315,6 +1315,10 @@
 			   tmp.num_counters, tmp.counters);
 	if (ret)
 		goto free_newinfo_untrans;
+
+#ifdef CONFIG_IP_FFN
+	ip_ffn_flush_all();
+#endif
 	return 0;
 
  free_newinfo_untrans:
diff -ruw linux-2.6.32.27/net/ipv4/netfilter/Kconfig linux-2.6.32.27-fbx/net/ipv4/netfilter/Kconfig
--- linux-2.6.32.27/net/ipv4/netfilter/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/netfilter/Kconfig	2011-08-29 16:28:23.531765291 +0200
@@ -5,6 +5,9 @@
 menu "IP: Netfilter Configuration"
 	depends on INET && NETFILTER
 
+config IP_FFN
+	bool "IP: Fast forwarding and NAT"
+
 config NF_DEFRAG_IPV4
 	tristate
 	default n
diff -ruw linux-2.6.32.27/net/ipv4/xfrm4_policy.c linux-2.6.32.27-fbx/net/ipv4/xfrm4_policy.c
--- linux-2.6.32.27/net/ipv4/xfrm4_policy.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv4/xfrm4_policy.c	2011-08-29 16:28:23.571765647 +0200
@@ -248,7 +248,7 @@
 	.destroy =		xfrm4_dst_destroy,
 	.ifdown =		xfrm4_dst_ifdown,
 	.local_out =		__ip_local_out,
-	.gc_thresh =		1024,
+	.gc_thresh =		CONFIG_INET_XFRM_GC_THRESH,
 	.entries =		ATOMIC_INIT(0),
 };
 
diff -ruw linux-2.6.32.27/net/ipv6/Kconfig linux-2.6.32.27-fbx/net/ipv6/Kconfig
--- linux-2.6.32.27/net/ipv6/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/ipv6/Kconfig	2011-08-29 16:28:23.571765647 +0200
@@ -173,6 +173,11 @@
 config IPV6_NDISC_NODETYPE
 	bool
 
+config IPV6_SIT_FBX6TO4
+	bool "sit support Freebox 6to4 scheme"
+	depends on IPV6_SIT
+	default n
+
 config IPV6_TUNNEL
 	tristate "IPv6: IP-in-IPv6 tunnel (RFC2473)"
 	select INET6_TUNNEL
diff -ruw linux-2.6.32.27/net/Kconfig linux-2.6.32.27-fbx/net/Kconfig
--- linux-2.6.32.27/net/Kconfig	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/Kconfig	2011-08-29 16:28:23.431764404 +0200
@@ -45,6 +45,26 @@
 
 menu "Networking options"
 
+config NETSKBPAD
+	int "Size reserved by dev_alloc_skb"
+	default 16
+
+config NETRXTHREAD
+	bool "Do rx network processing in kernel thread"
+
+config NETRXTHREAD_RX_QUEUE
+	int "Number of rx queues"
+	default 1
+	depends on NETRXTHREAD
+
+config NETRXTHREAD_MAX_PROCESS
+	int "Maximum number of packet to process before schedule"
+	default 4
+	depends on NETRXTHREAD
+
+config SKB_RECYCLE
+	bool "Skb recycling support"
+
 source "net/packet/Kconfig"
 source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
@@ -186,6 +206,7 @@
 source "net/rds/Kconfig"
 source "net/tipc/Kconfig"
 source "net/atm/Kconfig"
+source "net/fbxatm/Kconfig"
 source "net/802/Kconfig"
 source "net/bridge/Kconfig"
 source "net/dsa/Kconfig"
diff -ruw linux-2.6.32.27/net/Makefile linux-2.6.32.27-fbx/net/Makefile
--- linux-2.6.32.27/net/Makefile	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/Makefile	2011-08-29 16:28:23.431764404 +0200
@@ -40,6 +40,9 @@
 obj-$(CONFIG_SUNRPC)		+= sunrpc/
 obj-$(CONFIG_AF_RXRPC)		+= rxrpc/
 obj-$(CONFIG_ATM)		+= atm/
+ifneq ($(CONFIG_FBXATM),)
+obj-y				+= fbxatm/
+endif
 obj-$(CONFIG_DECNET)		+= decnet/
 obj-$(CONFIG_ECONET)		+= econet/
 obj-$(CONFIG_PHONET)		+= phonet/
diff -ruw linux-2.6.32.27/net/netfilter/nf_conntrack_core.c linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_core.c
--- linux-2.6.32.27/net/netfilter/nf_conntrack_core.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_core.c	2011-08-29 16:28:23.661766444 +0200
@@ -173,6 +173,10 @@
 	nf_ct_remove_expectations(ct);
 }
 
+#ifdef CONFIG_IP_FFN
+extern void ip_ffn_ct_destroy(struct nf_conn *ct);
+#endif
+
 static void
 destroy_conntrack(struct nf_conntrack *nfct)
 {
@@ -184,6 +188,10 @@
 	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
 	NF_CT_ASSERT(!timer_pending(&ct->timeout));
 
+#ifdef CONFIG_IP_FFN
+	ip_ffn_ct_destroy(ct);
+#endif
+
 	/* To make sure we don't get any weird locking issues here:
 	 * destroy_conntrack() MUST NOT be called with a write lock
 	 * to nf_conntrack_lock!!! -HW */
@@ -535,10 +543,12 @@
 	return dropped;
 }
 
+#define MAX_SECURE_CT	256
+
 struct nf_conn *nf_conntrack_alloc(struct net *net,
 				   const struct nf_conntrack_tuple *orig,
 				   const struct nf_conntrack_tuple *repl,
-				   gfp_t gfp)
+				   gfp_t gfp, int secure_pool)
 {
 	struct nf_conn *ct;
 
@@ -554,6 +564,13 @@
 	if (nf_conntrack_max &&
 	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {
 		unsigned int hash = hash_conntrack(net, orig);
+
+		/* Try allocation from secure pool */
+		if (secure_pool &&
+		    atomic_read(&net->ct.count) <
+		    nf_conntrack_max + MAX_SECURE_CT)
+			goto ok;
+
 		if (!early_drop(net, hash)) {
 			atomic_dec(&net->ct.count);
 			if (net_ratelimit())
@@ -568,6 +585,7 @@
 	 * Do not use kmem_cache_zalloc(), as this cache uses
 	 * SLAB_DESTROY_BY_RCU.
 	 */
+ok:
 	ct = kmem_cache_alloc(net->ct.nf_conntrack_cachep, gfp);
 	if (ct == NULL) {
 		pr_debug("nf_conntrack_alloc: Can't alloc conntrack.\n");
@@ -631,7 +649,8 @@
 		return NULL;
 	}
 
-	ct = nf_conntrack_alloc(net, tuple, &repl_tuple, GFP_ATOMIC);
+	ct = nf_conntrack_alloc(net, tuple, &repl_tuple, GFP_ATOMIC,
+				skb->rx_class != 0);
 	if (IS_ERR(ct)) {
 		pr_debug("Can't allocate conntrack.\n");
 		return (struct nf_conntrack_tuple_hash *)ct;
diff -ruw linux-2.6.32.27/net/netfilter/nf_conntrack_proto_tcp.c linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_proto_tcp.c
--- linux-2.6.32.27/net/netfilter/nf_conntrack_proto_tcp.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_proto_tcp.c	2011-08-29 16:28:23.661766444 +0200
@@ -1021,6 +1021,17 @@
 	return NF_ACCEPT;
 }
 
+#ifdef CONFIG_IP_FFN
+int external_tcpv4_packet(struct nf_conn *ct,
+			  const struct sk_buff *skb,
+			  unsigned int dataoff,
+			  enum ip_conntrack_info ctinfo)
+{
+	return tcp_packet(ct, skb, dataoff, ctinfo, AF_INET, 0);
+}
+#endif
+
+
 /* Called when a new connection for this protocol found. */
 static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		    unsigned int dataoff)
diff -ruw linux-2.6.32.27/net/netfilter/nf_conntrack_proto_udp.c linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_proto_udp.c
--- linux-2.6.32.27/net/netfilter/nf_conntrack_proto_udp.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/netfilter/nf_conntrack_proto_udp.c	2011-08-29 16:28:23.661766444 +0200
@@ -84,6 +84,16 @@
 	return NF_ACCEPT;
 }
 
+#ifdef CONFIG_IP_FFN
+int external_udpv4_packet(struct nf_conn *ct,
+			  const struct sk_buff *skb,
+			  unsigned int dataoff,
+			  enum ip_conntrack_info ctinfo)
+{
+	return udp_packet(ct, skb, dataoff, ctinfo, AF_INET, 0);
+}
+#endif
+
 /* Called when a new connection for this protocol found. */
 static bool udp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		    unsigned int dataoff)
diff -ruw linux-2.6.32.27/net/socket.c linux-2.6.32.27-fbx/net/socket.c
--- linux-2.6.32.27/net/socket.c	2010-12-09 22:29:45.000000000 +0100
+++ linux-2.6.32.27-fbx/net/socket.c	2011-08-29 16:28:23.731767067 +0200
@@ -886,6 +886,31 @@
 
 EXPORT_SYMBOL(dlci_ioctl_set);
 
+static DEFINE_MUTEX(fbxdiverter_ioctl_mutex);
+static int (*fbxdiverter_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg) = NULL;
+
+void fbxdiverter_ioctl_set(int (*hook) (struct net *, unsigned int,
+					void __user *))
+{
+	mutex_lock(&fbxdiverter_ioctl_mutex);
+	fbxdiverter_ioctl_hook = hook;
+	mutex_unlock(&fbxdiverter_ioctl_mutex);
+}
+
+EXPORT_SYMBOL(fbxdiverter_ioctl_set);
+
+static DEFINE_MUTEX(fbxbridge_ioctl_mutex);
+static int (*fbxbridge_ioctl_hook)(struct net *, unsigned int cmd, void __user *arg) = NULL;
+
+void fbxbridge_set(int (*hook)(struct net *, unsigned int, void __user *))
+{
+	mutex_lock(&fbxbridge_ioctl_mutex);
+	fbxbridge_ioctl_hook = hook;
+	mutex_unlock(&fbxbridge_ioctl_mutex);
+}
+
+EXPORT_SYMBOL(fbxbridge_set);
+
 /*
  *	With an ioctl, arg may well be a user mode pointer, but we don't know
  *	what to do with it - that's up to the protocol still.
@@ -958,6 +983,28 @@
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+		case SIOCGFBXDIVERT:
+		case SIOCSFBXDIVERT:
+			err = -ENOPKG;
+			if (!fbxdiverter_ioctl_hook)
+				request_module("fbxdiverter");
+
+			mutex_lock(&fbxdiverter_ioctl_mutex);
+			if (fbxdiverter_ioctl_hook)
+				err = fbxdiverter_ioctl_hook(net, cmd, argp);
+			mutex_unlock(&fbxdiverter_ioctl_mutex);
+			break;
+		case SIOCGFBXBRIDGE:
+		case SIOCSFBXBRIDGE:
+			err = -ENOPKG;
+			if (!fbxbridge_ioctl_hook)
+				request_module("fbxbridge");
+
+			mutex_lock(&fbxbridge_ioctl_mutex);
+			if (fbxbridge_ioctl_hook)
+				err = fbxbridge_ioctl_hook(net, cmd, argp);
+			mutex_unlock(&fbxbridge_ioctl_mutex);
+			break;
 		default:
 			err = sock->ops->ioctl(sock, cmd, arg);
 
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/arch/x86/kernel/fbxbootinfo.c	2011-01-06 02:17:50.582153704 +0100
@@ -0,0 +1,42 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fbxbootinfo.h>
+#include <linux/init.h>
+
+#include <asm/bootparam.h>
+
+static struct fbx_bootinfo fbx_bootinfo;
+
+u32 loader_bank_number;
+EXPORT_SYMBOL(loader_bank_number);
+
+char loader_version_str[128];
+EXPORT_SYMBOL(loader_version_str);
+
+u32 loader_bank0_forced;
+EXPORT_SYMBOL(loader_bank0_forced);
+
+char cefdk_version_str[256];
+EXPORT_SYMBOL(cefdk_version_str);
+
+void __init parse_fbxbootinfo(struct setup_data *data)
+{
+	if (data->len != sizeof (fbx_bootinfo)) {
+		printk(KERN_ERR "%s: invalid length: "
+		       "have %i, want %i\n", __func__, data->len,
+			sizeof (fbx_bootinfo));
+	}
+	memcpy(&fbx_bootinfo, data->data, data->len);
+
+	loader_bank_number = fbx_bootinfo.bank_number;
+	memcpy(&loader_version_str, &fbx_bootinfo.uboot_version_str,
+				sizeof(loader_version_str));
+	loader_bank0_forced = fbx_bootinfo.bank0_forced;
+	memcpy(&cefdk_version_str, &fbx_bootinfo.cefdk_version_str,
+				sizeof(cefdk_version_str));
+}
+
+const struct fbx_bootinfo *arch_get_fbxbootinfo(void)
+{
+	return &fbx_bootinfo;
+}
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/arch/x86/kernel/fbxserial.c	2011-08-29 16:28:17.741713846 +0200
@@ -0,0 +1,64 @@
+
+#include <linux/kernel.h>
+#include <linux/fbxserial.h>
+#include <linux/init.h>
+#include <linux/random.h>
+
+#include <asm/bootparam.h>
+
+static struct fbx_serial serial_info;
+static int parse_done;
+
+void __init parse_fbxserial_ext(struct setup_data *data)
+{
+	if (data->len != sizeof (serial_info)) {
+		printk(KERN_ERR "parse_fbxserial_ext: invalid length: "
+		       "have %i, want %i\n", data->len, sizeof (serial_info));
+	}
+	fbxserialinfo_read(data->data, &serial_info);
+	parse_done = 1;
+}
+
+static void __init seed_random(uint8_t *mac_addr, size_t len)
+{
+	u8 seed[4], val[4];
+	int i;
+
+	memcpy(val, mac_addr + (MAC_ADDR_SIZE - sizeof(val)), sizeof(val));
+
+	for (i = 0; i < sizeof(val); i++)
+		seed[i] ^= val[i];
+
+	for (i = 0; i < 512; i++)
+		add_raw_randomness(seed, sizeof(seed));
+}
+
+static int __init fbxserial_parse_check(void)
+{
+	if (!parse_done) {
+		/*
+		 * just setup magic and crc with bogus values.
+		 */
+		u32 bad_serial[sizeof (struct fbx_serial) / sizeof (u32)] =
+			{ 0xaa55aa55, 0xaa55aa55 };
+
+		/*
+		 * feed serial info deliberately with bad data to
+		 * enforce default settings.
+		 */
+		printk(KERN_ERR "parse_fbxserial_ext was not called. "
+		       "please fix/update your bootloader.\n");
+		fbxserialinfo_read(bad_serial, &serial_info);
+	}
+
+	seed_random(serial_info.mac_addr_base, MAC_ADDR_SIZE);
+
+	return 0;
+}
+arch_initcall(fbxserial_parse_check);
+
+
+const struct fbx_serial *arch_get_fbxserial(void)
+{
+	return &serial_info;
+}
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/arch/x86/kernel/i2c-intelce.c	2011-08-29 16:28:17.741713846 +0200
@@ -0,0 +1,320 @@
+/*
+ * i2c driver for Intel CE
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DPRINTF(args...)  printk(args)
+#else
+#define DPRINTF(args...)
+#endif
+
+#define ICR             (0x00)
+#define ISR             (0x04)
+#define ISAR            (0x08)
+#define IBMR            (0x10)
+#define IDBR            (0x0C)
+
+#define ICR_START       (1 << 0)           /* start bit */
+#define ICR_STOP        (1 << 1)           /* stop bit */
+#define ICR_ACKNAK      (1 << 2)           /* send ACK(0) or NAK(1) */
+#define ICR_TB          (1 << 3)           /* transfer byte bit */
+#define ICR_MA          (1 << 4)           /* master abort */
+#define ICR_SCLE        (1 << 5)           /* master clock enable */
+#define ICR_IUE         (1 << 6)           /* unit enable */
+#define ICR_GCD         (1 << 7)           /* general call disable */
+#define ICR_ITEIE       (1 << 8)           /* enable tx interrupts */
+#define ICR_IRFIE       (1 << 9)           /* enable rx interrupts */
+#define ICR_BEIE        (1 << 10)          /* enable bus error ints */
+#define ICR_SSDIE       (1 << 11)          /* slave STOP detected int enable */
+#define ICR_ALDIE       (1 << 12)          /* enable arbitration interrupt */
+#define ICR_SADIE       (1 << 13)          /* slave address detected int enable */
+#define ICR_UR          (1 << 14)          /* unit reset */
+#define ICR_FM          (1 << 15)          /* fast mode */
+
+#define ISR_RWM         (1 << 0)           /* read/write mode */
+#define ISR_ACKNAK      (1 << 1)           /* ack/nak status */
+#define ISR_UB          (1 << 2)           /* unit busy */
+#define ISR_IBB         (1 << 3)           /* bus busy */
+#define ISR_SSD         (1 << 4)           /* slave stop detected */
+#define ISR_ALD         (1 << 5)           /* arbitration loss detected */
+#define ISR_ITE         (1 << 6)           /* tx buffer empty */
+#define ISR_IRF         (1 << 7)           /* rx buffer full */
+#define ISR_GCAD        (1 << 8)           /* general call address detected */
+#define ISR_SAD         (1 << 9)           /* slave address detected */
+#define ISR_BED         (1 << 10)          /* bus error no ACK/NAK */
+#define ISR_RESERVED	0xfffff800
+
+#define I2C_WRITE	0
+#define I2C_READ	1
+
+#define I2C_BUS_ADDR	(0xdffe0500)
+#define I2C_BUS1_ADDR	(I2C_BUS_ADDR + 0x100)
+#define I2C_BUS_SIZE	(0x100 - 1)
+
+#define PFX	"CK505: "
+
+static void __iomem *base_addr;
+
+static inline u32 i2c_reg_read(u32 reg)
+{
+	return readl(base_addr + reg);
+}
+
+static inline void i2c_reg_write(u32 val, u32 reg)
+{
+	writel(val, base_addr + reg);
+}
+
+/*
+ * udelay is not working yet, so provide a dummy version
+ * which is sufficent for polling.
+ */
+static void __local_udelay(u32 delay)
+{
+	u16 timeout = ~0;
+
+	while (timeout--)
+		asm volatile("nop");
+}
+
+static int i2c_hw_init(void)
+{
+	u32 reg = 0;
+
+	base_addr = early_ioremap(I2C_BUS1_ADDR, I2C_BUS_SIZE);
+	if (!base_addr) {
+		printk(KERN_ERR PFX "failed to early_ioremap 0x%08x\n", I2C_BUS1_ADDR);
+		return -1;
+	}
+
+	/*
+	 * reset the unit and clear any pending interrupt
+	 */
+	reg |= ICR_UR;
+	i2c_reg_write(reg, ICR);
+	i2c_reg_write(0, ICR);
+	i2c_reg_write(0, ISR);
+
+	/*
+	 * TX empty and RX full interrupts are set automatically
+	 */
+	reg = ICR_IUE | ICR_SCLE | ICR_GCD;
+	i2c_reg_write(reg, ICR);
+	__local_udelay(100);
+
+	return 0;
+}
+
+static void i2c_clear_interrupt(void)
+{
+	u32 reg;
+
+	reg = i2c_reg_read(ISR);
+	reg &= (ISR_SSD | ISR_ALD | ISR_ITE | ISR_IRF | ISR_SAD | ISR_BED);
+	i2c_reg_write(reg, ISR);
+}
+
+static int i2c_wait(u32 cond, u32 *last_reg)
+{
+	volatile u32 reg;
+	int count = 100;
+
+	while (count) {
+		reg = i2c_reg_read(ISR);
+		if (reg & cond) {
+			*last_reg = reg;
+			i2c_clear_interrupt();
+			return 0;
+		}
+		count--;
+		__local_udelay(10);
+	}
+
+	i2c_clear_interrupt();
+	return -1;
+}
+
+static int i2c_send_start(u8 addr, unsigned op)
+{
+	u32 reg;
+	int status;
+
+	/* write slave address */
+	i2c_reg_write((addr << 1) | op, IDBR);
+
+	reg = i2c_reg_read(ICR);
+	reg &= ~(ICR_START | ICR_STOP | ICR_ALDIE | ICR_ACKNAK | ICR_TB);
+	reg |= ICR_START | ICR_TB;
+	i2c_reg_write(reg, ICR);
+
+	status = i2c_wait(ISR_ITE | ISR_BED, &reg);
+	if (status < 0) {
+		DPRINTF("%s: timeout\n", __func__);
+		return -1;
+	}
+
+	if (reg & ISR_BED) {
+		DPRINTF("%s: bus error\n", __func__);
+		return -1;
+	}
+
+	if (reg & ISR_ACKNAK) {
+		DPRINTF("%s: invalid return: %08x\n", __func__, reg);
+		return -2;
+	}
+
+	return 0;
+}
+
+static int i2c_tx_byte(u8 byte, unsigned stop)
+{
+	u32 reg;
+	int status;
+
+	/* load data */
+	i2c_reg_write(byte, IDBR);
+
+	reg = i2c_reg_read(ICR);
+	reg &= ~(ICR_START | ICR_STOP | ICR_ALDIE | ICR_ACKNAK | ICR_TB);
+	reg |= ICR_ALDIE | ICR_TB;
+	if (stop)
+		reg |= ICR_STOP;
+
+	i2c_reg_write(reg, ICR);
+
+	status = i2c_wait(ISR_ITE, &reg);
+	if (status < 0) {
+		DPRINTF("%s: timeout\n", __func__);
+		return -1;
+	}
+
+	if (reg & ISR_BED) {
+		DPRINTF("%s: bus error\n", __func__);
+		return -1;
+	}
+
+	if (reg & ISR_ACKNAK) {
+		DPRINTF("%s: invalid return: %08x\n", __func__, reg);
+		return -2;
+	}
+
+	return 0;
+}
+
+static int i2c_rx_byte(unsigned stop)
+{
+	u32 reg;
+	int status;
+
+	reg = i2c_reg_read(ICR);
+	reg &= ~(ICR_START | ICR_STOP | ICR_ALDIE | ICR_ACKNAK | ICR_TB);
+	reg |= ICR_ALDIE | ICR_TB;
+	if (stop)
+		reg |= ICR_STOP | ICR_ACKNAK;
+
+	i2c_reg_write(reg, ICR);
+	status = i2c_wait(ISR_IRF, &reg);
+	if (status < 0) {
+		DPRINTF("%s: timeout\n", __func__);
+		return -1;
+	}
+
+	if (reg & ISR_BED) {
+		DPRINTF("%s: bus error\n", __func__);
+		return -1;
+	}
+
+	return i2c_reg_read(IDBR);
+}
+
+#define CK505_ADDR		(0x69)
+#define CK505_SPREAD_REG	(0x01)
+#define CK505_SPREAD_CENTRAL	(1 << 6)
+
+int __init sdv_i2c_fixup_ck505(void)
+{
+	int ret;
+	u8 byte;
+
+	i2c_hw_init();
+
+	ret = i2c_send_start(CK505_ADDR, I2C_WRITE);
+	if (ret) {
+		printk(KERN_ERR "failed to i2c_send_start\n");
+		goto out_unmap;
+	}
+
+	ret = i2c_tx_byte(CK505_SPREAD_REG, 1);
+	if (ret) {
+		printk(KERN_ERR "failed to write reg\n");
+		goto out_unmap;
+	}
+
+	ret = i2c_send_start(CK505_ADDR, I2C_READ);
+	if (ret) {
+		printk(KERN_ERR "failed to i2c_send_start\n");
+		goto out_unmap;
+	}
+
+	byte = i2c_rx_byte(0);
+	if (byte < 0) {
+		printk(KERN_ERR "failed to read\n");
+		goto out_unmap;
+	}
+
+	byte = i2c_rx_byte(1);
+	if (byte < 0) {
+		printk(KERN_ERR "failed to read\n");
+		goto out_unmap;
+	}
+
+	if (byte & CK505_SPREAD_CENTRAL) {
+		printk(KERN_INFO PFX "no fixup required: 0x%02x\n", byte);
+		goto out_unmap;
+	}
+
+	printk(KERN_INFO PFX "fixing up: 0x%02x -> 0x%02x\n",
+				byte, byte | CK505_SPREAD_CENTRAL);
+
+	/* Set the PLL1_SSC_SEL to central spread spectrum mode */
+	byte |= CK505_SPREAD_CENTRAL;
+
+	ret = i2c_send_start(CK505_ADDR, I2C_WRITE);
+	if (ret) {
+		printk(KERN_ERR "failed to send start\n");
+		goto out_unmap;
+	}
+
+	ret = i2c_tx_byte(CK505_SPREAD_REG, 0);
+	if (ret) {
+		printk(KERN_ERR "failed to write byte\n");
+		goto out_unmap;
+	}
+
+	ret = i2c_tx_byte(CK505_SPREAD_REG, 0);
+	if (ret) {
+		printk(KERN_ERR "failed to write byte\n");
+		goto out_unmap;
+	}
+
+	ret = i2c_tx_byte(byte, 1);
+	if (ret) {
+		printk(KERN_ERR "failed to write byte\n");
+		goto out_unmap;
+	}
+
+	printk(KERN_INFO PFX "successfully fixed-up\n");
+
+out_unmap:
+	early_iounmap(base_addr, I2C_BUS_SIZE);
+
+	return ret;
+}
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/arch/x86/pci/intel_media_proc_gen3.c	2011-08-29 16:28:17.821714558 +0200
@@ -0,0 +1,323 @@
+/*
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2005-2009 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <asm/pci_x86.h>
+
+typedef struct {
+	u32 value;
+	u32 mask;
+} sim_reg_t;
+
+typedef struct {
+	int dev;
+	int func;
+	int reg;
+	sim_reg_t sim_reg;
+} sim_dev_reg_t;
+
+#define MB (1024 * 1024)
+#define KB (1024)
+#define SIZE_TO_MASK(size) (~(size - 1))
+
+static sim_dev_reg_t av_dev_reg_fixups[] = {
+	{  2, 0, 0x10, { 0, SIZE_TO_MASK(16 * MB) } },
+	{  2, 0, 0x14, { 0, SIZE_TO_MASK(256) } },
+	{  2, 1, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{  3, 0, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{  4, 0, 0x10, { 0, SIZE_TO_MASK(128 * KB) } },
+	{  4, 1, 0x10, { 0, SIZE_TO_MASK(128 * KB) } },
+	{  6, 0, 0x10, { 0, SIZE_TO_MASK(512 * KB) } },
+	{  6, 1, 0x10, { 0, SIZE_TO_MASK(512 * KB) } },
+	{  6, 2, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+
+	{  8, 0, 0x10, { 0, SIZE_TO_MASK(1 * MB) } },
+	{  8, 1, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{  8, 2, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+
+	{  9, 0, 0x10, { 0, SIZE_TO_MASK(1 * MB) } },
+	{  9, 0, 0x14, { 0, SIZE_TO_MASK(64 * KB) } },
+	{ 10, 0, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 10, 0, 0x14, { 0, SIZE_TO_MASK(256 * MB) } },
+	{ 11, 0, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 0, 0x14, { 0, SIZE_TO_MASK(256) } },
+
+	{ 11, 1, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 2, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 2, 0x14, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 2, 0x18, { 0, SIZE_TO_MASK(256) } },
+
+	{ 11, 3, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 3, 0x14, { 0, SIZE_TO_MASK(256) } },
+
+	{ 11, 4, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 5, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{ 11, 6, 0x10, { 0, SIZE_TO_MASK(256) } },
+	{ 11, 7, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+
+	{ 12, 0, 0x10, { 0, SIZE_TO_MASK(128 * KB) } },
+	{ 12, 0, 0x14, { 0, SIZE_TO_MASK(256) } },
+	{ 12, 1, 0x10, { 0, SIZE_TO_MASK(1024) } },
+	{ 13, 0, 0x10, { 0, SIZE_TO_MASK(32 * KB) } },
+	{ 13, 1, 0x10, { 0, SIZE_TO_MASK(32 * KB) } },
+
+	{ 14, 0,    8, { 0x01060100, 0 } },
+
+	{ 14, 0, 0x10, { 0, 0 } },
+	{ 14, 0, 0x14, { 0, 0 } },
+	{ 14, 0, 0x18, { 0, 0 } },
+	{ 14, 0, 0x1C, { 0, 0 } },
+	{ 14, 0, 0x20, { 0, 0 } },
+	{ 14, 0, 0x24, { 0, SIZE_TO_MASK(0x200) } },
+
+	{ 15, 0, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{ 15, 0, 0x14, { 0, SIZE_TO_MASK(64 * KB) } },
+
+	{ 16, 0, 0x10, { 0, SIZE_TO_MASK(64 * KB) } },
+	{ 16, 0, 0x14, { 0, SIZE_TO_MASK(64 * MB) } },
+	{ 16, 0, 0x18, { 0, SIZE_TO_MASK(64 * MB) } },
+
+	{ 17, 0, 0x10, { 0, SIZE_TO_MASK(128 * KB) } },
+	{ 18, 0, 0x10, { 0, SIZE_TO_MASK(1 * KB) } }
+};
+
+static const int num_av_dev_reg_fixups = sizeof (av_dev_reg_fixups) /
+	sizeof (av_dev_reg_fixups[0]);
+
+static u32 sata_cfg_phys_addr = 0;
+
+
+static void init_sim_regs(void)
+{
+	int i;
+
+	pci_direct_conf1.read(0, 1, PCI_DEVFN(14, 0), 0x10, 4,
+			&sata_cfg_phys_addr);
+
+	for (i = 0; i < num_av_dev_reg_fixups; i++) {
+		if (av_dev_reg_fixups[i].dev == 14) {
+			if (av_dev_reg_fixups[i].reg == 0x24) {
+                                /* SATA AHCI base address has an offset 0x400 from the SATA base
+                                 * physical address.
+                                 */
+				av_dev_reg_fixups[i].sim_reg.value = sata_cfg_phys_addr + 0x400;
+			}
+		} else {
+			pci_direct_conf1.read(0, 1,
+					PCI_DEVFN(av_dev_reg_fixups[i].dev,
+						av_dev_reg_fixups[i].func),
+					av_dev_reg_fixups[i].reg, 4,
+					&av_dev_reg_fixups[i].sim_reg.value);
+		}
+	}
+}
+
+static sim_reg_t *get_sim_reg(unsigned int bus, unsigned int devfn, int reg,
+		int len)
+{
+	unsigned int dev;
+	unsigned int func;
+	int i;
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* A/V bridge devices are on bus 1. */
+	if (bus == 1)
+		for (i = 0; i < num_av_dev_reg_fixups; i++)
+			if ((reg & ~3) == av_dev_reg_fixups[i].reg &&
+				dev == av_dev_reg_fixups[i].dev &&
+				func == av_dev_reg_fixups[i].func)
+				return &av_dev_reg_fixups[i].sim_reg;
+
+	return NULL;
+}
+
+static inline void extract_bytes(u32 *value, int reg, int len)
+{
+	uint32_t mask;
+
+	*value >>= ((reg & 3) * 8);
+	mask = 0xFFFFFFFF >> ((4 - len) * 8);
+	*value &= mask;
+}
+
+static int pci_gen3_read(unsigned int seg, unsigned int bus,
+		unsigned int devfn, int reg, int len, u32 *value)
+{
+	unsigned long flags;
+	unsigned int dev;
+	unsigned int func;
+	u32 av_bridge_base;
+	u32 av_bridge_limit;
+	sim_reg_t *sim_reg;
+	int simulated_read;
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	simulated_read = true;
+
+	sim_reg = get_sim_reg(bus, devfn, reg, len);
+
+	if (sim_reg != NULL) {
+		spin_lock_irqsave(&pci_config_lock, flags);
+		*value = sim_reg->value;
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+
+                /* EHCI registers has 0x100 offset. */
+		if (bus == 1 && dev == 13 && reg == 0x10 && func < 2)
+			if (*value != sim_reg->mask)
+				*value |= 0x100;
+
+		extract_bytes(value, reg, len);
+
+	} else if (bus == 1 && dev == 13 && (func == 0 || func == 1) &&
+			((reg & ~3) == PCI_VENDOR_ID)) {
+		/* Emulate TDI USB controllers. */
+		*value = 0x0101192E;
+		extract_bytes(value, reg, len);
+
+	} else if (bus == 0 && dev == 1 && func == 0) {
+		/* b0:d1:f0 is A/V bridge. */
+		switch (reg) {
+
+                        /* Make BARs appear to not request any memory. */
+			case PCI_BASE_ADDRESS_0:
+			case PCI_BASE_ADDRESS_0 + 1:
+			case PCI_BASE_ADDRESS_0 + 2:
+			case PCI_BASE_ADDRESS_0 + 3:
+				*value = 0;
+				break;
+
+                        /* Since subordinate bus number register is hardwired
+                         * to zero and read only, so do the simulation.
+                         */
+			case PCI_PRIMARY_BUS:
+				if (len == 4) {
+					*value = 0x00010100;
+				} else {
+					simulated_read = false;
+				}
+				break;
+
+			case PCI_SUBORDINATE_BUS:
+				*value = 1;
+				break;
+
+			case PCI_MEMORY_BASE:
+			case PCI_MEMORY_LIMIT:
+                                /* Get the A/V bridge base address. */
+				pci_direct_conf1.read(0, 0, PCI_DEVFN(1, 0), PCI_BASE_ADDRESS_0, 4,
+					&av_bridge_base);
+
+				av_bridge_limit = av_bridge_base + (512*1024*1024 - 1);
+				av_bridge_limit >>= 16;
+				av_bridge_limit &= 0xFFF0;
+
+				av_bridge_base >>= 16;
+				av_bridge_base &= 0xFFF0;
+
+				if (reg == PCI_MEMORY_LIMIT) {
+					*value = av_bridge_limit;
+				} else if (len == 2) {
+					*value = av_bridge_base;
+				} else {
+					*value = (av_bridge_limit << 16) | av_bridge_base;
+				}
+				break;
+                        /* Make prefetchable memory limit smaller than prefetchable
+                         * memory base, so not claim prefetchable memory space.
+                         */
+			case PCI_PREF_MEMORY_BASE:
+				*value = 0xFFF0;
+				break;
+			case PCI_PREF_MEMORY_LIMIT:
+				*value = 0x0;
+				break;
+                        /* Make IO limit smaller than IO base, so not claim IO space. */
+			case PCI_IO_BASE:
+				*value = 0xF0;
+				break;
+			case PCI_IO_LIMIT:
+				*value = 0;
+				break;
+
+			default:
+				simulated_read = false;
+				break;
+		}
+	} else {
+		simulated_read = false;
+	}
+
+	if (!simulated_read)
+		return pci_direct_conf1.read(seg, bus, devfn, reg, len, value);
+
+	return 0;
+}
+
+static int pci_gen3_write(unsigned int seg, unsigned int bus,
+		unsigned int devfn, int reg, int len, u32 value)
+{
+	unsigned long flags;
+	int dev;
+	int func;
+	sim_reg_t *sim_reg;
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	sim_reg = get_sim_reg(bus, devfn, reg, len);
+
+	if (sim_reg != NULL) {
+		spin_lock_irqsave(&pci_config_lock, flags);
+		sim_reg->value = (value & sim_reg->mask) |
+			(sim_reg->value & ~sim_reg->mask);
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+	} else if (bus == 0 && dev == 1 && func == 0 &&
+			((reg & ~3) == PCI_BASE_ADDRESS_0)) {
+                /* Discard writes to A/V bridge BAR. */
+	} else
+		return pci_direct_conf1.write(seg, bus, devfn, reg, len, value);
+
+	return 0;
+}
+
+struct pci_raw_ops pci_gen3_conf = {
+	.read =	pci_gen3_read,
+	.write = pci_gen3_write,
+};
+
+int __init pci_gen3_init(void)
+{
+	printk(KERN_INFO "PCI: Using configuration type GEN3\n");
+	init_sim_regs();
+	raw_pci_ops = &pci_gen3_conf;
+	return 0;
+}
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/config	2011-09-09 16:33:03.879713599 +0200
@@ -0,0 +1,2081 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.27
+# Fri Sep  9 16:31:28 2011
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_BZIP2 is not set
+CONFIG_KERNEL_LZMA=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+# CONFIG_GROUP_SCHED is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_NS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+# CONFIG_PCSPKR_PLATFORM is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+# CONFIG_SPARSE_IRQ is not set
+CONFIG_X86_MPPARSE=y
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+
+#
+# Intel Media SOC Gen3 support
+#
+CONFIG_ARCH_GEN3=y
+CONFIG_BOARD_FBX6HD=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+CONFIG_MATOM=y
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=64
+CONFIG_X86_INTERNODE_CACHE_BYTES=64
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_XADD=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PROCESSOR_SELECT=y
+CONFIG_CPU_SUP_INTEL=y
+# CONFIG_CPU_SUP_CYRIX_32 is not set
+# CONFIG_CPU_SUP_AMD is not set
+# CONFIG_CPU_SUP_CENTAUR is not set
+# CONFIG_CPU_SUP_TRANSMETA_32 is not set
+# CONFIG_CPU_SUP_UMC_32 is not set
+# CONFIG_X86_DS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+# CONFIG_DMI is not set
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=1
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_X86_UP_APIC=y
+# CONFIG_X86_UP_IOAPIC is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+# CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS is not set
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+# CONFIG_X86_ANCIENT_MCE is not set
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_VM86 is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+CONFIG_X86_REBOOTFIXUPS=y
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+# CONFIG_VMSPLIT_3G is not set
+# CONFIG_VMSPLIT_3G_OPT is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_2G_OPT is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_X86_PAE=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ILLEGAL_POINTER_VALUE=0
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+# CONFIG_X86_RESERVE_LOW_64K is not set
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+# CONFIG_X86_PAT is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+CONFIG_HZ_300=y
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=300
+CONFIG_SCHED_HRTICK=y
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x100000
+# CONFIG_COMPAT_VDSO is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/nfs ip=dhcp mem=exactmap memmap=1M$0 memmap=676M@1M hpet=force lapic dhcpclass=linux-fbx6hd"
+CONFIG_CMDLINE_OVERRIDE=y
+
+#
+# Power management and ACPI options
+#
+# CONFIG_PM is not set
+# CONFIG_SFI is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+CONFIG_PCI_GODIRECT=y
+# CONFIG_PCI_GOOLPC is not set
+# CONFIG_PCI_GOANY is not set
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCIEPORTBUS is not set
+CONFIG_ARCH_SUPPORTS_MSI=y
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_INTELCE_PM is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_NETSKBPAD=16
+# CONFIG_NETRXTHREAD is not set
+# CONFIG_SKB_RECYCLE is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_XFRM_GC_THRESH=1024
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_CT_ACCT is not set
+# CONFIG_NF_CONNTRACK_MARK is not set
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+# CONFIG_NF_CONNTRACK_FTP is not set
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_FFN is not set
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_NF_NAT is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+# CONFIG_IP6_NF_TARGET_LOG is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_FBXATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+
+#
+# Classification
+#
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+# CONFIG_BT_L2CAP is not set
+# CONFIG_BT_SCO is not set
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_FREEBOX_PROCFS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_ERASE_PRINTK=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+CONFIG_MTD_FBX6HD_PARTS=y
+CONFIG_MTD_FBX6HD_PARTS_WRITE_ALL=y
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_TS5500 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_FORCE_BAD_BLOCK_ERASE=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_CS553X is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_DENALI=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_FREEBOX_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_ISL29003 is not set
+CONFIG_CRASHZONE=y
+# CONFIG_PI7C9X is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=m
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_ATA_SFF is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# You can enable one or both FireWire driver stacks.
+#
+
+#
+# See the help texts for more information.
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+CONFIG_DEVPHYSMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_GEN3_UART=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_INTEL is not set
+# CONFIG_HW_RANDOM_AMD is not set
+# CONFIG_HW_RANDOM_GEODE is not set
+# CONFIG_HW_RANDOM_VIA is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PXA=y
+# CONFIG_I2C_PXA_SLAVE is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_LANGWELL is not set
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_FREEBOX_GPIO is not set
+# CONFIG_FREEBOX_JTAG is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+CONFIG_SENSORS_ADT7475=y
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+CONFIG_SENSORS_CORETEMP=y
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_SENSORS_APPLESMC is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+# CONFIG_FREEBOX_WATCHDOG is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_DVB_CORE=y
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_DVB_CAPTURE_DRIVERS=y
+
+#
+# Supported SAA7146 based PCI Adapters
+#
+# CONFIG_TTPCI_EEPROM is not set
+# CONFIG_DVB_AV7110 is not set
+# CONFIG_DVB_BUDGET_CORE is not set
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=y
+# CONFIG_DVB_USB_DEBUG is not set
+# CONFIG_DVB_USB_A800 is not set
+# CONFIG_DVB_USB_DIBUSB_MB is not set
+# CONFIG_DVB_USB_DIBUSB_MC is not set
+CONFIG_DVB_USB_DIB0700=m
+# CONFIG_DVB_USB_UMT_010 is not set
+# CONFIG_DVB_USB_CXUSB is not set
+# CONFIG_DVB_USB_M920X is not set
+# CONFIG_DVB_USB_GL861 is not set
+# CONFIG_DVB_USB_AU6610 is not set
+# CONFIG_DVB_USB_DIGITV is not set
+# CONFIG_DVB_USB_VP7045 is not set
+# CONFIG_DVB_USB_VP702X is not set
+# CONFIG_DVB_USB_GP8PSK is not set
+# CONFIG_DVB_USB_NOVA_T_USB2 is not set
+# CONFIG_DVB_USB_TTUSB2 is not set
+# CONFIG_DVB_USB_DTT200U is not set
+# CONFIG_DVB_USB_OPERA1 is not set
+# CONFIG_DVB_USB_AF9005 is not set
+# CONFIG_DVB_USB_DW2102 is not set
+# CONFIG_DVB_USB_CINERGY_T2 is not set
+# CONFIG_DVB_USB_ANYSEE is not set
+# CONFIG_DVB_USB_DTV5100 is not set
+# CONFIG_DVB_USB_AF9015 is not set
+# CONFIG_DVB_USB_CE6230 is not set
+# CONFIG_DVB_USB_FRIIO is not set
+# CONFIG_DVB_TTUSB_BUDGET is not set
+# CONFIG_DVB_TTUSB_DEC is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+# CONFIG_DVB_B2C2_FLEXCOP is not set
+
+#
+# Supported BT878 Adapters
+#
+
+#
+# Supported Pluto2 Adapters
+#
+# CONFIG_DVB_PLUTO2 is not set
+
+#
+# Supported SDMC DM1105 Adapters
+#
+# CONFIG_DVB_DM1105 is not set
+
+#
+# Supported Earthsoft PT1 Adapters
+#
+# CONFIG_DVB_PT1 is not set
+
+#
+# Supported DVB Frontends
+#
+# CONFIG_DVB_FE_CUSTOMISE is not set
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_S5H1411=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_TUNER_DIB0070=m
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_AGP is not set
+# CONFIG_VGA_ARB is not set
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+# CONFIG_SOUND_OSS_CORE_PRECLAIM is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_PCM_OSS_PLUGINS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_RTCTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_USB is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+CONFIG_HID_TOPSEED=y
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_ALIX2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_LEDS_TRIGGER_NETDEV=y
+# CONFIG_FREEBOX_PANEL is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_FREEBOX_DMAMUX is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+
+#
+# IntelCE devices
+#
+CONFIG_INTELCE_GPIO=y
+CONFIG_INTELCE_DFX=y
+# CONFIG_INTELCE_NOR is not set
+CONFIG_INTELCE_PIC16PMU=y
+
+#
+# RemoTI support
+#
+CONFIG_INTELCE_REMOTI=y
+CONFIG_INTELCE_REMOTI_UART=y
+CONFIG_INTELCE_REMOTI_INPUT=y
+CONFIG_INTELCE_REMOTI_LEDS=y
+# CONFIG_INTELCE_REMOTI_GPIO is not set
+
+#
+# RemoTI vendor-specific commands support
+#
+CONFIG_REMOTI_OAD=y
+# CONFIG_REMOTI_TEST is not set
+CONFIG_REMOTI_FBX=y
+# CONFIG_INTELCE_FALCON_FALLS is not set
+CONFIG_FBX6HD=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFS_FS=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=850
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS_XATTR=y
+CONFIG_RAMFS_XATTR_USER=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_HFS_FS=y
+CONFIG_HFSPLUS_FS=y
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=0
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=1
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_CPA_DEBUG is not set
+# CONFIG_OPTIMIZE_INLINING is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+# CONFIG_CRYPTO_BUILTIN_TEST is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_FBXSERIAL=y
+CONFIG_CROSS_PATH="/opt/toolchains/atom32-eglibc-std-2.12-gcc-4.5.2-binutils-2.21/bin/i686-linux-"
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxdmamux./Kconfig linux-2.6.32.27-fbx/drivers/fbxdmamux/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxdmamux./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxdmamux/Kconfig	2011-08-29 16:28:18.331719091 +0200
@@ -0,0 +1,17 @@
+
+menuconfig FREEBOX_DMAMUX
+	bool "Freebox DMA muxing support"
+
+if FREEBOX_DMAMUX
+
+config FREEBOX_DMAMUX_MAX_PRIO
+	int "Number of priority allowed"
+	default 1
+
+comment "DMA devices"
+
+config FREEBOX_DMAMUX_BCM63XX
+	tristate "Broadcom 63xx DMA support"
+	depends on BCM63XX
+
+endif
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxdmamux./Makefile linux-2.6.32.27-fbx/drivers/fbxdmamux/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxdmamux./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxdmamux/Makefile	2011-08-29 16:28:18.331719091 +0200
@@ -0,0 +1,2 @@
+obj-$(CONFIG_FREEBOX_DMAMUX) += fbxdmamux.o
+obj-$(CONFIG_FREEBOX_DMAMUX_BCM63XX) += fbxdmamux_bcm63xx.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxgpio./Kconfig linux-2.6.32.27-fbx/drivers/fbxgpio/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxgpio./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxgpio/Kconfig	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,3 @@
+config FREEBOX_GPIO
+	tristate "Freebox GPIO control interface"
+	default n
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxgpio./Makefile linux-2.6.32.27-fbx/drivers/fbxgpio/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxgpio./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxgpio/Makefile	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_GPIO)	+= fbxgpio_core.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxjtag./Kconfig linux-2.6.32.27-fbx/drivers/fbxjtag/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxjtag./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxjtag/Kconfig	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,3 @@
+config FREEBOX_JTAG
+	tristate "Freebox JTAG control interface"
+	default n
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxjtag./Makefile linux-2.6.32.27-fbx/drivers/fbxjtag/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxjtag./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxjtag/Makefile	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_JTAG)	+= fbxjtag.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxmtd./Kconfig linux-2.6.32.27-fbx/drivers/fbxmtd/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxmtd./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxmtd/Kconfig	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,41 @@
+menuconfig FREEBOX_MTD
+	tristate "Freebox Memory Technology Devices (FBXMTD) support"
+
+if FREEBOX_MTD
+
+config FREEBOX_MTD_BACKEND_AMD
+	bool "Support for AMD compatible flash"
+
+config FREEBOX_MTD_BACKEND_INTEL
+	bool "Support for Intel Strataflash"
+
+config FREEBOX_MTD_BLK
+	tristate "Block device access to fbxmtd"
+	depends on BLOCK
+
+config FREEBOX_MTD_CHAR
+	tristate "Character device access to fbxmtd"
+
+
+comment "Mapping drivers"
+
+#
+# Generic mapping driver.
+#
+config FREEBOX_MTD_MAP_DRV_FBX
+	tristate "Freebox mapping Driver."
+	select CRC32
+
+config FREEBOX_MTD_MAP_DRV_BCM963XX
+	tristate "Broadcom 963xx flash format"
+	select CRC32
+
+#
+# Freebox MTD Map Control interface
+#
+config FREEBOX_MTD_MAP_IOCTL
+	tristate "IOCTL control interface"
+	depends on FREEBOX_MTD_MAP_DRV_FBX
+
+endif
+
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxmtd./Makefile linux-2.6.32.27-fbx/drivers/fbxmtd/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxmtd./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxmtd/Makefile	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,24 @@
+
+# core support
+obj-$(CONFIG_FREEBOX_MTD) += fbxmtd.o
+
+fbxmtd-objs += fbxmtd_core.o fbxmtd_core_io.o
+ifeq ($(CONFIG_FREEBOX_MTD_BACKEND_AMD),y)
+fbxmtd-objs += fbxmtd_core_amd.o
+endif
+
+ifeq ($(CONFIG_FREEBOX_MTD_BACKEND_INTEL),y)
+fbxmtd-objs += fbxmtd_core_intel.o
+endif
+
+# generic character device access support (r/w with read erase modify write)
+obj-$(CONFIG_FREEBOX_MTD_CHAR) += fbxmtd_char.o
+fbxmtd_char-objs += fbxmtd_char_dev.o
+
+# generic r/o block device access support
+obj-$(CONFIG_FREEBOX_MTD_BLK) += fbxmtd_blk.o
+fbxmtd_blk-objs += fbxmtd_blk_dev.o
+
+obj-$(CONFIG_FREEBOX_MTD_MAP_DRV_FBX) += fbxmtd_map_drv_fbx.o
+obj-$(CONFIG_FREEBOX_MTD_MAP_DRV_BCM963XX) += fbxmtd_map_drv_bcm963xx.o
+obj-$(CONFIG_FREEBOX_MTD_MAP_IOCTL) += fbxmtd_map_ioctl.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxpanel./Kconfig linux-2.6.32.27-fbx/drivers/fbxpanel/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxpanel./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxpanel/Kconfig	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,13 @@
+menuconfig FREEBOX_PANEL
+	tristate "Freebox Panel Management"
+	default n
+
+if FREEBOX_PANEL
+
+config FREEBOX_PANEL_HW_PIC_FBX
+	tristate "I2C PIC-based Panel driver."
+	default n
+	select I2C
+
+endif
+
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxpanel./Makefile linux-2.6.32.27-fbx/drivers/fbxpanel/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxpanel./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxpanel/Makefile	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,5 @@
+obj-$(CONFIG_FREEBOX_PANEL)	+= fbxpanel.o
+
+fbxpanel-objs = fbxpanel_class.o fbxpanel_anim.o
+
+obj-$(CONFIG_FREEBOX_PANEL_HW_PIC_FBX)	+= fbxpanel_hw_pic_fbx.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxprocfs./fbxprocfs.c linux-2.6.32.27-fbx/drivers/fbxprocfs/fbxprocfs.c
--- linux-2.6.32.27-fbx/drivers/fbxprocfs./fbxprocfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxprocfs/fbxprocfs.c	2011-08-29 16:28:18.331719091 +0200
@@ -0,0 +1,205 @@
+/*
+ * Freebox ProcFs interface
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+
+#include <linux/fbxprocfs.h>
+
+#define PFX	"fbxprocfs: "
+
+
+static struct list_head clients;
+static struct semaphore clients_mutex;
+
+static struct proc_dir_entry *root;
+
+/*
+ * register  a  fbxprocfs client  with  given  dirname, caller  should
+ * consider returned struct opaque
+ */
+struct fbxprocfs_client *fbxprocfs_add_client(const char *dirname,
+					      struct module *owner)
+{
+	struct fbxprocfs_client *ret, *p;
+
+	ret = NULL;
+	down(&clients_mutex);
+
+	/* check for duplicate */
+	list_for_each_entry(p, &clients, list) {
+		if (!strcmp(dirname, p->dirname))
+			goto out;
+	}
+
+	if (!(ret = kmalloc(sizeof (*ret), GFP_KERNEL))) {
+		printk(KERN_ERR PFX "kmalloc failed\n");
+		goto out;
+	}
+
+	/* try to create client directory */
+	if (!(ret->dir = proc_mkdir(dirname, root))) {
+		printk(KERN_ERR PFX "can't create %s dir\n", dirname);
+		kfree(ret);
+		ret = NULL;
+		goto out;
+	}
+
+	atomic_set(&ret->refcount, 1);
+	ret->dirname = dirname;
+	list_add(&ret->list, &clients);
+
+out:
+	up(&clients_mutex);
+	return ret;
+}
+
+/*
+ * unregister  a  fbxprocfs client, make sure usage count is zero
+ */
+int fbxprocfs_remove_client(struct fbxprocfs_client *client)
+{
+	int ret;
+
+	down(&clients_mutex);
+
+	ret = 0;
+	if (atomic_read(&client->refcount) > 1) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	remove_proc_entry(client->dirname, root);
+	list_del(&client->list);
+	kfree(client);
+
+out:
+	up(&clients_mutex);
+	return ret;
+}
+
+/*
+ * remove given entries from client directory
+ */
+static int
+__remove_entries(struct fbxprocfs_client *client,
+		 const struct fbxprocfs_ro_desc *ro_desc,
+		 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int i;
+
+	for (i = 0; ro_desc && ro_desc[i].name; i++) {
+		remove_proc_entry(ro_desc[i].name, client->dir);
+		atomic_dec(&client->refcount);
+	}
+
+	for (i = 0; rw_desc && rw_desc[i].name; i++) {
+		remove_proc_entry(rw_desc[i].name, client->dir);
+		atomic_dec(&client->refcount);
+	}
+
+	return 0;
+}
+
+/*
+ * create given entries in client directory
+ */
+static int
+__create_entries(struct fbxprocfs_client *client,
+		 const struct fbxprocfs_ro_desc *ro_desc,
+		 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	struct proc_dir_entry	*proc;
+	int			i;
+
+	for (i = 0; ro_desc && ro_desc[i].name; i++) {
+		if (!(proc = create_proc_read_entry(ro_desc[i].name, 0,
+						    client->dir,
+						    ro_desc[i].rfunc,
+						    (void *) ro_desc[i].id))) {
+			printk(KERN_ERR PFX "can't create %s/%s entry\n",
+			       client->dirname, ro_desc[i].name);
+			goto err;
+		}
+		atomic_inc(&client->refcount);
+	}
+
+	for (i = 0; rw_desc && rw_desc[i].name; i++) {
+		if (!(proc = create_proc_entry(rw_desc[i].name, 0,
+					       client->dir))) {
+			printk(KERN_ERR PFX "can't create %s/%s entry\n",
+			       client->dirname, ro_desc[i].name);
+			goto err;
+		}
+
+		proc->read_proc  = rw_desc[i].rfunc;
+		proc->write_proc = rw_desc[i].wfunc;
+		proc->data = (void *)rw_desc[i].id;
+		atomic_inc(&client->refcount);
+	}
+
+	return 0;
+
+err:
+	__remove_entries(client, ro_desc, rw_desc);
+	return -1;
+}
+
+int
+fbxprocfs_create_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int	ret;
+
+	ret = __create_entries(client, ro_desc, rw_desc);
+	return ret;
+}
+
+int
+fbxprocfs_remove_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc)
+{
+	int	ret;
+
+	ret = __remove_entries(client, ro_desc, rw_desc);
+	return ret;
+}
+
+
+static int __init
+fbxprocfs_init(void)
+{
+	INIT_LIST_HEAD(&clients);
+	init_MUTEX(&clients_mutex);
+
+	/* create freebox directory */
+	if (!(root = proc_mkdir("freebox", NULL))) {
+		printk(KERN_ERR PFX "can't create freebox/ dir\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static void __exit
+fbxprocfs_exit(void)
+{
+	remove_proc_entry("freebox", NULL);
+}
+
+module_init(fbxprocfs_init);
+module_exit(fbxprocfs_exit);
+
+EXPORT_SYMBOL(fbxprocfs_create_entries);
+EXPORT_SYMBOL(fbxprocfs_remove_entries);
+EXPORT_SYMBOL(fbxprocfs_add_client);
+EXPORT_SYMBOL(fbxprocfs_remove_client);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxprocfs./Kconfig linux-2.6.32.27-fbx/drivers/fbxprocfs/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxprocfs./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxprocfs/Kconfig	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1,2 @@
+config FREEBOX_PROCFS
+	tristate "Freebox procfs interface"
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxprocfs./Makefile linux-2.6.32.27-fbx/drivers/fbxprocfs/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxprocfs./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxprocfs/Makefile	2011-01-06 02:17:51.082068196 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_FREEBOX_PROCFS) += fbxprocfs.o
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxwatchdog./Kconfig linux-2.6.32.27-fbx/drivers/fbxwatchdog/Kconfig
--- linux-2.6.32.27-fbx/drivers/fbxwatchdog./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxwatchdog/Kconfig	2011-08-29 16:28:18.331719091 +0200
@@ -0,0 +1,20 @@
+menuconfig FREEBOX_WATCHDOG
+	tristate "Freebox Watchdog"
+	default n
+
+if FREEBOX_WATCHDOG
+
+config FREEBOX_WATCHDOG_CHAR
+	bool "Freebox Watchdog char device interface."
+	default n
+
+config FREEBOX_WATCHDOG_BCM63XX
+	tristate "Broadcom 63xx Freebox Watchdog support"
+	depends on BCM63XX
+	default n
+
+config FREEBOX_WATCHDOG_ORION
+	tristate "Marvell Orion support"
+	depends on PLAT_ORION
+
+endif
diff -Nruw linux-2.6.32.27-fbx/drivers/fbxwatchdog./Makefile linux-2.6.32.27-fbx/drivers/fbxwatchdog/Makefile
--- linux-2.6.32.27-fbx/drivers/fbxwatchdog./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/fbxwatchdog/Makefile	2011-08-29 16:28:18.331719091 +0200
@@ -0,0 +1,9 @@
+obj-$(CONFIG_FREEBOX_WATCHDOG) += fbxwatchdog.o
+
+fbxwatchdog-objs = fbxwatchdog_core.o
+ifeq ($(CONFIG_FREEBOX_WATCHDOG_CHAR),y)
+fbxwatchdog-objs += fbxwatchdog_char.o
+endif
+
+obj-$(CONFIG_FREEBOX_WATCHDOG_BCM63XX)	+= fbxwatchdog_bcm63xx.o
+obj-$(CONFIG_FREEBOX_WATCHDOG_ORION)	+= fbxwatchdog_orion.o
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/leds/ledtrig-netdev.c	2011-08-29 16:28:18.801723270 +0200
@@ -0,0 +1,437 @@
+/*
+ * LED Kernel Netdev Trigger
+ *
+ * Toggles the LED to reflect the link and traffic state of a named net device
+ *
+ * Copyright 2007 Oliver Jowett <oliver@opencloud.com>
+ *
+ * Derived from ledtrig-timer.c which is:
+ *  Copyright 2005-2006 Openedhand Ltd.
+ *  Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include "leds.h"
+
+/*
+ * Configurable sysfs attributes:
+ *
+ * device_name - network device name to monitor
+ *
+ * interval - duration of LED blink, in milliseconds
+ *
+ * mode - either "none" (LED is off) or a space separated list of one or more of:
+ *   link: LED's normal state reflects whether the link is up (has carrier) or not
+ *   tx:   LED blinks on transmitted data
+ *   rx:   LED blinks on receive data
+ * 
+ * Some suggestions:
+ *
+ *  Simple link status LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo link >someled/mode
+ *
+ *  Ethernet-style link/activity LED:
+ *  $ echo netdev >someled/trigger
+ *  $ echo eth0 >someled/device_name
+ *  $ echo "link tx rx" >someled/mode
+ *
+ *  Modem-style tx/rx LEDs:
+ *  $ echo netdev >led1/trigger
+ *  $ echo ppp0 >led1/device_name
+ *  $ echo tx >led1/mode
+ *  $ echo netdev >led2/trigger
+ *  $ echo ppp0 >led2/device_name
+ *  $ echo rx >led2/mode
+ *
+ */
+
+#define MODE_LINK 1
+#define MODE_TX   2
+#define MODE_RX   4
+
+struct led_netdev_data {
+	rwlock_t lock;
+	
+	struct timer_list timer;
+	struct notifier_block notifier;	
+	
+	struct led_classdev *led_cdev;
+	struct net_device *net_dev;
+	
+	char device_name[IFNAMSIZ];
+	unsigned interval;
+	unsigned mode;
+	unsigned link_up;
+	unsigned last_activity;
+};
+
+static void set_baseline_state(struct led_netdev_data *trigger_data)
+{  
+	if ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up)
+		led_set_brightness(trigger_data->led_cdev, LED_FULL);
+	else
+		led_set_brightness(trigger_data->led_cdev, LED_OFF);
+	
+	if ((trigger_data->mode & (MODE_TX | MODE_RX)) != 0 && trigger_data->link_up)
+		mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+	else
+		del_timer(&trigger_data->timer);    
+}  
+
+static ssize_t led_device_name_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	
+	read_lock_bh(&trigger_data->lock);
+	sprintf(buf, "%s\n", trigger_data->device_name);
+	read_unlock_bh(&trigger_data->lock);
+	
+	return strlen(buf) + 1;
+}
+  
+static ssize_t led_device_name_store(struct device *dev, 
+				     struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	
+	if (size < 0 || size >= IFNAMSIZ)
+		return -EINVAL;
+	
+	write_lock_bh(&trigger_data->lock);
+
+	strcpy(trigger_data->device_name, buf);
+	if (size > 0 && trigger_data->device_name[size-1] == '\n')
+		trigger_data->device_name[size-1] = 0;
+	
+	if (trigger_data->device_name[0] != 0) {
+		/* check for existing device to update from */
+		trigger_data->net_dev = dev_get_by_name(&init_net, trigger_data->device_name);
+		if (trigger_data->net_dev != NULL)
+			trigger_data->link_up = (dev_get_flags(trigger_data->net_dev) & IFF_LOWER_UP) != 0;
+		set_baseline_state(trigger_data); /* updates LEDs, may start timers */
+	}
+	
+	write_unlock_bh(&trigger_data->lock);	
+	return size;
+}
+
+static DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
+
+static ssize_t led_mode_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	
+	read_lock_bh(&trigger_data->lock);
+	
+	if (trigger_data->mode == 0) {
+		strcpy(buf, "none\n");
+	} else {
+		if (trigger_data->mode & MODE_LINK) 
+			strcat(buf, "link ");
+		if (trigger_data->mode & MODE_TX)
+			strcat(buf, "tx ");
+		if (trigger_data->mode & MODE_RX)
+			strcat(buf, "rx ");
+		strcat(buf, "\n");
+	}
+	
+	read_unlock_bh(&trigger_data->lock);	
+
+	return strlen(buf)+1;
+}
+
+static ssize_t led_mode_store(struct device *dev, 
+			      struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;	
+	char copybuf[1024];
+	int new_mode = -1;
+	char *p, *token;
+
+	/* take a copy since we don't want to trash the inbound buffer when using strsep */
+	strncpy(copybuf, buf, sizeof(copybuf));
+	copybuf[1023] = 0;
+	p = copybuf;
+	
+	while ((token = strsep(&p, " \t\n")) != NULL) {
+		if (!*token)
+			continue;
+		
+		if (new_mode == -1)
+			new_mode = 0;
+		
+		if (!strcmp(token, "none"))
+			new_mode = 0;
+		else if (!strcmp(token, "tx"))
+			new_mode |= MODE_TX;
+		else if (!strcmp(token, "rx"))
+			new_mode |= MODE_RX;
+		else if (!strcmp(token, "link"))
+			new_mode |= MODE_LINK;
+		else
+			return -EINVAL;
+	}
+	
+	if (new_mode == -1)
+		return -EINVAL;
+	
+	write_lock_bh(&trigger_data->lock);	
+	trigger_data->mode = new_mode;  
+	set_baseline_state(trigger_data);
+	write_unlock_bh(&trigger_data->lock);
+	
+	return size;
+}
+
+static DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
+
+static ssize_t led_interval_show(struct device *dev, 
+				 struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	
+	read_lock_bh(&trigger_data->lock);
+	sprintf(buf, "%u\n", jiffies_to_msecs(trigger_data->interval));
+	read_unlock_bh(&trigger_data->lock);
+	
+	return strlen(buf) + 1;
+}
+
+static ssize_t led_interval_store(struct device *dev, 
+				  struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+	int ret = -EINVAL;
+	char *after;
+	unsigned long value = simple_strtoul(buf, &after, 10);
+	size_t count = after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	/* impose some basic bounds on the timer interval */
+	if (count == size && value >= 5 && value <= 10000) {
+		write_lock_bh(&trigger_data->lock);
+		trigger_data->interval = msecs_to_jiffies(value);
+		set_baseline_state(trigger_data); // resets timer
+		write_unlock_bh(&trigger_data->lock);
+		ret = count;
+	}
+	
+	return ret;
+}
+
+static DEVICE_ATTR(interval, 0644, led_interval_show, led_interval_store);
+
+static int netdev_trig_notify(struct notifier_block *nb,
+			      unsigned long evt,
+			      void *dv)
+{
+	struct net_device *dev = dv;
+	struct led_netdev_data *trigger_data = container_of(nb, struct led_netdev_data, notifier);
+	
+	if (evt != NETDEV_UP && evt != NETDEV_DOWN && evt != NETDEV_CHANGE && evt != NETDEV_REGISTER && evt != NETDEV_UNREGISTER)
+		return NOTIFY_DONE;
+	
+	write_lock_bh(&trigger_data->lock);
+
+	if (strcmp(dev->name, trigger_data->device_name))
+		goto done;
+	
+	if (evt == NETDEV_REGISTER) {
+		if (trigger_data->net_dev != NULL)
+			dev_put(trigger_data->net_dev);
+		dev_hold(dev);
+		trigger_data->net_dev = dev;
+		trigger_data->link_up = 0;
+		goto done;
+	}
+	
+	if (evt == NETDEV_UNREGISTER && trigger_data->net_dev != NULL) {
+		dev_put(trigger_data->net_dev);
+		trigger_data->net_dev = NULL;
+		goto done;
+	}
+	
+	/* UP / DOWN / CHANGE */
+	
+	trigger_data->link_up = (evt != NETDEV_DOWN && netif_carrier_ok(dev));
+	set_baseline_state(trigger_data);
+
+done:
+	write_unlock_bh(&trigger_data->lock);  
+	return NOTIFY_DONE;
+}
+
+/* here's the real work! */
+static void netdev_trig_timer(unsigned long arg)
+{
+	struct led_netdev_data *trigger_data = (struct led_netdev_data *)arg;
+	const struct net_device_stats *dev_stats;
+	unsigned new_activity;
+	
+	write_lock(&trigger_data->lock);
+    
+	if (!trigger_data->link_up || !trigger_data->net_dev || (trigger_data->mode & (MODE_TX | MODE_RX)) == 0) {
+		/* we don't need to do timer work, just reflect link state. */
+		led_set_brightness(trigger_data->led_cdev, ((trigger_data->mode & MODE_LINK) != 0 && trigger_data->link_up) ? LED_FULL : LED_OFF);
+		goto no_restart;
+	}
+	
+	dev_stats = dev_get_stats(trigger_data->net_dev);
+	new_activity =
+		((trigger_data->mode & MODE_TX) ? dev_stats->tx_packets : 0) +
+		((trigger_data->mode & MODE_RX) ? dev_stats->rx_packets : 0);
+      
+	if (trigger_data->mode & MODE_LINK) {
+		/* base state is ON (link present) */
+		/* if there's no link, we don't get this far and the LED is off */
+		
+		/* OFF -> ON always */
+		/* ON -> OFF on activity */
+		if (trigger_data->led_cdev->brightness == LED_OFF) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		}
+	} else {
+		/* base state is OFF */
+		/* ON -> OFF always */
+		/* OFF -> ON on activity */
+		if (trigger_data->led_cdev->brightness == LED_FULL) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		}
+	}
+	
+	trigger_data->last_activity = new_activity;
+	mod_timer(&trigger_data->timer, jiffies + trigger_data->interval);
+
+no_restart:
+	write_unlock(&trigger_data->lock);
+}
+
+static void netdev_trig_activate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data;
+	int rc;
+
+	trigger_data = kzalloc(sizeof(struct led_netdev_data), GFP_KERNEL);
+	if (!trigger_data)
+		return;
+
+	rwlock_init(&trigger_data->lock);
+
+	trigger_data->notifier.notifier_call = netdev_trig_notify;
+	trigger_data->notifier.priority = 10;
+
+	setup_timer(&trigger_data->timer, netdev_trig_timer, (unsigned long) trigger_data);
+
+	trigger_data->led_cdev = led_cdev;
+	trigger_data->net_dev = NULL;
+	trigger_data->device_name[0] = 0;
+	
+	trigger_data->mode = 0;
+	trigger_data->interval = msecs_to_jiffies(50);
+	trigger_data->link_up = 0;
+	trigger_data->last_activity = 0;
+	
+	led_cdev->trigger_data = trigger_data;
+
+	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
+	if (rc)
+		goto err_out;
+	rc = device_create_file(led_cdev->dev, &dev_attr_mode);
+	if (rc)
+		goto err_out_device_name;
+	rc = device_create_file(led_cdev->dev, &dev_attr_interval);
+	if (rc)
+		goto err_out_mode;
+
+	register_netdevice_notifier(&trigger_data->notifier);	
+	return;
+
+err_out_mode:
+	device_remove_file(led_cdev->dev, &dev_attr_mode);
+err_out_device_name:
+	device_remove_file(led_cdev->dev, &dev_attr_device_name);
+err_out:
+	led_cdev->trigger_data = NULL;
+	kfree(trigger_data);
+}
+
+static void netdev_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
+
+	if (trigger_data) {	  
+		unregister_netdevice_notifier(&trigger_data->notifier);
+
+		device_remove_file(led_cdev->dev, &dev_attr_device_name);
+		device_remove_file(led_cdev->dev, &dev_attr_mode);
+		device_remove_file(led_cdev->dev, &dev_attr_interval);
+
+		write_lock_bh(&trigger_data->lock);
+		
+		if (trigger_data->net_dev) {
+			dev_put(trigger_data->net_dev);
+			trigger_data->net_dev = NULL;
+		}
+		
+		write_unlock(&trigger_data->lock);
+
+		del_timer_sync(&trigger_data->timer);
+
+		kfree(trigger_data);
+	}
+}
+
+static struct led_trigger netdev_led_trigger = {
+	.name     = "netdev",
+	.activate = netdev_trig_activate,
+	.deactivate = netdev_trig_deactivate,
+};
+
+static int __init netdev_trig_init(void)
+{
+	return led_trigger_register(&netdev_led_trigger);
+}
+
+static void __exit netdev_trig_exit(void)
+{
+	led_trigger_unregister(&netdev_led_trigger);
+}
+
+module_init(netdev_trig_init);
+module_exit(netdev_trig_exit);
+
+MODULE_AUTHOR("Oliver Jowett <oliver@opencloud.com>");
+MODULE_DESCRIPTION("Netdev LED trigger");
+MODULE_LICENSE("GPL");
diff -Nruw linux-2.6.32.27-fbx/drivers/media/dvb/tango2./Kconfig linux-2.6.32.27-fbx/drivers/media/dvb/tango2/Kconfig
--- linux-2.6.32.27-fbx/drivers/media/dvb/tango2./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/tango2/Kconfig	2011-01-06 02:17:51.692064450 +0100
@@ -0,0 +1,11 @@
+config DVB_TANGO2
+	tristate "Tango2 DVB adapter"
+	depends on DVB_CORE && ARCH_FBX5_B
+	select I2C
+	select I2C_ALGOBIT
+	select DVB_TDA1004X
+	select DVB_PLL
+
+config DVB_TANGO2_TESTBED
+	bool "extended testing and useful error codes"
+	depends on DVB_TANGO2
diff -Nruw linux-2.6.32.27-fbx/drivers/media/dvb/tango2./Makefile linux-2.6.32.27-fbx/drivers/media/dvb/tango2/Makefile
--- linux-2.6.32.27-fbx/drivers/media/dvb/tango2./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/media/dvb/tango2/Makefile	2011-01-06 02:17:51.692064450 +0100
@@ -0,0 +1,5 @@
+obj-$(CONFIG_DVB_TANGO2) = tango2_dvb.o
+
+tango2_dvb-objs := tango2.o
+
+EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/ -Idrivers/media/dvb/frontends/
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/misc/crash_zone.c	2011-01-06 02:17:51.921532224 +0100
@@ -0,0 +1,145 @@
+#include <linux/init.h>
+#include <linux/crash_zone.h>
+#include <linux/proc_fs.h>
+#include <asm/checksum.h>
+
+static unsigned char *dead_zone = NULL;
+static unsigned int dead_zone_size;
+
+#define CRASH_DATA_SIZE	(dead_zone_size - sizeof (struct crash_zone))
+
+static inline unsigned short int csum_data(const unsigned char *buff, int len)
+{
+	return csum_fold(csum_partial(buff, len, 0));
+}
+
+static int crash_zone_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	struct crash_header *crash_zone;
+	int datalen;
+
+	/* check crash zone */
+	if (!dead_zone) {
+		printk(KERN_DEBUG "dead zone unset\n");
+		goto empty;
+	}
+
+	crash_zone = (struct crash_header *)dead_zone;
+	if (crash_zone->magic != CRASH_MAGIC) {
+		printk(KERN_DEBUG "bad crash zone magic\n");
+		goto empty;
+	}
+
+	if (crash_zone->len > dead_zone_size) {
+		printk(KERN_DEBUG "bad crash zone len\n");
+		goto empty;
+	}
+
+	if (csum_data((unsigned char *)crash_zone, crash_zone->len)) {
+		printk(KERN_DEBUG "bad crash zone checksum\n");
+		goto empty;
+	}
+
+	/* copy crash data */
+	datalen = crash_zone->len - sizeof (struct crash_header);
+	if (off + count >= datalen) {
+		*eof = 1;
+		count = datalen - off;
+	}
+
+	*start = page;
+	if (count > 0) {
+		memcpy(page, &crash_zone->data + off, count);
+		return count;
+	}
+
+	return 0;
+
+empty:
+	*eof = 1;
+	return 0;
+}
+
+static int crash_zone_write_proc(struct file *file, const char *buffer,
+				 unsigned long count, void *data)
+{
+	struct crash_header *crash_zone;
+	int len;
+
+	if (!dead_zone)
+		return count;
+
+	/* empty the crash zone */
+	crash_zone = (struct crash_header *)dead_zone;
+	len = sizeof (struct crash_header);
+	crash_zone->magic = CRASH_MAGIC;
+	crash_zone->len = len;
+	crash_zone->checksum = 0;
+	crash_zone->checksum = csum_data((unsigned char *)crash_zone, len);
+
+	return count;
+}
+
+static int crash_zone_panic_event(struct notifier_block *self,
+				  unsigned long event, void *data)
+{
+	struct crash_header *crash_zone;
+	int data_len, len;
+
+	if (!dead_zone)
+		return NOTIFY_DONE;
+
+	crash_zone = (struct crash_header *)dead_zone;
+
+	/* copy current kernel log into crash zone */
+	data_len = dead_zone_size - sizeof (struct crash_header);
+	console_emergency_dump(&crash_zone->data, &data_len);
+
+	/* checksum area */
+	len = data_len + sizeof (struct crash_header);
+	crash_zone->magic = CRASH_MAGIC;
+	crash_zone->len = len;
+	crash_zone->checksum = 0;
+	crash_zone->checksum = csum_data((unsigned char *)crash_zone, len);
+	printk("Panic log saved in crash zone\n");
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block crash_panic_block = {
+	crash_zone_panic_event,
+	NULL,
+	INT_MAX /* try to do it first */
+};
+
+void __init crash_zone_set_param(unsigned char *zone, unsigned int size)
+{
+	dead_zone = zone;
+	dead_zone_size = size;
+}
+
+static int __init crash_zone_init(void)
+{
+	struct proc_dir_entry	*proc;
+
+	/* create crash proc entry */
+	proc = create_proc_entry("crash_zone", 0, NULL);
+	if (!proc)
+		return 1;
+	proc->read_proc  = crash_zone_read_proc;
+	proc->write_proc = crash_zone_write_proc;
+
+	/* register panic notifier */
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &crash_panic_block);
+	return 0;
+}
+
+static void __exit crash_zone_exit(void)
+{
+
+}
+
+module_init(crash_zone_init);
+module_exit(crash_zone_exit);
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/mtd/fbx6hd-mtdparts.c	2011-01-06 02:17:51.962066091 +0100
@@ -0,0 +1,243 @@
+/*
+ * MTD parser for fbx6hd, just return a static mtd partition
+ * list. optionally set all partitions to read/write if requested by
+ * config.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/mtd.h>
+
+#define PFX	"fbx6hd-mtdparts: "
+
+#define SZ_1M	(1 << 20)
+
+#define MBR_BLOCKS	(8)
+#define CEFDK_S1_BLOCKS	(8)
+#define CEFDK_S2_BLOCKS	(8 * 4)
+#define SERIAL_BLOCKS	(16)
+#define KEYS_BLOCKS	(8)
+
+
+#define BANK0_SIZE	(18 * SZ_1M)
+#define CONFIG_SIZE	(7 * SZ_1M)
+#define NEWBANK0_SIZE	BANK0_SIZE
+enum {
+	E_PART_ALL,
+	E_PART_MBR,
+	E_PART_CEFDK_S1_B0,
+	E_PART_CEFDK_S1_B1,
+	E_PART_CEFDK_S2_B0,
+	E_PART_CEFDK_S2_B1,
+	E_PART_SERIALINFO,
+	E_PART_KEYS,
+	E_PART_BANK0,
+	E_PART_CONFIG,
+	E_PART_BANK1,
+	E_PART_NEWBANK0,
+};
+
+static struct mtd_partition fbx6hd_nand_partitions[] = {
+	[E_PART_ALL] = {
+		.name		= "all",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_MBR] = {
+		.name		= "mbr",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_CEFDK_S1_B0] = {
+		.name		= "cefdk-stage1-bank0",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_CEFDK_S1_B1] = {
+		.name		= "cefdk-stage1-bank1",
+		.offset		= -1,
+		.size		= -1,
+	},
+	[E_PART_CEFDK_S2_B0] = {
+		.name		= "cefdk-stage2-bank0",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_CEFDK_S2_B1] = {
+		.name		= "cefdk-stage2-bank1",
+		.offset		= -1,
+		.size		= -1,
+	},
+	[E_PART_SERIALINFO] = {
+		.name		= "serial",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_KEYS] = {
+		.name		= "keys",
+		.offset		= -1,
+		.size		= -1,
+	},
+	[E_PART_BANK0] = {
+		.name		= "bank0",
+		.offset		= -1,
+		.size		= -1,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[E_PART_CONFIG] = {
+		.name		= "config",
+		.offset		= -1,
+		.size		= -1,
+	},
+	[E_PART_BANK1] = {
+		.name		= "bank1",
+		.offset		= -1,
+		.size		= -1,
+	},
+	[E_PART_NEWBANK0] = {
+		.name		= "newbank0",
+		.offset		= -1,
+		.size		= -1,
+	},
+};
+
+static int fbx6hd_parse_mtd_partitions(struct mtd_info *master,
+				       struct mtd_partition **pparts,
+				       unsigned long origin)
+{
+	struct mtd_partition *bank1;
+	struct mtd_partition *newbank0;
+	struct mtd_partition *cur_part;
+	u32 cur_offset;
+
+	/*
+	 * make all partition cover the whole flash.
+	 */
+	cur_part = &fbx6hd_nand_partitions[E_PART_ALL];
+	cur_part->offset = 0;
+	cur_part->size = master->size;
+
+	/*
+	 * start filling partition offset/size one by one.
+	 */
+	cur_offset = 0;
+	cur_part = &fbx6hd_nand_partitions[E_PART_MBR];
+	cur_part->offset = cur_offset;
+	cur_part->size = MBR_BLOCKS * master->erasesize;
+
+	/*
+	 * CEFDK stage1 partitions
+	 */
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_CEFDK_S1_B0];
+	cur_part->offset = cur_offset;
+	cur_part->size = CEFDK_S1_BLOCKS * master->erasesize;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_CEFDK_S1_B1];
+	cur_part->offset = cur_offset;
+	cur_part->size = CEFDK_S1_BLOCKS * master->erasesize;
+
+	/*
+	 * CEFDK stage2 partitions
+	 */
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_CEFDK_S2_B0];
+	cur_part->offset = cur_offset;
+	cur_part->size = CEFDK_S2_BLOCKS * master->erasesize;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_CEFDK_S2_B1];
+	cur_part->offset = cur_offset;
+	cur_part->size = CEFDK_S2_BLOCKS * master->erasesize;
+
+	/*
+	 * Freebox specific
+	 */
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_SERIALINFO];
+	cur_part->offset = cur_offset;
+	cur_part->size = SERIAL_BLOCKS * master->erasesize;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_KEYS];
+	cur_part->offset = cur_offset;
+	cur_part->size = KEYS_BLOCKS * master->erasesize;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_BANK0];
+	cur_part->offset = cur_offset;
+	cur_part->size = BANK0_SIZE;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_CONFIG];
+	cur_part->offset = cur_offset;
+	cur_part->size = CONFIG_SIZE;
+
+	cur_offset += cur_part->size;
+	cur_part = &fbx6hd_nand_partitions[E_PART_BANK1];
+	cur_part->offset = cur_offset;
+	cur_part->size = master->size - cur_offset;
+
+	/*
+	 * newbank0 starts inside bank1 partition and ends at the end
+	 * of the flash.
+	 */
+	cur_offset = master->size - NEWBANK0_SIZE;
+	cur_part = &fbx6hd_nand_partitions[E_PART_NEWBANK0];
+	cur_part->offset = cur_offset;
+	cur_part->size = NEWBANK0_SIZE;
+
+	/*
+	 * some basic sanity checks before to avoid botched partitiont
+	 * table.
+	 */
+	bank1 = &fbx6hd_nand_partitions[E_PART_BANK1];
+	newbank0 = &fbx6hd_nand_partitions[E_PART_NEWBANK0];
+	if (bank1->offset > master->size) {
+		printk(KERN_CRIT PFX "bank1 partition starts after flash "
+		       "end: use a bigger flash.\n");
+		return -ENOSPC;
+	}
+
+	if (newbank0->offset < bank1->offset) {
+		printk(KERN_CRIT PFX "newbank0 starts before bank1: use a "
+		       "bigger flash.\n");
+		return -ENOSPC;
+	}
+
+	printk(KERN_INFO PFX "%llu MiB available for bank1.\n",
+	       bank1->size >> 20);
+
+#ifdef CONFIG_MTD_FBX6HD_PARTS_WRITE_ALL
+	int i;
+	for (i = 0; i < ARRAY_SIZE(fbx6hd_nand_partitions); ++i)
+		fbx6hd_nand_partitions[i].mask_flags &= ~MTD_WRITEABLE;
+#endif
+
+	*pparts = fbx6hd_nand_partitions;
+	return ARRAY_SIZE(fbx6hd_nand_partitions);
+}
+
+struct mtd_part_parser fbx6hd_mtd_parser = {
+	.owner		= THIS_MODULE,
+	.parse_fn	= fbx6hd_parse_mtd_partitions,
+	.name		= "fbx6hd-mtdparts",
+};
+
+static int __init fbx6hd_parser_init(void)
+{
+	return register_mtd_parser(&fbx6hd_mtd_parser);
+}
+
+module_init(fbx6hd_parser_init);
+
+
+MODULE_AUTHOR("Nicolas Schichan <nschichan@freebox.fr>");
+MODULE_LICENSE("GPL");
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/denali_nand.c	2011-08-29 16:28:19.281727536 +0200
@@ -0,0 +1,1073 @@
+/*
+ * denali nand controller driver.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+
+#include <linux/mtd/nand.h>
+#include <linux/mtd/mtd.h>
+
+#include <linux/mtd/partitions.h>
+
+#define PFX	"denali_nand: "
+
+#include "denali_nand.h"
+
+static const char *parts_parsers[] = { "fbx6hd-mtdparts", NULL };
+
+static int max_mode __read_mostly = 4;
+module_param(max_mode, int, 0);
+MODULE_PARM_DESC(max_mode, "Maximum ONFI timing mode supported (default: 4)");
+
+static int map_mode __read_mostly;
+module_param(map_mode, int, 0);
+MODULE_PARM_DESC(map_mode, "MAP mode to use (01, 10, 11)");
+
+static int dnl_reset_bank(struct denali_nand_priv *priv);
+
+/*
+ * register accessors
+ */
+static inline u32 dnl_reg_readl(struct denali_nand_priv *priv, u32 addr)
+{
+	return readl(priv->regs + addr);
+}
+
+static inline void dnl_reg_writel(struct denali_nand_priv *priv, u32 val,
+				  u32 addr)
+{
+	writel(val, priv->regs + addr);
+}
+
+/*
+ * mem accessors.
+ */
+static inline u32 dnl_mem_readl(struct denali_nand_priv *priv, u32 addr)
+{
+	return readl(priv->mem + addr);
+}
+
+static inline void dnl_mem_writel(struct denali_nand_priv *priv, u32 val,
+				  u32 addr)
+{
+	writel(val, priv->mem + addr);
+}
+
+/*
+ * read/write to/from a map.
+ */
+static uint32_t dnl_map_read(struct denali_nand_priv *priv, u32 map_ctl)
+{
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+	return dnl_mem_readl(priv, DNL_MAP_DATA_REG);
+}
+
+static void dnl_map_write(struct denali_nand_priv *priv, u32 data,
+				 u32 map_ctl)
+{
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+	dnl_mem_writel(priv, data, DNL_MAP_DATA_REG);
+}
+
+/*
+ * write_buf: support only map11 write, direct NAND bus access.
+ */
+static void dnl_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+	int i;
+	u32 map_ctl;
+
+	nand = mtd->priv;
+	priv = nand->priv;
+
+	map_ctl = DNL_MAP_11_MASK;
+	map_ctl |= priv->chip_num << DNL_CHIP_SHIFT;
+	map_ctl |= DNL_MAP_11_DATA_MASK;
+
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+
+	for (i = 0; i < len; ++i)
+		dnl_mem_writel(priv, buf[i], DNL_MAP_DATA_REG);
+}
+
+static u8 dnl_read_map11_byte(struct denali_nand_priv *priv)
+{
+	u8 ret;
+	u32 map_ctl;
+
+	map_ctl = DNL_MAP_11_MASK;
+	map_ctl |= priv->chip_num << DNL_CHIP_SHIFT;
+	map_ctl |= DNL_MAP_11_DATA_MASK;
+
+	ret =  dnl_map_read(priv, map_ctl);
+	return ret;
+}
+
+static u8 dnl_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+
+	nand = mtd->priv;
+	priv = nand->priv;
+
+	if (priv->buf_mode != E_BUFMODE_MAP11) {
+		printk(KERN_ERR PFX "read_byte() when not in MAP11 mode is "
+		       "not supported.\n");
+		return 0xff;
+	}
+
+	return dnl_read_map11_byte(priv);
+}
+
+/*
+ * map11 read_buf: all accesses will generate a data read on the NAND
+ * bus.
+ */
+static void dnl_read_map11_buf(struct denali_nand_priv *priv,
+			       uint8_t *buf, int len)
+{
+	int i;
+	u32 map_ctl;
+
+	map_ctl = DNL_MAP_11_MASK;
+	map_ctl |= priv->chip_num << DNL_CHIP_SHIFT;
+	map_ctl |= DNL_MAP_11_DATA_MASK;
+
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+
+	for (i = 0; i < len; ++i)
+		buf[i] = dnl_mem_readl(priv, DNL_MAP_DATA_REG);
+}
+
+static void dnl_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+
+	nand = mtd->priv;
+	priv = nand->priv;
+
+	dnl_read_map11_buf(priv, buf, len);
+}
+
+/*
+ * enable/disable DMA helpers. DMA MUST be enabled before issuing the
+ * MAP10 four command sequence.
+ */
+static void dnl_enable_dma(struct denali_nand_priv *priv)
+{
+	dnl_reg_writel(priv, 1, DNL_DMA_ENABLE);
+	dnl_reg_readl(priv, DNL_DMA_ENABLE);
+}
+
+static void dnl_disable_dma(struct denali_nand_priv *priv)
+{
+	dnl_reg_writel(priv, 0, DNL_DMA_ENABLE);
+	dnl_reg_readl(priv, DNL_DMA_ENABLE);
+}
+
+/*
+ * used before and after reading/writing OOB.
+ */
+static void dnl_set_transfer_mode(struct denali_nand_priv *priv,
+				  int page, int mode)
+{
+	u32 map_ctl;
+	u32 data;
+
+	map_ctl = DNL_MAP_10_MASK;
+	map_ctl |= (priv->chip_num << DNL_CHIP_SHIFT);
+	map_ctl |= page;
+	data = mode;
+
+	dnl_map_write(priv, data, map_ctl);
+}
+
+static void dnl_clear_all_interrupts(struct denali_nand_priv *priv)
+{
+	u32 reg_offset;
+
+	reg_offset = DNL_0_INTR_STATUS_REG + (priv->chip_num * 0x14) * 4;
+	dnl_reg_writel(priv, 0xffff, reg_offset);
+}
+
+/*
+ * configure a DMA access using the mapped dma buffer in priv. this is
+ * done by issuing the 4 command sequence described in the
+ * documentation, chapter7, page 52.
+ */
+static void dnl_setup_dma(struct denali_nand_priv *priv,
+			  u32 page_addr, int access_mode)
+{
+	uint32_t map_ctl;
+	uint32_t data;
+	uint16_t addr_hi;
+	uint16_t addr_lo;
+
+	addr_hi = ((u32)priv->read_buf_dma >> 16) & 0xffff;
+	addr_lo = (u32)priv->read_buf_dma & 0xffff;
+
+	map_ctl = DNL_MAP_10_MASK | (priv->chip_num << DNL_CHIP_SHIFT);
+
+	/*
+	 * first step, transmit page_addr, select between program or
+	 * read..
+	 */
+	if (access_mode == DNL_E_DMA_PROGRAM)
+		data = DNL_MAP10_DMA_WRITE_PAGE;
+	else
+		data = DNL_MAP10_DMA_READ_PAGE;
+	dnl_map_write(priv, data, map_ctl | page_addr);
+
+	/*
+	 * second step, transmit addr_hi
+	 */
+	dnl_map_write(priv, DNL_MAP10_DMA_SET_ADDR_HI,
+		      map_ctl | (addr_hi << 8));
+
+	/*
+	 * third step, transmit addr_lo
+	 */
+	dnl_map_write(priv, DNL_MAP10_DMA_SET_ADDR_LO,
+		      map_ctl | (addr_lo << 8));
+
+	/*
+	 * fourth step, raise interrupt when complete, 64byte burst.
+	 */
+	dnl_map_write(priv, DNL_MAP10_DMA_SET_PARAMS,
+		      map_ctl | DNL_DMA_PARAM_GEN_INT | DNL_DMA_BURST_64);
+}
+
+/*
+ * wait for specific interrupt flag to be set by hardware. wait at
+ * most for 2 seconds for this to happen or timeout.
+ *
+ * more than one bit can be set in the status_mask (for instance to
+ * watch program_complete and program_failed interrupt events). the
+ * status that caused this function to return is set in *res_status
+ * for the caller layer to sort out.
+ */
+static int dnl_spin_for_mask(struct denali_nand_priv *priv,
+			     u32 status_mask, u32 *res_status)
+{
+	u32 count;
+	u32 status;
+	u32 reg_offset;
+
+	/*
+	 * select the status register of the chip we want to spin on.
+	 */
+	reg_offset = DNL_0_INTR_STATUS_REG + (priv->chip_num * 0x14) * 4;
+
+	/*
+	 * wait, use a two second timeout, should yield a confortable
+	 * margin for any expected irq bit to be set.
+	 */
+	count = 200000;
+	while (count) {
+		status = dnl_reg_readl(priv, reg_offset);
+		if (status & status_mask) {
+			dnl_reg_writel(priv, status_mask, reg_offset);
+			*res_status = status;
+			return 0;
+		}
+		udelay(10);
+		--count;
+	}
+
+	printk(KERN_ERR PFX "timedout waiting for %08x: status %08x\n",
+	       status_mask, status);
+	return -ETIMEDOUT;
+}
+
+/*
+ * read a page using DMA.
+ */
+static int dnl_read_page_raw(struct mtd_info *mtd, struct nand_chip *nand,
+			     uint8_t *buf, int page)
+{
+	struct denali_nand_priv *priv = nand->priv;
+	u32 status;
+
+	dma_sync_single_for_device(&priv->dev->dev, priv->read_buf_dma,
+				   priv->read_buf_size, DMA_FROM_DEVICE);
+
+	dnl_enable_dma(priv);
+	dnl_setup_dma(priv, page, DNL_E_DMA_READ);
+
+	if (dnl_spin_for_mask(priv,
+			      DNL_INT_DMA_DATA_CMD_COMPLETE |
+			      DNL_INT_BAD_CMD_SEQ,
+			      &status) < 0) {
+		printk(KERN_ERR PFX "timedout waiting for DMA.\n");
+		return -ETIMEDOUT;
+	}
+
+	/*
+	 * disable and sync dma before considering status.
+	 */
+	dnl_disable_dma(priv);
+	dma_sync_single_for_cpu(&priv->dev->dev, priv->read_buf_dma,
+				priv->read_buf_size, DMA_FROM_DEVICE);
+
+	if (status & DNL_INT_BAD_CMD_SEQ) {
+		printk(KERN_ERR PFX "controller reported a bad command "
+		       "sequence.\n");
+		return -EIO;
+	}
+
+	memcpy(buf, priv->read_buf, mtd->writesize);
+	memcpy(nand->oob_poi, priv->read_buf + mtd->writesize, mtd->oobsize);
+
+	return 0;
+}
+
+/*
+ * access oob zone using MAP01 command and no DMA.
+ */
+static int dnl_read_oob(struct mtd_info *mtd, struct nand_chip *nand,
+			int page, int sndcmd)
+{
+	struct denali_nand_priv *priv = nand->priv;
+	u32 map_ctl;
+	u32 pos;
+	u32 *buf32;
+	u32 status;
+
+	dnl_clear_all_interrupts(priv);
+
+	/*
+	 * tell the hardware to read only spare in MAP01 mode.
+	 */
+	dnl_set_transfer_mode(priv, page, DNL_XFER_SPARE_ONLY);
+
+	/*
+	 * select the page to read oob from.
+	 */
+	map_ctl = DNL_MAP_01_MASK | page;
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+
+	/*
+	 * read oob.
+	 */
+	buf32 = (u32*)nand->oob_poi;
+	for (pos = 0; pos < mtd->oobsize; pos += 4)
+		buf32[pos / 4] = dnl_mem_readl(priv, DNL_MAP_DATA_REG);
+
+	/*
+	 * ok, we already have the data in nand->oob_poi, so I guess
+	 * this is in the original driver just to be sure that we have
+	 * not read crap from the controller.
+	 */
+	if (dnl_spin_for_mask(priv, DNL_INT_LOAD_COMPLETE, &status) < 0) {
+		printk("timeouted waiting for oob load completion.\n");
+		return -ETIMEDOUT;
+	}
+
+	/*
+	 * switch back to MAIN + SPARE mode.
+	 */
+	dnl_set_transfer_mode(priv, page, DNL_XFER_SPARE_AND_MAIN);
+
+	return 0;
+}
+
+/*
+ * write oob zone of given page. use MAP01 command, no DMA.
+ */
+static int dnl_write_oob(struct mtd_info *mtd, struct nand_chip *nand, int page)
+{
+	struct denali_nand_priv *priv = nand->priv;
+	u32 map_ctl;
+	u32 *buf32;
+	u32 pos;
+	u32 status;
+
+	dnl_clear_all_interrupts(priv);
+
+	/*
+	 * tell the hardware to read only spare in MAP01 mode.
+	 */
+	dnl_set_transfer_mode(priv, page, DNL_XFER_SPARE_ONLY);
+
+	/*
+	 * select the page to write oob from.
+	 */
+	map_ctl = DNL_MAP_01_MASK | page;
+	dnl_mem_writel(priv, map_ctl, DNL_MAP_CTL_REG);
+
+	/*
+	 * write the oob data to the controller.
+	 */
+	buf32 = (u32*)nand->oob_poi;
+	for (pos = 0; pos < mtd->oobsize; pos += 4)
+		dnl_mem_writel(priv, buf32[pos / 4], DNL_MAP_DATA_REG);
+
+	if (dnl_spin_for_mask(priv,
+			      DNL_INT_PROGRAM_COMPLETE |
+			      DNL_INT_PROGRAM_FAIL,
+			      &status) < 0) {
+		printk(KERN_ERR PFX "timeouted waiting for OOB program.\n");
+		return -ETIMEDOUT;
+	}
+
+
+	/*
+	 * switch back to MAIN + SPARE mode.
+	 */
+	dnl_set_transfer_mode(priv, page, DNL_XFER_SPARE_AND_MAIN);
+
+	if (status & DNL_INT_PROGRAM_FAIL) {
+		printk(KERN_ERR PFX "controller reported a bad OOB program.\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/*
+ * issue an erase command using MAP10 command and wait for command
+ * completion.
+ */
+static void dnl_erase_cmd(struct mtd_info *mtd, int page)
+{
+	struct nand_chip *nand = mtd->priv;
+	struct denali_nand_priv *priv = nand->priv;
+	u32 map_ctl;
+	u32 data;
+	u32 status;
+
+	dnl_clear_all_interrupts(priv);
+
+	map_ctl = DNL_MAP_10_MASK | page;
+	data = DNL_MAP10_ERASE_COMMAND;
+	dnl_map_write(priv, data, map_ctl);
+
+	if (dnl_spin_for_mask(priv,
+			      DNL_INT_ERASE_FAILED | DNL_INT_ERASE_COMPLETE,
+			      &status) < 0) {
+		printk(KERN_ERR PFX "timeouted waiting for erase on page "
+		       "%u.\n", page);
+		return ;
+	}
+
+	if (status & DNL_INT_ERASE_FAILED) {
+		printk(KERN_ERR PFX "controller reported erase failed on "
+		       "block %i\n", page);
+		return ;
+	}
+}
+
+/*
+ * start a page write, use DMA.
+ */
+static void dnl_write_page_raw(struct mtd_info *mtd, struct nand_chip *nand,
+			       const uint8_t *buf)
+{
+	struct denali_nand_priv *priv = nand->priv;
+	u32 status;
+
+	/*
+	 * build buffer for DMA with oob tightly following data.
+	 */
+	memcpy(priv->read_buf, buf, mtd->writesize);
+	memcpy(priv->read_buf + mtd->writesize, nand->oob_poi, mtd->oobsize);
+
+	dma_sync_single_for_device(&priv->dev->dev, priv->read_buf_dma,
+				   priv->read_buf_size, DMA_TO_DEVICE);
+
+	dnl_clear_all_interrupts(priv);
+	dnl_enable_dma(priv);
+	dnl_setup_dma(priv, priv->page, DNL_E_DMA_PROGRAM);
+
+	if (dnl_spin_for_mask(priv,
+			      DNL_INT_DMA_DATA_CMD_COMPLETE |
+			      DNL_INT_PROGRAM_FAIL |
+			      DNL_INT_BAD_CMD_SEQ,
+			      &status) < 0) {
+		printk(KERN_ERR PFX "timedout waiting for program completion "
+		       "on page %u\n", priv->page);
+		return ;
+	}
+
+	dnl_disable_dma(priv);
+	dma_sync_single_for_cpu(&priv->dev->dev, priv->read_buf_dma,
+				priv->read_buf_size, DMA_TO_DEVICE);
+
+	if (status & DNL_INT_PROGRAM_FAIL) {
+		printk(KERN_ERR PFX "controller reported a program failure "
+		       "on page %u\n", priv->page);
+		return ;
+	}
+
+	if (status & DNL_INT_BAD_CMD_SEQ) {
+		printk(KERN_ERR PFX "controller reported a bad command "
+		       "sequence.\n");
+		return ;
+	}
+}
+
+/*
+ * command control: a NAND bus access will be generated with this
+ * function (command, address, or data).
+ */
+static void dnl_cmd_ctrl(struct mtd_info *mtd, int command,
+			 unsigned int ctrl)
+{
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+	u32 map_ctl;
+
+	nand = mtd->priv;
+	priv = nand->priv;
+
+	map_ctl = DNL_MAP_11_MASK;
+	map_ctl |= priv->chip_num << DNL_CHIP_SHIFT;
+
+	if (command == NAND_CMD_NONE)
+		return ;
+
+	/*
+	 * depending on address, or command cycle, set map_ctl with the
+	 * correct bits.
+	 */
+	if (ctrl & NAND_CLE)
+		map_ctl |= DNL_MAP_11_CMD_MASK;
+	else if (ctrl & NAND_ALE)
+		map_ctl |= DNL_MAP_11_ADDR_MASK;
+	else
+		BUG();
+
+	dnl_map_write(priv, command & 0xff, map_ctl);
+}
+
+/*
+ * generate needed address cycles to output column and page to the NAND
+ * bus.
+ */
+static void dnl_shift_addresses(struct mtd_info *mtd,
+				int column, int page)
+{
+	struct nand_chip *nand;
+
+	nand = mtd->priv;
+
+	if (column != -1) {
+		nand->cmd_ctrl(mtd, column, NAND_ALE);
+		nand->cmd_ctrl(mtd, column >> 8, NAND_ALE);
+	}
+
+	if (page != -1) {
+		nand->cmd_ctrl(mtd, page, NAND_ALE);
+		nand->cmd_ctrl(mtd, page >> 8, NAND_ALE);
+		if (nand->chipsize > (128 << 20))
+			nand->cmd_ctrl(mtd, page >> 16, NAND_ALE);
+	}
+}
+
+/*
+ * our cmdfunc callback. this duplicates some code from the upper
+ * layer nand_command_lp() function. page READ (NAND_CMD_READ0
+ * commands) are issued using MAP01/MAP10 commands which are faster.
+ */
+static void dnl_cmdfunc(struct mtd_info *mtd, unsigned int command,
+			int column, int page_addr)
+{
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+
+	nand = mtd->priv;
+	priv = nand->priv;
+
+	switch (command) {
+	case NAND_CMD_RESET:
+		dnl_reset_bank(priv);
+		break;
+
+	case NAND_CMD_READID:
+		/*
+		 * read id page. set bufmode to map11 so that upper
+		 * layer can read the result using the correct method.
+		 */
+		nand->cmd_ctrl(mtd, NAND_CMD_READID, NAND_CLE);
+		dnl_shift_addresses(mtd, column, page_addr);
+		udelay(35);
+		priv->buf_mode = E_BUFMODE_MAP11;
+		break;
+
+	case NAND_CMD_READ_ONFI_PARAMS:
+		nand->cmd_ctrl(mtd, NAND_CMD_READ_ONFI_PARAMS, NAND_CLE);
+		dnl_shift_addresses(mtd, column, page_addr);
+		udelay(35);
+		break;
+
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_READ0:
+		priv->page = page_addr;
+		priv->page = page_addr;
+		break;
+
+	case NAND_CMD_STATUS:
+		/*
+		 * issue status register read command, and tell
+		 * read_buf/read_byte to use MAP11.
+		 */
+		nand->cmd_ctrl(mtd, NAND_CMD_STATUS, NAND_CLE);
+		priv->buf_mode = E_BUFMODE_MAP11;
+		break;
+
+
+	case NAND_CMD_PAGEPROG:
+		break;
+
+	default:
+		printk("warning: unhandled command %x (please report)\n",
+		       command);
+		return ;
+	}
+
+	ndelay(100);
+}
+
+static inline u32 ceil_div(u32 x, u32 y)
+{
+	if (x % y)
+		return x / y + 1;
+	else
+		return x / y;
+}
+
+#define CLK_X		5
+#define CLK_MULTI	4
+
+/*
+ * calculate ONFI timings for given onfi mode. copied from spectra
+ * driver, should yield the same timings.
+ */
+static void dnl_calc_onfi_timings(struct denali_nand_priv *priv,
+			       int onfi_mode)
+{
+	static const u8 Trea[6]	 = { 40, 30, 25, 20, 20, 16 };
+	static const u8 Trp[6]	 = { 50, 25, 17, 15, 12, 10 };
+	static const u8 Treh[6]	 = { 30, 15, 15, 10, 10, 7 };
+	static const u8 Trc[6]	 = { 100, 50, 35, 30, 25, 20 };
+	static const u8 Trhoh[6] = { 0, 15, 15, 15, 15, 15 };
+	static const u8 Trloh[6] = { 0, 0, 0, 0, 5, 5 };
+	static const u8 Tcea[6]	 = { 100, 45, 30, 25, 25, 25 };
+	static const u8 Tadl[6]	 = { 200, 100, 100, 100, 70, 70 };
+	static const u8 Trhw[6]	 = { 200, 100, 100, 100, 100, 100 };
+	static const u8 Trhz[6]	 = { 200, 100, 100, 100, 100, 100 };
+	static const u8 Twhr[6]	 = { 120, 80, 80, 60, 60, 60 };
+	static const u8 Tcs[6]	 = { 70, 35, 25, 25, 20, 15 };
+
+	u16 en_lo, en_hi;
+	u16 acc_clks;
+	u16 dv_window = 0;
+	u16 addr_2_data;
+	u16 re_2_we;
+	u16 re_2_re;
+	u16 we_2_re;
+	u16 cs_cnt;
+
+	en_lo = ceil_div(Trp[onfi_mode], CLK_X);
+	en_hi = ceil_div(Treh[onfi_mode], CLK_X);
+
+	if (en_hi * CLK_X < Treh[onfi_mode] + 2)
+		++en_hi;
+	if (CLK_X * (en_lo + en_hi) < Trc[onfi_mode] + 2)
+		en_lo += ceil_div(Trc[onfi_mode] - (en_lo + en_hi) * CLK_X,
+				  CLK_X);
+
+	if (en_lo + en_hi < CLK_MULTI)
+		en_lo += CLK_MULTI - en_lo - en_hi;
+
+	while (1) {
+		u16 data_invalid_rhoh, data_invalid_rloh, data_invalid;
+
+		data_invalid_rhoh = en_lo * CLK_X + Trhoh[onfi_mode];
+		data_invalid_rloh = (en_lo + en_hi) * CLK_X + Trloh[onfi_mode];
+		data_invalid = min(data_invalid_rhoh, data_invalid_rloh);
+
+		dv_window = data_invalid - Trea[onfi_mode];
+		if (dv_window >= 8)
+			break;
+		++en_lo;
+	}
+
+	acc_clks = ceil_div(Trea[onfi_mode], CLK_X);
+	while (acc_clks * CLK_X - Trea[onfi_mode] < 3)
+		++acc_clks;
+
+	addr_2_data = ceil_div(Tadl[onfi_mode], CLK_X);
+	re_2_we = ceil_div(Trhw[onfi_mode], CLK_X);
+	re_2_re = ceil_div(Trhz[onfi_mode], CLK_X);
+	we_2_re = ceil_div(Twhr[onfi_mode], CLK_X);
+	cs_cnt = ceil_div(Tcs[onfi_mode] - Trp[onfi_mode], CLK_X);
+	if (cs_cnt == 0)
+		cs_cnt = 1;
+
+	if (Tcea[onfi_mode])
+		while (cs_cnt * CLK_X + Trea[onfi_mode] < Tcea[onfi_mode])
+			cs_cnt++;
+
+	/*
+	 * apply calculated timings.
+	 */
+	dnl_reg_writel(priv, acc_clks, DNL_ACC_CLKS_REG);
+	dnl_reg_writel(priv, re_2_we, DNL_RE_2_WE_REG);
+	dnl_reg_writel(priv, re_2_re, DNL_RE_2_RE_REG);
+	dnl_reg_writel(priv, we_2_re, DNL_WE_2_RE_REG);
+	dnl_reg_writel(priv, addr_2_data, DNL_ADDR_2_DATA_REG);
+	dnl_reg_writel(priv, en_lo, DNL_EN_LO_CNT_REG);
+	dnl_reg_writel(priv, en_hi, DNL_EN_HI_CNT_REG);
+	dnl_reg_writel(priv, cs_cnt, DNL_CS_SETUP_CNT_REG);
+}
+
+static void dnl_set_slowest_timings(struct denali_nand_priv *priv)
+{
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+
+	mtd = priv->mtd;
+	nand = mtd->priv;
+
+	priv->buf_mode = E_BUFMODE_MAP11;
+
+	/*
+	 * use slowest and safest timing possible to read ONFI
+	 * parameter page. we will stay in this mode if we cannot read
+	 * the ONFI parameter page.
+	 */
+	dnl_calc_onfi_timings(priv, 0);
+}
+
+static int dnl_configure_timings(struct denali_nand_priv *priv)
+{
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+	u16 timing_modes;
+	int mode;
+
+	mtd = priv->mtd;
+	nand = mtd->priv;
+
+	timing_modes = le16_to_cpu(nand->onfi_params.async_timing_mode);
+
+	/*
+	 * walk bitfield storing supported ONFI timings, use the
+	 * highest available mode. start from fastest possible mode
+	 * (mode 5) and go down until we found one mode that is
+	 * supported.
+	 */
+	for (mode = max_mode; mode > 0; --mode) {
+		if (timing_modes & (1 << mode))
+			break;
+	}
+	printk(KERN_INFO PFX "using ONFI timing mode %i\n", mode);
+	dnl_calc_onfi_timings(priv, mode);
+
+	return 0;
+}
+
+static int dnl_reset_bank(struct denali_nand_priv *priv)
+{
+	u32 reg;
+	u32 status;
+
+	dnl_clear_all_interrupts(priv);
+
+	/*
+	 * reset controller.
+	 */
+	reg = dnl_reg_readl(priv, DNL_DEVICE_RESET_REG);
+	reg |= (1 << priv->chip_num);
+	dnl_reg_writel(priv, reg, DNL_DEVICE_RESET_REG);
+
+	/*
+	 * wait for reset completion.
+	 */
+	if (dnl_spin_for_mask(priv, DNL_INT_RESET_DONE | DNL_INT_WDOG_TIMEOUT,
+			      &status) < 0) {
+		printk("timeouted waiting for device reset.\n");
+		return -ETIMEDOUT;
+	}
+
+	if (status & DNL_INT_WDOG_TIMEOUT) {
+		printk("internal hardware watchdog triggered.\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int denali_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int err;
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+	struct denali_nand_priv *priv;
+	struct mtd_partition *parts;
+	int nr_parts;
+
+	err = pci_enable_device(dev);
+	if (err) {
+		printk(KERN_ERR PFX "unable to enable pci device: %i.\n", err);
+		return err;
+	}
+
+	priv = kzalloc(sizeof (*priv), GFP_KERNEL);
+	if (!priv) {
+		err = -ENOMEM;
+		goto out_disable_device;
+	}
+	dev_set_drvdata(&dev->dev, priv);
+	priv->dev = dev;
+
+	/*
+	 * mem zone is on the first pci resource, map xx access is done here.
+	 */
+	priv->mem_phys = pci_resource_start(dev, 0);
+	priv->mem_size = pci_resource_end(dev, 0) - priv->mem_phys + 1;
+
+	/*
+	 * registers are on the second pci resource.
+	 */
+	priv->regs_phys = pci_resource_start(dev, 1);
+	priv->regs_size = pci_resource_end(dev, 1) - priv->regs_phys + 1;
+
+	priv->mem = ioremap(priv->mem_phys, priv->mem_size);
+	if (!priv->mem) {
+		err = -ENOMEM;
+		goto out_free_priv;
+	}
+
+	priv->regs = ioremap(priv->regs_phys, priv->regs_size);
+	if (!priv->regs) {
+		err = -ENOMEM;
+		goto out_unmap_mem;
+	}
+
+	mtd = kzalloc(sizeof (*mtd), GFP_KERNEL);
+	if (!mtd) {
+		err = -ENOMEM;
+		goto out_unmap_regs;
+	}
+	priv->mtd = mtd;
+
+	nand = kzalloc(sizeof (*nand), GFP_KERNEL);
+	if (!nand) {
+		err = -ENOMEM;
+		goto out_free_mtd;
+	}
+
+	mtd->priv = nand;
+	mtd->owner = THIS_MODULE;
+
+	/*
+	 * the chip may support it but the controller makes it a pain
+	 * to handle.
+	 */
+	nand->options = NAND_NO_RNDOUT;
+
+	nand->priv = priv;
+	nand->read_byte = dnl_read_byte;
+	nand->write_buf = dnl_write_buf;
+	nand->read_buf = dnl_read_buf;
+	nand->cmd_ctrl = dnl_cmd_ctrl;
+
+	if (map_mode == 11) {
+		/*
+	 	* always use MAP11 accesses, will be slower, but may be
+	 	* usefull for debug.
+	 	*/
+		printk(KERN_INFO PFX "using MAP11 for ALL accesses (slow).\n");
+		priv->buf_mode = E_BUFMODE_MAP11;
+		nand->ecc.mode = NAND_ECC_SOFT;
+		nand->chip_delay = 35;
+
+	} else {
+		/*
+	 	 * use our provided cmdfunc, with the ->ecc callbacks
+	 	 * along, things will go much more faster.
+	 	 */
+		nand->cmdfunc = dnl_cmdfunc;
+
+		nand->ecc.mode = NAND_ECC_SOFT;
+		nand->ecc.read_page_raw = dnl_read_page_raw;
+		nand->ecc.write_page_raw = dnl_write_page_raw;
+		nand->ecc.read_oob = dnl_read_oob;
+		nand->ecc.write_oob = dnl_write_oob;
+		nand->erase_cmd = dnl_erase_cmd;
+	}
+
+	dnl_clear_all_interrupts(priv);
+	dnl_reset_bank(priv);
+	dnl_set_slowest_timings(priv);
+
+	/*
+	 * enable prefetch on page read, to speed up things.
+	 */
+	dnl_reg_writel(priv, 1, DNL_PREFETCH_MODE);
+
+	/*
+	 * disable ECC verification/generation on page read/write.
+	 */
+	dnl_reg_writel(priv, 0, DNL_ECC_ENABLE_REG);
+
+	/*
+	 * allocate read buffer: size should be main size + oob
+	 * size. we do not have the mtd fields populated yet with
+	 * these values, but controller registers do already have them
+	 * populated.
+	 */
+	priv->read_buf_size = dnl_reg_readl(priv, DNL_MAIN_SIZE_REG) +
+		dnl_reg_readl(priv, DNL_SPARE_SIZE_REG);
+	priv->read_buf = kmalloc(2 * 4096, GFP_KERNEL);
+	if (!priv->read_buf) {
+		goto out_free_nand;
+		err = -ENOMEM;
+	}
+
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(32)) < 0) {
+		printk(KERN_ERR PFX "32bit dma not supported.\n");
+		goto out_free_read_buf;
+	}
+	priv->read_buf_dma = dma_map_single(&dev->dev, priv->read_buf,
+					    priv->read_buf_size,
+					    DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(&dev->dev, priv->read_buf_dma)) {
+		printk(PFX KERN_ERR "unable to map read_buf for dma.\n");
+		goto out_free_read_buf;
+	}
+
+	/*
+	 * FIXME: 4 chips can be supported
+	 */
+	err = nand_scan_ident(mtd, 1);
+	if (err < 0)
+		goto out_pci_unmap_single;
+
+	if (map_mode != 11)
+		/*
+		 * FIXME: nand_scan_ident does not preserve our
+		 * erase_cmd.
+		 */
+		nand->erase_cmd = dnl_erase_cmd;
+
+
+
+	err = nand_scan_tail(mtd);
+	if (err < 0)
+		goto out_pci_unmap_single;
+
+
+	if (nand->options & NAND_ONFI)
+		dnl_configure_timings(priv);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts = parse_mtd_partitions(mtd, parts_parsers, &parts, 0);
+	if (nr_parts > 0)
+		add_mtd_partitions(mtd, parts, nr_parts);
+	else {
+		printk(KERN_WARNING PFX "unable to parse MTD partitions.\n");
+		err = nr_parts;
+		goto out_pci_unmap_single;
+	}
+#else
+	err = add_mtd_device(mtd);
+	if (err)
+		goto out_pci_unmap_single;
+#endif
+
+	return 0;
+
+out_pci_unmap_single:
+	pci_unmap_single(dev, priv->read_buf_dma, priv->read_buf_size,
+			 PCI_DMA_BIDIRECTIONAL);
+out_free_read_buf:
+	kfree(priv->read_buf);
+out_free_nand:
+	kfree(nand);
+out_free_mtd:
+	kfree(mtd);
+out_unmap_regs:
+	iounmap(priv->regs);
+out_unmap_mem:
+	iounmap(priv->mem);
+out_free_priv:
+	kfree(priv);
+out_disable_device:
+	pci_disable_device(dev);
+	return err;
+}
+
+static void denali_pci_remove(struct pci_dev *dev)
+{
+	struct denali_nand_priv *priv;
+
+	priv = dev_get_drvdata(&dev->dev);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	del_mtd_partitions(priv->mtd);
+#else
+	del_mtd_device(priv->mtd);
+#endif
+
+	pci_unmap_single(dev, priv->read_buf_dma, priv->read_buf_size,
+			 PCI_DMA_BIDIRECTIONAL);
+	kfree(priv->read_buf);
+	kfree(priv->mtd->priv);
+	kfree(priv->mtd);
+
+	iounmap(priv->regs);
+	iounmap(priv->mem);
+
+	kfree(priv);
+	pci_disable_device(dev);
+}
+
+const struct pci_device_id denali_pci_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0701) },
+	{ 0, },
+};
+
+struct pci_driver	denali_nand_pci_driver =
+{
+	.name		= "denali_nand",
+	.id_table	= denali_pci_table,
+	.probe		= denali_pci_probe,
+	.remove		= denali_pci_remove,
+};
+
+static int __init denali_nand_init(void)
+{
+	int err;
+
+	err = pci_register_driver(&denali_nand_pci_driver);
+	if (err) {
+		printk(KERN_ERR PFX "pci_register_driver failed: %i.\n", err);
+		return err;
+	}
+	return 0;
+}
+
+static void __exit denali_nand_exit(void)
+{
+	pci_unregister_driver(&denali_nand_pci_driver);
+}
+
+module_init(denali_nand_init);
+module_exit(denali_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Schichan <nschichan@freebox.fr>");
+MODULE_DESCRIPTION("Denali NAND driver");
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/mtd/nand/denali_nand.h	2011-01-06 02:17:51.972146751 +0100
@@ -0,0 +1,165 @@
+
+#ifndef __DENALI_NAND_H
+# define __DENALI_NAND_H
+
+struct mtd_info;
+
+enum
+{
+	E_BUFMODE_MAP01,
+	E_BUFMODE_MAP11,
+};
+
+struct denali_nand_priv
+{
+	int		chip_num;
+	unsigned long	regs_phys;
+	unsigned long	regs_size;
+
+	unsigned long	mem_phys;
+	unsigned long	mem_size;
+
+	void __iomem	*regs;
+	void __iomem	*mem;
+
+	u8		*read_buf;
+	int		read_buf_size;
+	int		read_buf_offset;
+	int		page;
+
+
+	int		buf_mode;
+
+	dma_addr_t	read_buf_dma;
+
+	struct pci_dev *dev;
+	struct mtd_info	*mtd;
+};
+
+#define DNL_DEVICE_RESET_REG		0x0
+
+#define DNL_XFER_SPARE_REG		(0x4 * 4)
+
+#define DNL_CE_REG			(0x34 * 4)
+#define  DNL_CE_DISABLE			(1 << 0)
+
+#define DNL_RB_PIN_ENABLED_REG		(0x18 * 4)
+# define DNL_RB_PIN_B0_EN		(1 << 0)
+# define DNL_RB_PIN_B1_EN		(1 << 1)
+# define DNL_RB_PIN_B2_EN		(1 << 2)
+# define DNL_RB_PIN_B3_EN		(1 << 3)
+
+#define DNL_PREFETCH_MODE		(0x30 * 4)
+#define DNL_ECC_ENABLE_REG		(0x38 * 4)
+
+#define DNL_INT_ENABLE_REG		(0x3c * 4)
+# define DNL_INT_ENABLE			(1 << 0)
+
+#define DNL_MAIN_SIZE_REG		(0x5c * 4)
+#define DNL_SPARE_SIZE_REG		(0x60 * 4)
+
+#define DNL_0_INTR_STATUS_REG		(0x104 * 4)
+#define DNL_0_INTR_EN_REG		(0x108 * 4)
+#define DNL_0_PAGE_COUNT_REG		(0x10c * 4)
+#define DNL_0_ERR_ADDR_REG		(0x110 * 4)
+#define DNL_0_ERR_BLOCK_REG		(0x114 * 4)
+
+#define DNL_1_INTR_STATUS_REG		(0x118 * 4)
+#define DNL_1_INTR_EN_REG		(0x11c * 4)
+#define DNL_1_PAGE_COUNT_REG		(0x120 * 4)
+#define DNL_1_ERR_ADDR_REG		(0x124 * 4)
+#define DNL_1_ERR_BLOCK_REG		(0x128 * 4)
+
+#define DNL_2_INTR_STATUS_REG		(0x12c * 4)
+#define DNL_2_INTR_EN_REG		(0x130 * 4)
+#define DNL_2_PAGE_COUNT_REG		(0x134 * 4)
+#define DNL_2_ERR_ADDR_REG		(0x138 * 4)
+#define DNL_2_ERR_BLOCK_REG		(0x13c * 4)
+
+#define DNL_3_INTR_STATUS_REG		(0x140 * 4)
+#define DNL_3_INTR_EN_REG		(0x144 * 4)
+#define DNL_3_PAGE_COUNT_REG		(0x148 * 4)
+#define DNL_3_ERR_ADDR_REG		(0x14c * 4)
+#define DNL_3_ERR_BLOCK_REG		(0x150 * 4)
+
+/*
+ * interrupt cause bits valid for all 4 controllers.
+ */
+#define DNL_INT_DMA_DATA_CMD_COMPLETE	(1 << 2)
+#define DNL_INT_WDOG_TIMEOUT		(1 << 3)
+#define DNL_INT_PROGRAM_FAIL		(1 << 4)
+#define DNL_INT_ERASE_FAILED		(1 << 5)
+#define DNL_INT_LOAD_COMPLETE		(1 << 6)
+#define DNL_INT_PROGRAM_COMPLETE	(1 << 7)
+#define DNL_INT_ERASE_COMPLETE		(1 << 8)
+#define DNL_INT_BAD_CMD_SEQ		(1 << 11)
+#define DNL_INT_RESET_DONE		(1 << 13)
+
+
+#define DNL_SKIP_BYTE_REG		(0x8c * 4)
+#define DNL_SPACE_AREA_MARKER_REG	(0x90 * 4)
+
+#define DNL_MANUFACTURER_REG		(0xc0 * 4)
+
+#define DNL_PAGE_SIZE			(0xd4 * 4)
+#define DNL_SPARE_SIZE			(0xd8 * 4)
+
+/*
+ * timing configuration registers
+ */
+#define DNL_WE_2_RE_REG			(0x40 * 4)
+#define DNL_ADDR_2_DATA_REG		(0x44 * 4)
+#define DNL_RE_2_WE_REG			(0x48 * 4)
+#define DNL_ACC_CLKS_REG		(0x4c * 4)
+
+#define DNL_EN_LO_CNT_REG		(0x7c * 4)
+#define DNL_EN_HI_CNT_REG		(0x80 * 4)
+#define DNL_CS_SETUP_CNT_REG		(0x88 * 4)
+#define DNL_RE_2_RE_REG			(0xa4 * 4)
+
+#define DNL_XFER_MODE			(0x100 * 4)
+
+#define DNL_DMA_ENABLE			(0x1c0 * 4)
+
+/*
+ * map xx indirect read/write accessors
+ */
+#define DNL_MAP_01_MASK		0x04000000
+#define DNL_MAP_10_MASK		0x08000000
+#define DNL_MAP_11_MASK		0x0c000000
+
+#define DNL_CHIP_MASK		0x03000000
+#define DNL_CHIP_SHIFT		(24)
+#define DNL_MAP_11_CMD_MASK	(0x0)
+#define DNL_MAP_11_ADDR_MASK	(0x1)
+#define DNL_MAP_11_DATA_MASK	(0x2)
+
+#define DNL_MAP_CTL_REG		0x00
+#define DNL_MAP_DATA_REG	0x10
+
+#define DNL_XFER_SPARE_ONLY		0x41
+#define DNL_XFER_MAIN_ONLY		0x42
+#define DNL_XFER_SPARE_AND_MAIN		0x43
+
+#define DNL_MAP10_READAHEAD_ONCE	0x2001
+
+enum {
+	DNL_E_DMA_READ,
+	DNL_E_DMA_PROGRAM,
+};
+
+#define DNL_MAP10_ERASE_COMMAND		0x1
+
+/*
+ * DMA command sequence.
+ */
+#define DNL_MAP10_DMA_READ_PAGE		0x2001
+#define DNL_MAP10_DMA_WRITE_PAGE	0x2101
+#define DNL_MAP10_DMA_SET_ADDR_HI	0x2200
+#define DNL_MAP10_DMA_SET_ADDR_LO	0x2300
+#define DNL_MAP10_DMA_SET_PARAMS	0x2400
+
+#define DNL_DMA_PARAM_GEN_INT		(1 << 16)
+#define DNL_DMA_BURST_64		(0x40 << 8)
+
+#endif /* !__DENALI_NAND_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/net/e1000/gbe_mac_access.h	2011-08-29 16:28:19.471729225 +0200
@@ -0,0 +1,154 @@
+/*
+GPL LICENSE SUMMARY
+
+Copyright(c) 2005-2009 Intel Corporation. All rights reserved.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of version 2 of the GNU General Public License as
+published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+General Public License for more details.
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+The full GNU General Public License is included in this distribution
+in the file called LICENSE.GPL.
+
+Contact Information:
+Intel Corporation
+2200 Mission College Blvd.
+Santa Clara, CA 97052
+*/
+
+/* gbe_mac_access.h
+ * Structures, enums, and macros for the MAC
+ */
+#ifndef _GBE_MAC_ACCESS_H_
+#define _GBE_MAC_ACCESS_H_
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/miscdevice.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <linux/time.h>
+
+extern	void __iomem * gbe_config_base_virt;
+#define GBE_CONFIG_BASE_VIRT  	gbe_config_base_virt
+
+#define CONFIG_RAM_BASE		0x60000 
+#define GBE_CONFIG_OFFSET	0x0
+#define GBE_CONFIG_RAM_BASE		((unsigned int)(CONFIG_RAM_BASE + GBE_CONFIG_OFFSET))
+#define GBE_CONFIG_DATA_LENGTH	0x200 
+
+#define GBE_CONFIG_FLASH_READ(base,offset,count,data)		gbe_config_read_words(base,offset,count,data)
+#define GBE_CONFIG_FLASH_WRITE(base,offset,count,data)		gbe_config_write_words(base,offset,count,data)
+
+#define GBE_PERROR(fmt, args...) printk("[ERROR] %s: " fmt, __FUNCTION__ , ## args)
+  
+extern int (* gbe_config_media_read)(void  __iomem * config_ram_base_t, int length);
+extern int (* gbe_config_media_write)(void  __iomem * config_ram_base_t, int length);
+
+/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
+/*!  \brief Write GbE configuration data from RAM
+ *
+ *   Write configuration data from RAM 
+ *
+ *     @param[in] ram_base_t         the ram base address used to store the configuration data
+ *     @param[in] offset_t           offset address in the configuration data. 
+ *     @param[in] count              total numbers of word to be read  
+ *     @param[out] buf_t             buffer of the  data to be written
+ *     @return  logical true if successful
+ *              logical false if failed for some reason.
+ */
+
+static int inline gbe_config_write_words(void  __iomem * ram_base_t, unsigned short offset_t, unsigned short count, unsigned short *buf_t)
+{
+	volatile unsigned short * dst;
+	unsigned int * config_ram_base_t ;
+	int length = GBE_CONFIG_DATA_LENGTH; 
+
+	dst = (volatile unsigned short *)(ram_base_t + (unsigned int)offset_t);
+	*dst = *buf_t;
+
+	if(gbe_config_media_write){
+        config_ram_base_t = gbe_config_base_virt;	
+		gbe_config_media_write(config_ram_base_t, length);		
+	}
+	return 0;
+}
+
+/*  write a word  */
+static int inline read_one_word(void  __iomem * ram_base_t, unsigned short offset, unsigned short *buf)
+{
+    int ret = 0;
+    volatile unsigned int ramBase;
+	volatile unsigned short * src;
+
+	if(!buf){
+		GBE_PERROR("Invalid buffer address!\n");
+		return -EINVAL;
+	}
+	
+	if( offset > 0x3f)
+	{
+		GBE_PERROR("invalid offset number: %x\n", offset);
+		return -EINVAL;
+	}
+
+	// translate the address from eeporm address (in word) into the flash address (in byte);
+	offset<<=1;
+
+	ramBase = (volatile unsigned int)ram_base_t;
+	src = (volatile unsigned short *)(ramBase + (unsigned int)offset);
+	*buf = *src;
+    
+	return ret;
+}
+/* = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
+/*!  \brief Read GbE configuration data from RAM
+ *
+ *   Read  configuration data from RAM 
+ *
+ *     @param[in] ram_base_t           the ram base address used to store the configuration data
+ *     @param[in] offset_t           offset address in the configuration data. 
+ *     @param[in] count              totol numbers of word to be read  
+ *     @param[out] buf_t             buffer of returned data   
+ *     @return  logical true if successful
+ *              logical false if failed for some reason.
+ */
+
+static int inline gbe_config_read_words(void  __iomem * ram_base_t, unsigned short offset_t, unsigned short count, unsigned short *buf_t)
+{
+	int ret = 0 ;
+	unsigned short i, offset, * buf;
+
+	if( (count + offset_t - 1 ) > 0x3f){
+		printk("Invalid words number, eeprom space limited to 0x3f word size\n");
+	}
+
+	offset = offset_t;
+	buf = buf_t;	
+
+	for(i=0;i<count;i++){
+		read_one_word(ram_base_t, offset, buf);
+		offset ++;
+		buf ++;
+	}
+	
+	return ret;
+}
+#endif //_GBE_MAC_ACCESS_H_
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/drivers/pci/pci-intelce_pm.c	2011-08-29 16:28:20.181735534 +0200
@@ -0,0 +1,109 @@
+/*
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2010 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <linux/pci-intelce_pm.h>
+#include "pci.h"
+
+static intel_pm_pci_ops_t external_pm_ops;
+
+static struct semaphore icepm_lock;
+
+#define CALL_EXTERNAL(rc, x, args...)                     \
+down(&icepm_lock);                                        \
+if (external_pm_ops.x) { rc = external_pm_ops.x(args); }  \
+up(&icepm_lock);
+
+static pci_power_t intel_pm_pci_choose_state(struct pci_dev *dev)
+{
+	pci_power_t rc = 0;
+	CALL_EXTERNAL(rc, choose_state, dev);
+	return rc;
+}
+
+static bool intel_pm_pci_power_manageable(struct pci_dev *dev)
+{
+	bool rc = true;
+	CALL_EXTERNAL(rc, is_manageable, dev);
+	return rc;
+}
+
+static int intel_pm_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+{
+	int rc = 0;
+	CALL_EXTERNAL(rc, set_state, dev, state);
+	return rc;
+}
+
+static bool intel_pm_pci_can_wakeup(struct pci_dev *dev)
+{
+	bool rc = true;
+	CALL_EXTERNAL(rc, can_wakeup, dev);
+	return rc;
+}
+
+static int intel_pm_pci_sleep_wake(struct pci_dev *dev, bool enable)
+{
+    int rc = 0;
+    CALL_EXTERNAL(rc, sleep_wake, dev, enable);
+	return rc;
+}
+
+static struct pci_platform_pm_ops pci_pm = {
+	.is_manageable = intel_pm_pci_power_manageable,
+	.set_state     = intel_pm_pci_set_power_state,
+	.choose_state  = intel_pm_pci_choose_state,
+	.can_wakeup    = intel_pm_pci_can_wakeup,
+	.sleep_wake    = intel_pm_pci_sleep_wake,
+};
+
+static int __init intel_pm_pci_init(void)
+{
+	memset(&external_pm_ops, 0x0, sizeof(intel_pm_pci_ops_t));
+
+	sema_init(&icepm_lock, 1);
+
+	pci_set_platform_pm(&pci_pm);
+	return 0;
+}
+
+void intel_pm_register_callback(intel_pm_pci_ops_t * ops)
+{
+	down(&icepm_lock);
+	if (ops == NULL)
+        	memset(&external_pm_ops, 0x0, sizeof(intel_pm_pci_ops_t));
+    	else
+        	memcpy(&external_pm_ops, ops, sizeof(intel_pm_pci_ops_t));
+    	up(&icepm_lock);
+}
+
+EXPORT_SYMBOL(intel_pm_register_callback);
+
+arch_initcall(intel_pm_pci_init);
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./boards/Kconfig linux-2.6.32.27-fbx/drivers/platform/intelce/boards/Kconfig
--- linux-2.6.32.27-fbx/drivers/platform/intelce./boards/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/boards/Kconfig	2011-08-29 16:28:20.221735890 +0200
@@ -0,0 +1,20 @@
+config INTELCE_FALCON_FALLS
+	bool "IntelCE 4100 Falcon Falls suport"
+	select I2C
+	select I2C_PXA
+	---help---
+	  Support for the IntelCE 4100 Falcon Falls devices.
+	
+	  If you have such a board, say Y here, otherwise say N.
+
+config FBX6HD
+	bool "Freebox 6HD support"
+	select I2C
+	select LEDS_CLASS
+	select LEDS_GPIO
+	select INTELCE_GPIO
+	default y
+	---help---
+	  Support for the Freebox 6HD board devices.
+	
+	  If you have such a board, say Y here, otherwise say N.
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./boards/Makefile linux-2.6.32.27-fbx/drivers/platform/intelce/boards/Makefile
--- linux-2.6.32.27-fbx/drivers/platform/intelce./boards/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/boards/Makefile	2011-08-29 16:28:20.221735890 +0200
@@ -0,0 +1,4 @@
+obj-$(CONFIG_INTELCE_FALCON_FALLS)	+= falcon-falls.o
+obj-$(CONFIG_FBX6HD)			+= fbx6hd.o
+
+EXTRA_CFLAGS	+= -I$(srctree)/drivers/platform/intelce/
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./Kconfig linux-2.6.32.27-fbx/drivers/platform/intelce/Kconfig
--- linux-2.6.32.27-fbx/drivers/platform/intelce./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/Kconfig	2011-08-29 16:28:20.211735801 +0200
@@ -0,0 +1,44 @@
+#
+# IntelCE devices configuration
+#
+
+menu "IntelCE devices"
+	depends on ARCH_GEN3 && PCI
+
+config INTELCE_GPIO
+	tristate "GPIO support"
+	select ARCH_REQUIRE_GPIOLIB
+	---help---
+	  IntelCE 3100/4100 GPIO support.
+
+config INTELCE_DFX
+	tristate "DFX reporting support"
+	---help---
+	  IntelCE 3100/4100 DFX fuse reporting support.
+
+config INTELCE_NOR
+	tristate "NOR flash support"
+	depends on MTD
+	select MTD_PARTITIONS
+	select MTD_REDBOOT_PARTS
+	select MTD_CFI
+	select MTD_CFI_INTELEXT
+	---help---
+	  IntelCE 3100/4100 NOR Flash support.
+
+config INTELCE_PIC16PMU
+	tristate "PIC16 PMU, LED, hwmon support"
+	select INPUT_POLLDEV
+	depends on FBX6HD
+	depends on I2C
+	depends on HWMON
+	---help---
+	  Freebox v6 HD PIC16 PMU interface support, enables
+	  control of the on-board LEDs and reports the power status,
+	  reset status and button status.
+
+source "drivers/platform/intelce/remoti/Kconfig"
+
+source "drivers/platform/intelce/boards/Kconfig"
+
+endmenu
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./Makefile linux-2.6.32.27-fbx/drivers/platform/intelce/Makefile
--- linux-2.6.32.27-fbx/drivers/platform/intelce./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/Makefile	2011-08-29 16:28:20.221735890 +0200
@@ -0,0 +1,8 @@
+# Makefile for the IntelCE drivers
+
+obj-$(CONFIG_INTELCE_GPIO)	+= gpio-intelce.o
+obj-$(CONFIG_INTELCE_NOR)	+= nor.o
+obj-$(CONFIG_INTELCE_DFX)	+= dfx.o
+obj-$(CONFIG_INTELCE_PIC16PMU)	+= pic16-pmu.o
+obj-y				+= remoti/
+obj-y				+= boards/
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./remoti/Kconfig linux-2.6.32.27-fbx/drivers/platform/intelce/remoti/Kconfig
--- linux-2.6.32.27-fbx/drivers/platform/intelce./remoti/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/remoti/Kconfig	2011-08-29 16:28:20.241736068 +0200
@@ -0,0 +1,57 @@
+menu "RemoTI support"
+
+config INTELCE_REMOTI
+	tristate "RemoTI support"
+	depends on FBX6HD
+	---help---
+	  Texas Instruments RemoTI stack.
+
+config INTELCE_REMOTI_UART
+	tristate "RemoTI UART transport"
+	depends on INTELCE_REMOTI
+	depends on SERIAL_CORE
+	---help---
+	  RemoTI UART transport.
+
+config INTELCE_REMOTI_INPUT
+	tristate "RemoTI input support"
+	depends on INTELCE_REMOTI
+	depends on INPUT
+	---help---
+	  RemoTI Linux input driver support.
+
+config INTELCE_REMOTI_LEDS
+	tristate "RemoTI LEDS support"
+	depends on INTELCE_REMOTI
+	depends on LEDS_CLASS
+	---help---
+	  RemoTI LEDS class driver support.
+
+config INTELCE_REMOTI_GPIO
+	tristate "RemoTI gpio support"
+	depends on INTELCE_REMOTI
+	---help---
+	  gpiochip driver for the RemoTI RNP
+
+menu "RemoTI vendor-specific commands support"
+	depends on INTELCE_REMOTI_INPUT
+
+	config REMOTI_OAD
+		tristate "Over-the-Air firmware updates"
+		---help---
+		  Over-the-Air download support (firmware updates for Remote Controls).
+
+	config REMOTI_TEST
+		tristate "RemoTI test interface"
+		---help---
+		  Support for sending and reading test reports on RemoTI devices.
+		  This feature can be disabled in the Remote Control firmware.
+
+	config REMOTI_FBX
+		tristate "RemoTI Freebox device"
+		---help---
+		  Freebox RemoTI device (temp sensor, voltage input, gyro support).
+
+endmenu
+
+endmenu
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/intelce./remoti/Makefile linux-2.6.32.27-fbx/drivers/platform/intelce/remoti/Makefile
--- linux-2.6.32.27-fbx/drivers/platform/intelce./remoti/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/intelce/remoti/Makefile	2011-08-29 16:28:20.241736068 +0200
@@ -0,0 +1,12 @@
+obj-$(CONFIG_INTELCE_REMOTI)	+= remoti.o
+obj-$(CONFIG_INTELCE_REMOTI_UART) += remoti-uart.o
+obj-$(CONFIG_INTELCE_REMOTI_INPUT) += remoti-input.o
+obj-$(CONFIG_INTELCE_REMOTI_GPIO) += remoti-gpio.o
+obj-$(CONFIG_INTELCE_REMOTI_LEDS) += remoti-leds.o
+
+remoti-objs                     := remoti-core.o remoti-netlink.o
+
+# Vendor-specific command support
+obj-$(CONFIG_REMOTI_OAD)	+= remoti-input-oad.o
+obj-$(CONFIG_REMOTI_TEST)	+= remoti-input-test.o
+obj-$(CONFIG_REMOTI_FBX)	+= remoti-input-fbx.o
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/tango2./Kconfig linux-2.6.32.27-fbx/drivers/platform/tango2/Kconfig
--- linux-2.6.32.27-fbx/drivers/platform/tango2./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/tango2/Kconfig	2011-01-06 02:17:53.032183471 +0100
@@ -0,0 +1,30 @@
+#
+# TANGO2 devices configuration
+#
+
+menu "Tango2 devices"
+	depends on TANGO2
+
+config TANGO2_FIP
+	tristate "Front panel support"
+	select INPUT
+	---help---
+	  Tango2 FIP front panel support.
+
+config TANGO2_GPIO
+	tristate "GPIO sysfs support"
+	---help---
+	  Export GPIO attributes in sysfs.
+
+config TANGO2_IR
+	tristate "IR support"
+	---help---
+	  Tango2 IR (NEC/RC5/RC6) support.
+
+config TANGO2_FB
+	tristate "Framebuffer support"
+	depends on FB
+	---help---
+	  Tango2 framebuffer support.
+
+endmenu
diff -Nruw linux-2.6.32.27-fbx/drivers/platform/tango2./Makefile linux-2.6.32.27-fbx/drivers/platform/tango2/Makefile
--- linux-2.6.32.27-fbx/drivers/platform/tango2./Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/drivers/platform/tango2/Makefile	2011-01-06 02:17:53.032183471 +0100
@@ -0,0 +1,6 @@
+# Makefile for the TANGO2 device drivers
+
+obj-$(CONFIG_TANGO2_FIP) += fip.o
+obj-$(CONFIG_TANGO2_GPIO) += gpio.o
+obj-$(CONFIG_TANGO2_IR) += ir.o
+obj-$(CONFIG_TANGO2_FB) += fb.o
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/fs/ramfs/xattr.c	2011-08-29 16:28:22.741758276 +0200
@@ -0,0 +1,194 @@
+/*
+ * xattr.c for ramfs
+ * Created by <nschichan@freebox.fr> on Wed Aug  8 11:57:18 2007
+ * Freebox SA
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/xattr.h>
+
+#include "internal.h"
+
+void ramfs_inode_purge_xattrs(struct ramfs_inode_info *rii)
+{
+	(void)rii;
+#ifdef CONFIG_RAMFS_XATTR_USER
+	while (!list_empty(&rii->xattr_user_list)) {
+		struct list_head *head;
+		struct ramfs_xattr *elem;
+
+
+		head = rii->xattr_user_list.next;
+		elem = list_entry(head, struct ramfs_xattr, list);
+		list_del(head);
+		kfree(elem->data);
+		kfree(elem->name);
+		kfree(elem);
+	}
+#endif
+
+}
+
+#ifdef CONFIG_RAMFS_XATTR_USER
+static size_t ramfs_xattr_user_list(struct inode *inode, char *list,
+				    size_t list_size,
+				    const char *name, size_t namelen)
+{
+	struct ramfs_inode_info *rii;
+	struct list_head *it;
+	int ret;
+	char *ptr;
+	char *end;
+
+	ret = 0;
+	ptr = list;
+	end = list + list_size;
+	rii = RAMFS_I(inode);
+
+	list_for_each(it, &rii->xattr_user_list) {
+		struct ramfs_xattr *elem;
+		int name_len;
+
+		elem = list_entry(it, struct ramfs_xattr, list);
+		name_len = strlen(elem->name);
+
+		if (ptr + name_len + 1 + XATTR_USER_PREFIX_LEN >= end)
+			break;
+
+		/* copy prefix in buffer */
+		memcpy(ptr, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);
+		ptr += XATTR_USER_PREFIX_LEN;
+		ret += XATTR_USER_PREFIX_LEN;
+
+		/* copy attribute name in buffer */
+		memcpy(ptr, elem->name, name_len + 1);
+		ptr += name_len + 1;
+		ret += name_len + 1;
+	}
+
+	return ret;
+}
+
+static struct ramfs_xattr *ramfs_xattr_find(struct ramfs_inode_info *rii,
+					    const char *name)
+{
+	struct list_head *it;
+
+	list_for_each(it, &rii->xattr_user_list) {
+		struct ramfs_xattr *elem;
+
+		elem = list_entry(it, struct ramfs_xattr, list);
+		if (!strcmp(elem->name, name))
+			return elem;
+	}
+	return NULL;
+}
+
+static int ramfs_xattr_user_remove(struct inode *inode, const char *name)
+{
+	struct ramfs_inode_info *rii;
+	struct ramfs_xattr *elem;
+
+	rii = RAMFS_I(inode);
+	elem = ramfs_xattr_find(rii, name);
+	if (!elem)
+		return -ENODATA;
+
+	list_del(&elem->list);
+	kfree(elem->data);
+	kfree(elem->name);
+	kfree(elem);
+
+	return 0;
+}
+
+static int ramfs_xattr_user_set(struct inode *inode, const char *name,
+				const void *buffer, size_t size, int flags)
+{
+	int error;
+	struct ramfs_xattr *elem;
+	struct ramfs_inode_info *rii;
+	int new_elem;
+
+	if (buffer == NULL && size == 0)
+		return ramfs_xattr_user_remove(inode, name);
+
+	rii = RAMFS_I(inode);
+	elem = ramfs_xattr_find(rii, name);
+	if (elem) {
+		new_elem = 0;
+		if (flags & XATTR_CREATE)
+			return -EEXIST;
+		kfree(elem->data);
+		elem->data = NULL;
+	} else {
+		new_elem = 1;
+		if (flags & XATTR_REPLACE)
+			return -ENODATA;
+		elem = kzalloc(sizeof (*elem), GFP_KERNEL);
+		if (!elem)
+			return -ENOMEM;
+		elem->name = kstrdup(name, GFP_KERNEL);
+		if (!elem->name) {
+			kfree(elem);
+			return -ENOMEM;
+		}
+	}
+
+	elem->data = kmalloc(size, GFP_KERNEL);
+	if (!elem->data) {
+		error = -ENOMEM;
+		goto out_free_new_elem;
+	}
+	memcpy(elem->data, buffer, size);
+	elem->data_len = size;
+
+	if (new_elem)
+		list_add(&elem->list, &rii->xattr_user_list);
+
+	return 0;
+
+ out_free_new_elem:
+	if (elem && new_elem) {
+		if (elem->name)
+			kfree(elem->name);
+		kfree(elem);
+	}
+	return error;
+}
+
+static int ramfs_xattr_user_get(struct inode *inode, const char *name,
+				void *buffer, size_t size)
+{
+	struct ramfs_xattr *elem;
+	struct ramfs_inode_info *rii;
+	int copylen;
+
+	rii = RAMFS_I(inode);
+	elem = ramfs_xattr_find(rii, name);
+	if (elem == NULL)
+		return -ENODATA;
+	copylen = elem->data_len;
+
+	if (size < copylen)
+		copylen = size;
+	memcpy(buffer, elem->data, copylen);
+	return copylen;
+}
+
+static struct xattr_handler ramfs_user_handler = {
+	.prefix = XATTR_USER_PREFIX,
+	.list	= ramfs_xattr_user_list,
+	.get	= ramfs_xattr_user_get,
+	.set	= ramfs_xattr_user_set,
+};
+#endif
+
+struct xattr_handler *ramfs_xattr_handlers[] = {
+#ifdef CONFIG_RAMFS_XATTR_USER
+	&ramfs_user_handler,
+#endif
+	NULL,
+};
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/crash_zone.h	2011-01-06 02:17:56.281560587 +0100
@@ -0,0 +1,16 @@
+#ifndef CRASH_ZONE_H
+#define CRASH_ZONE_H
+
+#define CRASH_MAGIC	0xa7cecd6a
+
+struct crash_header
+{
+	unsigned int magic;
+	unsigned int len;
+	unsigned short checksum;
+	unsigned char data;
+};
+
+void __init crash_zone_set_param(unsigned char *zone, unsigned int size);
+
+#endif /* ! CRASH_ZONE_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/fbxatm.h	2011-01-06 02:17:56.292062462 +0100
@@ -0,0 +1,155 @@
+/*
+ * Generic fbxatm definition, exported to userspace
+ */
+#ifndef LINUX_FBXATM_H_
+#define LINUX_FBXATM_H_
+
+#include <linux/types.h>
+#include <linux/if.h>
+
+#define FBXATM_IOCTL_MAGIC		0xd3
+
+/* allow userspace usage without up to date kernel headers */
+#ifndef PF_FBXATM
+#define PF_FBXATM			32
+#define AF_FBXATM			PF_FBXATM
+#endif
+
+struct fbxatm_vcc_id {
+	int				dev_idx;
+	__u32				vpi;
+	__u32				vci;
+};
+
+enum fbxatm_vcc_user {
+	FBXATM_VCC_USER_NONE = 0,
+	FBXATM_VCC_USER_2684,
+	FBXATM_VCC_USER_PPPOA,
+};
+
+enum fbxatm_vcc_traffic_class {
+	FBXATM_VCC_TC_UBR_NO_PCR = 0,
+	FBXATM_VCC_TC_UBR,
+};
+
+struct fbxatm_vcc_qos {
+	__u32				traffic_class;
+	__u32				max_sdu;
+	__u32				max_buffered_pkt;
+	__u32				priority;
+	__u32				rx_priority;
+};
+
+
+/*
+ * VCC related
+ */
+struct fbxatm_vcc_params {
+	/* ADD/DEL/GET */
+	struct fbxatm_vcc_id		id;
+
+	/* ADD/GET */
+	struct fbxatm_vcc_qos		qos;
+
+	/* GET */
+	enum fbxatm_vcc_user		user;
+};
+
+#define FBXATM_IOCADD		_IOW(FBXATM_IOCTL_MAGIC,	1,	\
+					struct fbxatm_vcc_params)
+
+#define FBXATM_IOCDEL		_IOR(FBXATM_IOCTL_MAGIC,	2,	\
+					struct fbxatm_vcc_params)
+
+#define FBXATM_IOCGET		_IOWR(FBXATM_IOCTL_MAGIC,	3,	\
+					struct fbxatm_vcc_params)
+
+
+struct fbxatm_vcc_drop_params {
+	struct fbxatm_vcc_id		id;
+	unsigned int			drop_count;
+};
+
+#define FBXATM_IOCDROP		_IOWR(FBXATM_IOCTL_MAGIC,	5,	\
+					struct fbxatm_vcc_drop_params)
+
+/*
+ * OAM related
+ */
+enum fbxatm_oam_ping_type {
+	FBXATM_OAM_PING_SEG_F4	= 0,
+	FBXATM_OAM_PING_SEG_F5,
+	FBXATM_OAM_PING_E2E_F4,
+	FBXATM_OAM_PING_E2E_F5,
+};
+
+struct fbxatm_oam_ping_req {
+	/* only dev_idx for F4 */
+	struct fbxatm_vcc_id		id;
+
+	__u8				llid[16];
+	enum fbxatm_oam_ping_type	type;
+};
+
+#define FBXATM_IOCOAMPING	_IOWR(FBXATM_IOCTL_MAGIC,	10,	\
+				      struct fbxatm_oam_ping_req)
+
+
+/*
+ * PPPOA related
+ */
+enum fbxatm_pppoa_encap {
+	FBXATM_EPPPOA_AUTODETECT = 0,
+	FBXATM_EPPPOA_VCMUX,
+	FBXATM_EPPPOA_LLC,
+};
+
+struct fbxatm_pppoa_vcc_params {
+	struct fbxatm_vcc_id		id;
+	__u32				encap;
+	__u32				cur_encap;
+};
+
+#define FBXATM_PPPOA_IOCADD	_IOW(FBXATM_IOCTL_MAGIC,	20,	\
+					struct fbxatm_pppoa_vcc_params)
+
+#define FBXATM_PPPOA_IOCDEL	_IOW(FBXATM_IOCTL_MAGIC,	21,	\
+					struct fbxatm_pppoa_vcc_params)
+
+#define FBXATM_PPPOA_IOCGET	_IOWR(FBXATM_IOCTL_MAGIC,	22,	\
+					struct fbxatm_pppoa_vcc_params)
+
+
+
+/*
+ * 2684 related
+ */
+enum fbxatm_2684_encap {
+	FBXATM_E2684_VCMUX = 0,
+	FBXATM_E2684_LLC,
+};
+
+enum fbxatm_2684_payload {
+	FBXATM_P2684_BRIDGE = 0,
+	FBXATM_P2684_ROUTED,
+};
+
+struct fbxatm_2684_vcc_params {
+	struct fbxatm_vcc_id		id;
+
+	__u32				encap;
+	__u32				payload;
+	char				dev_name[IFNAMSIZ];
+};
+
+
+#define FBXATM_2684_IOCADD	_IOW(FBXATM_IOCTL_MAGIC,	30,	\
+					struct fbxatm_2684_vcc_params)
+
+#define FBXATM_2684_IOCDEL	_IOW(FBXATM_IOCTL_MAGIC,	31,	\
+					struct fbxatm_2684_vcc_params)
+
+#define FBXATM_2684_IOCGET	_IOWR(FBXATM_IOCTL_MAGIC,	32,	\
+					struct fbxatm_2684_vcc_params)
+
+#endif /* LINUX_FBXATM_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/fbxbootinfo.h	2011-01-06 02:17:56.292062462 +0100
@@ -0,0 +1,11 @@
+#ifndef FBXBOOTINFO_H
+#define FBXBOOTINFO_H
+
+struct fbx_bootinfo {
+	u32 bank_number;
+	char uboot_version_str[128];
+	u32 bank0_forced;
+	char cefdk_version_str[256];
+} __attribute__ ((packed));
+
+#endif /* FBXBOOTINFO_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/fbxmtd_map_ioctl.h	2011-01-06 02:17:56.292062462 +0100
@@ -0,0 +1,52 @@
+/*
+ * fbxmtd_map_ioctl.h for linux-freebox
+ * Created by <nschichan@freebox.fr> on Thu Feb  8 20:37:28 2007
+ * Freebox SA
+ */
+
+#ifndef FBXMTD_MAP_IOCTL_H
+# define FBXMTD_MAP_IOCTL_H
+
+/*
+ * IOCTL interface
+ */
+#define FBXMTD_MINOR	242
+
+#define FBXMTD_MAP_IOCTL_MAX_DEV	2
+#define FBXMTD_MAP_IOCTL_MAX_PART	16
+
+struct fbxmtd_map_ioctl_part
+{
+	char		name[32];
+	uint32_t	offset;
+	uint32_t	size;
+	uint32_t	flags;
+};
+
+struct fbxmtd_map_ioctl_dev
+{
+	char				name[32];
+	uint32_t			base_phys;
+	int				bus_width;
+	uint32_t			size;
+	uint32_t			status;
+	struct fbxmtd_map_ioctl_part	parts[FBXMTD_MAP_IOCTL_MAX_PART];
+	int				num_parts;
+};
+
+#define FBXMTD_MAP_IOCTL_NR	0x42
+
+struct fbxmtd_map_ioctl_query
+{
+	uint32_t	cmd;
+	uint32_t	param;
+	int		result;
+	void __user	*user_buf;
+	uint32_t	user_buf_size;
+};
+
+#define FBXMTDCTL_CMD_GET_DEVICES	0x1
+#define FBXMTDCTL_CMD_ADD_DEVICE	0x2
+#define FBXMTDCTL_CMD_DEL_DEVICE	0x3
+
+#endif /* !FBXMTD_MAP_IOCTL_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/fbxprocfs.h	2011-01-06 02:17:56.292062462 +0100
@@ -0,0 +1,45 @@
+#ifndef FBXPROCFS_H_
+#define FBXPROCFS_H_
+
+#include <linux/proc_fs.h>
+#include <asm/atomic.h>
+
+struct fbxprocfs_client
+{
+	const char *dirname;
+	struct module *owner;
+	struct proc_dir_entry *dir;
+	atomic_t refcount;
+	struct list_head list;
+};
+
+struct fbxprocfs_ro_desc {
+	char		*name;
+	unsigned long	id;
+	int	(*rfunc)(char *, char **, off_t, int, int *, void *);
+};
+
+struct fbxprocfs_rw_desc {
+	char		*name;
+	unsigned long	id;
+	int	(*rfunc)(char *, char **, off_t, int, int *, void *);
+	int	(*wfunc)(struct file *, const char *, unsigned long, void *);
+};
+
+struct fbxprocfs_client *fbxprocfs_add_client(const char *dirname,
+					      struct module *owner);
+
+int fbxprocfs_remove_client(struct fbxprocfs_client *client);
+
+
+int
+fbxprocfs_create_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc);
+
+int
+fbxprocfs_remove_entries(struct fbxprocfs_client *client,
+			 const struct fbxprocfs_ro_desc *ro_desc,
+			 const struct fbxprocfs_rw_desc *rw_desc);
+
+#endif /* FBXPROCFS_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/fbxserial.h	2011-09-09 16:10:59.830460865 +0200
@@ -0,0 +1,122 @@
+#ifndef FBXSERIAL_H_
+#define FBXSERIAL_H_
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/*
+ * some part of serial may vary, we use abstract struct to store this,
+ * data content depends on type.
+ */
+#define EXTINFO_SIZE		128
+#define EXTINFO_MAX_COUNT	16
+
+/*
+ * extdev desc
+ */
+#define EXTINFO_TYPE_EXTDEV	1
+
+#define EXTDEV_TYPE_BUNDLE	1
+#define EXTDEV_TYPE_MAX		2
+
+struct fbx_serial_extinfo {
+	u32			type;
+
+	union {
+		/* extdev */
+		struct {
+			u32	type;
+			u32	model;
+			char	serial[64];
+		} extdev;
+
+		/* raw access */
+		unsigned char	data[EXTINFO_SIZE];
+	} u;
+}  __attribute__ ((packed));;
+
+
+/*
+ * master serial structure
+ */
+
+#define FBXSERIAL_VERSION	1
+
+#define FBXSERIAL_MAGIC		0x2d9521ab
+
+#define MAC_ADDR_SIZE		6
+#define RANDOM_DATA_SIZE	32
+
+/*
+ * this  is the  maximum size  we accept  to check  crc32  against, so
+ * structure may no grow larger than this
+ */
+#define FBXSERIAL_MAX_SIZE	8192
+
+struct fbx_serial {
+	u32	crc32;
+	u32	magic;
+	u32	struct_version;
+	u32	len;
+
+	/* board serial */
+	u16	type;
+	u8	version;
+	u8	manufacturer;
+	u16	year;
+	u8	week;
+	u32	number;
+	u32	flags;
+
+	/* mac address base */
+	u8	mac_addr_base[MAC_ADDR_SIZE];
+
+	/* mac address count */
+	u8	mac_count;
+
+	/* random data */
+	u8	random_data[RANDOM_DATA_SIZE];
+
+	/* last update of data (seconds since epoch) */
+	u32	last_modified;
+
+	/* count of following extinfo tag */
+	u32	extinfo_count;
+
+	/* beginning of extended info */
+	struct fbx_serial_extinfo	extinfos[EXTINFO_MAX_COUNT];
+
+} __attribute__ ((packed));
+
+
+/*
+ * default value to use in case magic is wrong (no cksum in that case)
+ */
+static inline void fbxserial_set_default(struct fbx_serial *s)
+{
+	memset(s, 0, sizeof (*s));
+	s->magic = FBXSERIAL_MAGIC;
+	s->struct_version = FBXSERIAL_VERSION;
+	s->len = sizeof (*s);
+	s->manufacturer = '_';
+	memcpy(s->mac_addr_base, "\x00\x07\xCB\x00\x00\xFD", 6);
+	s->mac_count = 1;
+}
+
+void
+fbxserialinfo_get_random(unsigned char *data, unsigned int len);
+
+void
+fbxserialinfo_get_mac_addr(unsigned char *data);
+
+int
+fbxserialinfo_read(void *data, struct fbx_serial *out);
+
+struct fbx_serial *fbxserialinfo_get(void);
+
+/*
+ * implemented in board specific code
+ */
+const struct fbx_serial *arch_get_fbxserial(void);
+
+#endif /* FBXSERIAL_H_ */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/include/linux/pci-intelce_pm.h	2011-08-29 16:28:23.071761207 +0200
@@ -0,0 +1,42 @@
+/*
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2010 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+
+#ifndef __PCI_INTELCE_PM_H__
+#define __PCI_INTELCE_PM_H__
+
+typedef struct intel_pm_pci_ops_t
+{
+	bool		(*is_manageable)(struct pci_dev *dev);
+	int		(*set_state)(struct pci_dev *dev, pci_power_t state);
+	pci_power_t	(*choose_state)(struct pci_dev *dev);
+	bool		(*can_wakeup)(struct pci_dev *dev);
+	int		(*sleep_wake)(struct pci_dev *dev, bool enable);
+} intel_pm_pci_ops_t;
+
+void intel_pm_register_callback(intel_pm_pci_ops_t * ops);
+
+#endif
diff -Nruw linux-2.6.32.27-fbx/include/linux/remoti./Kbuild linux-2.6.32.27-fbx/include/linux/remoti/Kbuild
--- linux-2.6.32.27-fbx/include/linux/remoti./Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/remoti/Kbuild	2011-08-29 16:28:23.091761385 +0200
@@ -0,0 +1,2 @@
+header-y	+= remoti.h remoti-netlink.h remoti-input-oad.h \
+		   remoti-input-fbx.h
diff -Nruw linux-2.6.32.27-fbx/include/linux/remoti./remoti.h linux-2.6.32.27-fbx/include/linux/remoti/remoti.h
--- linux-2.6.32.27-fbx/include/linux/remoti./remoti.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/remoti/remoti.h	2011-08-29 16:28:23.091761385 +0200
@@ -0,0 +1,387 @@
+#ifndef __REMOTI_H
+#define __REMOTI_H
+
+#ifdef __KERNEL__
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+
+#include <linux/remoti/remoti-transport.h>
+#include <linux/remoti/remoti-input.h>
+#endif
+
+enum rnp_states {
+	RNP_STATE_UNSPEC,
+	RNP_STATE_READY,
+	RNP_STATE_FW_DOWNLOADING,
+	RNP_STATE_FW_FAILED,
+	RNP_STATE_PAIRING_FAILED,
+	RNP_STATE_MAX,
+};
+
+/*
+ * RTI definitions
+ */
+#define NPI_SYS_RES0		0
+#define NPI_SYS_SYS		1
+#define NPI_SYS_MAC		2
+#define NPI_SYS_NWK		3
+#define NPI_SYS_AF		4
+#define NPI_SYS_ZDO		5
+#define NPI_SYS_SAPI		6
+#define NPI_SYS_UTIL		7
+#define NPI_SYS_DBG		8
+#define NPI_SYS_APP		9
+#define NPI_SYS_RCAF		10
+#define NPI_SYS_RCN		11
+#define NPI_SYS_RCN_CLI		12
+#define NPI_SYS_BOOT		13
+#define NPI_SYS_MAX		14
+#define NPI_SYS_MASK		0x1F
+
+#define NPI_MAX_FRAME_LEN	128
+#define NPI_MAX_MSG_LEN		123
+
+#define NPI_POLL		0
+#define NPI_SREQ		1
+#define NPI_AREQ		2
+#define NPI_SRSP		3
+#define NPI_TYPE_MASK		3
+#define NPI_TYPE_SHIFT		5
+
+/*
+ * RCAF RPCs
+ */
+#define RTI_READ_ITEM		0x01
+#define RTI_WRITE_ITEM		0x02
+
+#define RTI_INIT_CNF		0x01
+#define RTI_INIT_REQ		0x03
+
+#define RTI_PAIR_CNF		0x02
+#define RTI_PAIR_REQ		0x04
+
+#define RTI_ALLOW_PAIR_CNF	0x04
+#define RTI_ALLOW_PAIR_REQ	0x06
+
+#define RTI_STANDBY_REQ		0x07
+#define RTI_STANDBY_CNF		0x06
+
+#define RTI_RECEIVE_DATA_CNF	0x03
+#define RTI_RECEIVE_DATA_IND	0x05
+
+#define RTI_ENABLE_SLEEP_REQ	0x09
+#define RTI_ENABLE_SLEEP_CNF	0x08
+
+#define RTI_DISABLE_SLEEP_REQ	0x0A
+#define RTI_DISABLE_SLEEP_CNF	0x09
+
+#define RTI_UNPAIR_REQ		0x0B
+#define RTI_UNPAIR_CNF		0x0A
+
+#define RTI_ALLOW_PAIR_ABRT_REQ	0x0D
+
+#define RTI_SB_RELOAD		0x10
+
+/* Test-mode only */
+#define RTI_RESET_REQ		0x13
+#define RTI_TEST_MODE_REQ	0x11
+#define RTI_TEST_RX_CNT_REQ	0x12
+
+#define RTI_CLEAR_TABLE_REQ	0x19
+#define RTI_CLEAR_TABLE_CNF	0x18
+
+/*
+ * Serial bootloader RPCs
+ */
+#define RTI_SB_HSK_REQ		0x04
+#define RTI_SB_HSK_RESP		0x84
+#define RTI_SB_WR_REQ		0x01
+#define RTI_SB_WR_RESP		0x81
+#define RTI_SB_RD_REQ		0x02
+#define RTI_SB_RD_RESP		0x82
+
+/*
+ * Serial bootloader RPCs
+ */
+#define RTI_SB_HSK_REQ		0x04
+#define RTI_SB_WRITE_REQ	0x01
+#define RTI_SB_READ_REQ		0x02
+#define RTI_SB_ENABLE_REQ	0x03
+
+#define RTI_SB_FLASH_WORD	4
+
+/*
+ * Items
+ */
+#define RTI_ITEM_STARTUP_OPTS	0xA0
+#define RTI_ITEM_NODE_CAPS	0xA1
+#define RTI_ITEM_SUP_TGT_TYPES	0xA2
+#define RTI_ITEM_APP_CAPS	0xA3
+#define RTI_ITEM_DEV_TYPE_LIST	0xA4
+#define RTI_ITEM_PROF_ID_LIST	0xA5
+#define RTI_ITEM_DEF_STANDBY	0xA6
+#define RTI_ITEM_DEF_DUTY_CYCLE	0xA7
+#define RTI_ITEM_VENDOR_ID	0xA8
+#define RTI_ITEM_VENDOR_NAME	0xA9
+#define RTI_ITEM_DISC_DURATION	0xAA
+#define RTI_ITEM_DEF_LQI_THRES	0xAB
+
+#define RTI_ITEM_STAND_ACT_PER	0x60
+#define RTI_ITEM_CURR_CHANNEL	0x61
+#define RTI_ITEM_DISC_LQI_THRES	0x62
+#define RTI_ITEM_DUTY_CYCLE	0x64
+#define RTI_ITEM_FRAME_CNT	0x65
+#define RTI_ITEM_IN_POWERSAVE	0x67
+#define RTI_ITEM_MAX_CSMA_BACK	0x6A
+#define RTI_ITEM_MAX_FRAME_RET	0x6B
+#define RTI_ITEM_RESP_WAIT_TIME	0x6D
+#define RTI_ITEM_SCAN_DURATION	0x6E
+#define RTI_ITEM_USER_STRING	0x6F
+
+#define RTI_ITEM_IEEE_ADDR	0x84
+#define RTI_ITEM_PAN_ID		0x85
+#define RTI_ITEM_SHORT_ADDR	0x86
+#define RTI_ITEM_AGILITY_EN	0x87
+#define RTI_ITEM_TX_PWR		0x88
+
+#define RTI_ITEM_NUM_ACT_PT	0xB0
+#define RTI_ITEM_CURR_PT_INDEX	0xB1
+#define RTI_ITEM_CURR_PT_ENTRY	0xB2
+
+#define RTI_ITEM_SW_VER		0xC0
+#define RTI_ITEM_MAX_PT_ENTRIES	0xC1
+#define RTI_ITEM_PROTO_ID	0xC2
+#define RTI_ITEM_PROTO_VER	0xC3
+#define RTI_ITEM_FW_VER		0xC4
+
+#define RTI_ITEM_MIN		(RTI_ITEM_STAND_ACT_PER)
+#define RTI_ITEM_MAX		(RTI_ITEM_FW_VER)
+
+
+/* common error codes (see RemoTI API) */
+#define RTI_SUCCESS		0x00
+#define RTI_ERR_INV_INDEX	0xF9
+#define RTI_ERR_INV_PARAM	0xE8
+#define RTI_ERR_UNSUP_ATTR	0xF4
+#define RTI_ERR_NOT_PERM	0xB4
+#define RTI_ERR_NO_ORG_CAP	0xB0
+#define RTI_ERR_NO_REC_CAP	0xB1
+#define RTI_ERR_NO_RESP		0xB3
+#define RTI_ERR_OOM		0xBE
+#define RTI_ERR_PAIR_TIMEO	0x23
+#define RTI_ERR_UNK_STATUS	0x20
+#define RTI_ERR_OSAL_NO_TIMER	0x08
+#define RTI_ERR_OSAL_NV_FAILED	0x0A
+#define RTI_ERR_OSAL_NV_UNINIT	0x09
+#define RTI_ERR_OSAL_NV_BAD	0x0C
+#define RTI_ERR_MAC_EXP		0xF0
+#define RTI_ERR_MAC_OVF		0xF1
+#define RTI_ERR_MAC_NO_RES	0x1A
+#define RTI_ERR_MAC_BAD_STATE	0x19
+#define RTI_ERR_MAC_CHAN_ACC	0xE1
+#define RTI_ERR_MAC_NO_ACK	0xE9
+#define RTI_ERR_MAC_BCN		0xE0
+#define RTI_ERR_MAC_PAN_ID	0xEE
+#define RTI_ERR_MAC_SCAN	0xFC
+#define RTI_ERR_FAIL_DISC	0x21
+#define RTI_ERR_FAIL_PAIR	0x22
+#define RTI_ERR_NO_PAIR_IDX	0xB2
+#define RTI_ERR_PAIR_COMP	0x24
+#define RTI_ERR_SYNC_TIMEO	0xFF
+
+/*
+ * Vendor identifiers
+ */
+#define RTI_VENDOR_PANASONIC		0x0001
+#define RTI_VENDOR_SONY			0x0002
+#define RTI_VENDOR_SAMSUNG		0x0003
+#define RTI_VENDOR_PHILIPS		0x0004
+#define RTI_VENDOR_FREESCALE		0x0005
+#define RTI_VENDOR_OKI			0x0006
+#define RTI_VENDOR_TEXAS_INSTRUMENTS	0x0007
+#define RTI_VENDOR_FREEBOX		0x10A5
+
+#ifdef __KERNEL__
+
+static inline const char *remoti_rnp_error(u8 val)
+{
+	switch (val) {
+	case RTI_SUCCESS:
+		return "success";
+	case RTI_ERR_INV_INDEX:
+		return "invalid index";
+	case RTI_ERR_INV_PARAM:
+		return "invalid parameter";
+	case RTI_ERR_UNSUP_ATTR:
+		return "unsupported attribute";
+	case RTI_ERR_NOT_PERM:
+		return "not permitted";
+	case RTI_ERR_NO_ORG_CAP:
+		return "originator pairing table full";
+	case RTI_ERR_NO_REC_CAP:
+		return "recipient pairing table full";
+	case RTI_ERR_NO_RESP:
+		return "no response";
+	case RTI_ERR_OOM:
+		return "out of memory";
+	case RTI_ERR_PAIR_TIMEO:
+		return "pairing timeout";
+	case RTI_ERR_UNK_STATUS:
+		return "unknown RTI status";
+	case RTI_ERR_OSAL_NO_TIMER:
+		return "no OSAL timer available";
+	case RTI_ERR_OSAL_NV_FAILED:
+		return "NVRAM operation failed";
+	case RTI_ERR_OSAL_NV_UNINIT:
+		return "NVRAM item not initialized";
+	case RTI_ERR_OSAL_NV_BAD:
+		return "NVRAM item invalid length";
+	case RTI_ERR_MAC_EXP:
+		return "MAC transaction expired";
+	case RTI_ERR_MAC_OVF:
+		return "MAC transaction overflow";
+	case RTI_ERR_MAC_NO_RES:
+		return "MAC resource unavailable";
+	case RTI_ERR_MAC_BAD_STATE:
+		return "MAC state not allowed";
+	case RTI_ERR_MAC_CHAN_ACC:
+		return "MAC channel access failure";
+	case RTI_ERR_MAC_NO_ACK:
+		return "MAC transaction got no ACK";
+	case RTI_ERR_MAC_BCN:
+		return "MAC transaction w/ beacon lost";
+	case RTI_ERR_MAC_PAN_ID:
+		return "PAN ID conflict";
+	case RTI_ERR_MAC_SCAN:
+		return "MAC background scan in progress";
+	case RTI_ERR_FAIL_DISC:
+		return "failed to discover";
+	case RTI_ERR_NO_PAIR_IDX:
+		return "pairing reference invalid";
+	case RTI_ERR_PAIR_COMP:
+		return "pairing already completed";
+	case RTI_ERR_SYNC_TIMEO:
+		return "NPI synchronisation timeout";
+	default:
+		return "unknown";
+	}
+
+	return NULL;
+}
+
+/* Commonly used structures to describe frames */
+struct rti_hdr {
+	u8	len;
+	u8	subsys;
+	u8	cmd;
+} __packed;
+
+/*
+ * Payload starting after SOF + header
+ */
+#define RTI_HDR_SIZE	(sizeof(struct rti_hdr))
+
+struct remoti_msg {
+	u8 type;
+	u8 subsys;
+	u8 cmd;
+	u8 len;
+	u8 *data;
+};
+
+struct remoti_command {
+	struct remoti_msg msg;
+	u8		fixed:1;
+	const char 	*name;
+	int		(*req)(struct remoti_device *rf,
+						const char *data, int count);
+	int		(*cnf)(struct remoti_device *rf,
+						const char *data, int count);
+	int		(*error)(const char *data, int count);
+	int		(*post_init)(struct remoti_device *rf);
+	int		(*exit)(struct remoti_device *rf);
+	void		(*close)(struct remoti_device *rf);
+	struct list_head cmd_list;
+};
+
+struct remoti_transport;
+
+int remoti_send_frame(struct remoti_device *rf,
+			const struct remoti_msg *msg);
+void remoti_tty_write_buf(struct tty_struct *tty);
+int remoti_read_item(struct remoti_device *rf,
+			const u8 item, const u8 item_len,
+			void *value, size_t *len);
+int remoti_receive_frame(struct remoti_transport *tsp,
+						const u8 *buf, const u8 len);
+int remoti_check_frame(struct remoti_transport *tsp,
+						const u8 *buf, const u8 len);
+void remoti_close_transport(struct remoti_transport *tsp);
+int remoti_reload_firmware(struct remoti_device *rf);
+
+int remoti_register_command(struct remoti_command *cmd);
+int remoti_register_commands(struct remoti_command *cmd, int size);
+void remoti_unregister_command(struct remoti_command *cmd);
+void remoti_unregister_commands(struct remoti_command *cmd, int size);
+
+struct remoti_command *remoti_find_cmd_by_id(const u8 id);
+
+static inline unsigned fw_data_is_empty(u8 *data, size_t count)
+{
+	while (count--)
+		if (*data++)
+			return 0;
+	return 1;
+}
+
+struct rti_sb_read_resp {
+	u8 status;
+	__le16 addr;
+	u8 data[64];
+} __packed;
+
+struct remoti_platform_data {
+	unsigned int reset_gpio;
+	unsigned int reset_polarity;
+};
+
+struct remoti_device {
+	struct platform_device	*pdev;
+	struct remoti_transport	*tsp;
+	spinlock_t		lock;
+	unsigned long		rnp_state;
+	u8			state;
+
+	struct list_head	cmd_list;
+
+	/* rw items */
+	struct completion	completion;
+	u8			cnf_buf[NPI_MAX_FRAME_LEN];
+	u8			cnf_buf_len;
+
+	int                     cmd_status;
+	u8			rx_buf[NPI_MAX_FRAME_LEN];
+	u8			rx_count;
+
+	struct remoti_remote_dev input_devs[REMOTI_INPUT_COUNT];
+
+	/* firmware related stuff */
+	struct firmware		*fw;
+	struct workqueue_struct	*workqueue;
+	struct delayed_work	hw_init_work;
+	struct delayed_work	hw_firmware_work;
+	struct rti_sb_read_resp	read_resp;
+
+	struct remoti_platform_data pdata;
+};
+
+#endif /* __KERNEL__ */
+
+#endif /* __REMOTI_H */
diff -Nruw linux-2.6.32.27-fbx/include/linux/remoti./remoti-input-fbx.h linux-2.6.32.27-fbx/include/linux/remoti/remoti-input-fbx.h
--- linux-2.6.32.27-fbx/include/linux/remoti./remoti-input-fbx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/remoti/remoti-input-fbx.h	2011-08-29 16:28:23.091761385 +0200
@@ -0,0 +1,38 @@
+#ifndef __REMOTI_INPUT_FBX_H
+#define __REMOTI_INPUT_FBX_H
+
+enum gyro_calib_states {
+        GYRO_CALIB_STATUS_OK,
+        GYRO_CALIB_STATUS_OUT_RANGE,
+        GYRO_CALIB_STATUS_WRITE_FAILED,
+        GYRO_CALIB_STATUS_DRIFT,
+        GYRO_CALIB_STATUS_ALDY_STARTED,
+        GYRO_CALIB_STATUS_TIMED_OUT
+};
+
+enum {
+	REMOTI_ATTR_INPUT_FBX_UNSPEC,
+	REMOTI_ATTR_INPUT_FBX_STATE,
+	REMOTI_ATTR_INPUT_FBX_STATUS,
+	REMOTI_ATTR_INPUT_FBX_INDEX,
+	REMOTI_ATTR_INPUT_FBX_MAX
+};
+
+enum {
+	REMOTI_CMD_INPUT_FBX_UNSPEC,
+	REMOTI_CMD_INPUT_FBX_NEW_STATE,
+	REMOTI_CMD_INPUT_FBX_MAX
+};
+
+enum {
+	REMOTI_TYPE_INPUT_FBX_UNSPEC,
+	REMOTI_TYPE_INPUT_FBX_U8,
+	REMOTI_TYPE_INPUT_FBX_MAX,
+};
+
+enum {
+	ACCELERO_MODEL_ST = 0,
+	ACCELERO_MODEL_ADI,
+};
+
+#endif /* __REMOTI_INPUT_FBX_H */
diff -Nruw linux-2.6.32.27-fbx/include/linux/remoti./remoti-input-oad.h linux-2.6.32.27-fbx/include/linux/remoti/remoti-input-oad.h
--- linux-2.6.32.27-fbx/include/linux/remoti./remoti-input-oad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/remoti/remoti-input-oad.h	2011-08-29 16:28:23.091761385 +0200
@@ -0,0 +1,42 @@
+#ifndef __REMOTI_INPUT_OAD_H
+#define __REMOTI_INPUT_OAD_H
+
+enum oad_states {
+	OAD_STATE_UNSPEC,
+	OAD_STATE_READY,
+	OAD_STATE_FW_DOWNLOADING,
+	OAD_STATE_FW_FAILED,
+	OAD_STATE_FW_UPTODATE,
+	OAD_STATE_MAX,
+};
+
+enum {
+	REMOTI_ATTR_INPUT_OAD_UNSPEC,
+	REMOTI_ATTR_INPUT_OAD_VERSION,
+	REMOTI_ATTR_INPUT_OAD_STATE,
+	REMOTI_ATTR_INPUT_OAD_INDEX,
+	REMOTI_ATTR_INPUT_OAD_MAX,
+};
+
+enum {
+	REMOTI_CMD_INPUT_OAD_UNSPEC,
+	REMOTI_CMD_INPUT_OAD_GET_VERSION,
+	REMOTI_CMD_INPUT_OAD_GET_STATE,
+	REMOTI_CMD_INPUT_OAD_NEW_STATE,
+	REMOTI_CMD_INPUT_OAD_FW_PROGRESS,
+	REMOTI_CMD_INPUT_OAD_MAX,
+};
+
+enum {
+	REMOTI_TYPE_INPUT_OAD_UNSPEC,
+	REMOTI_TYPE_INPUT_OAD_U8,
+	REMOTI_TYPE_INPUT_OAD_U32,
+	REMOTI_TYPE_INPUT_OAD_MAX,
+};
+
+/*
+ * Progress related
+ */
+#define OAD_PROGRESS_STEP	(1)
+
+#endif /* __REMOTI_INPUT_OAD_H */
diff -Nruw linux-2.6.32.27-fbx/include/linux/remoti./remoti-netlink.h linux-2.6.32.27-fbx/include/linux/remoti/remoti-netlink.h
--- linux-2.6.32.27-fbx/include/linux/remoti./remoti-netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/include/linux/remoti/remoti-netlink.h	2011-05-24 15:54:26.825351454 +0200
@@ -0,0 +1,61 @@
+#ifndef __REMOTI_NETLINK_H
+#define __REMOTI_NETLINK_H
+
+#include <linux/remoti/remoti.h>
+
+/* Exported attributes */
+enum {
+	REMOTI_ATTR_RNP_UNSPEC,
+	REMOTI_ATTR_RNP_CMD_ID,
+	REMOTI_ATTR_RNP_CMD_STATUS,
+	REMOTI_ATTR_RNP_STATE,
+	REMOTI_ATTR_RNP_CMD_FW,
+	REMOTI_ATTR_RNP_COUNTERS,
+	REMOTI_ATTR_RNP_TRANSPORT,
+	REMOTI_ATTR_RNP_MAX,
+};
+
+enum {
+	REMOTI_CMD_RNP_UNSPEC,
+	REMOTI_CMD_RNP_GET_STATE,
+	REMOTI_CMD_RNP_NEW_STATE,
+	REMOTI_CMD_RNP_SEND_CMD,
+	REMOTI_CMD_RNP_GET_CMD_STATUS,
+	REMOTI_CMD_RNP_RELOAD_FW,
+	REMOTI_CMD_RNP_GET_STATS,
+	REMOTI_CMD_RNP_GET_TRANSPORT,
+	REMOTI_CMD_RNP_READ_ITEM,
+	REMOTI_CMD_RNP_FW_PROGRESS,
+	REMOTI_CMD_RNP_MAX,
+};
+
+enum {
+	REMOTI_TYPE_UNSPEC,
+	REMOTI_TYPE_U8,
+	REMOTI_TYPE_INT,
+	REMOTI_TYPE_STATS,
+	REMOTI_TYPE_STRING,
+	REMOTI_TYPE_RNP_CMD,
+	REMOTI_TYPE_ITEM,
+	REMOTI_TYPE_MAX,
+};
+
+/* Nested attributes */
+enum {
+	REMOTI_TYPE_RNP_CMD_UNSPEC,
+	REMOTI_TYPE_RNP_CMD_ARGS,
+	REMOTI_TYPE_RNP_CMD_MAX,
+};
+
+#define RTI_FW_PROGRESS_STEP	(1)
+
+#ifdef __KERNEL__
+
+int remoti_netlink_register(struct remoti_device *rf);
+void remoti_netlink_unregister(void);
+
+int remoti_mcast_msg(const int cmd, const int type, const void *arg);
+
+#endif
+
+#endif /* __REMOTI_NETLINK_H */
--- /dev/null	2011-06-03 14:51:38.633053002 +0200
+++ linux-2.6.32.27-fbx/lib/fbxserial.c	2011-01-06 02:17:56.732113582 +0100
@@ -0,0 +1,117 @@
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/crc32.h>
+
+#include <asm/io.h>
+
+#include <linux/fbxserial.h>
+
+#define PFX "builtin-fbxserial: "
+
+static void __init
+fbxserialinfo_use_default(struct fbx_serial *serial)
+{
+	printk(KERN_WARNING PFX "warning: using default serial infos\n");
+	fbxserial_set_default(serial);
+}
+
+/*
+ * add trailing 0 for bundle string here.
+ */
+static void __init
+bundle_fixup(struct fbx_serial *serial)
+{
+	struct fbx_serial_extinfo *p;
+	int i;
+
+	for (i = 0; i < be32_to_cpu(serial->extinfo_count); i++) {
+
+		if (i >= EXTINFO_MAX_COUNT)
+			break;
+
+		p = &serial->extinfos[i];
+		if (be32_to_cpu(p->type) == EXTINFO_TYPE_EXTDEV &&
+		    be32_to_cpu(p->u.extdev.type) == EXTDEV_TYPE_BUNDLE) {
+			int size;
+
+			size = sizeof (p->u.extdev.serial);
+			p->u.extdev.serial[size - 1] = 0;
+		}
+	}
+}
+
+/*
+ * called from  arch code early  in the boot sequence.   This function
+ * returns 1  in case serial infos are  invalid/unreadable and default
+ * values have been used.
+ */
+int __init
+fbxserialinfo_read(void *data, struct fbx_serial *out)
+{
+	uint32_t sum;
+
+	/*
+	 * get partial serial data from flash/whatever.
+	 */
+	memcpy(out, data, sizeof (*out));
+
+	/* check magic first */
+	if (be32_to_cpu(out->magic) != FBXSERIAL_MAGIC) {
+		printk(KERN_NOTICE PFX "invalid magic (%08x, expected %08x), "
+			"using defaults !\n", be32_to_cpu(out->magic),
+		       FBXSERIAL_MAGIC);
+		goto out_default;
+	}
+
+	/* fetch size for which we have to check CRC */
+	if (be32_to_cpu(out->len) > FBXSERIAL_MAX_SIZE) {
+		printk(KERN_NOTICE PFX "structure size too big (%d), "
+		       "using defaults !\n", be32_to_cpu(out->len));
+		goto out_default;
+	}
+
+	/* compute and check checksum */
+	sum = crc32(0, data + 4, be32_to_cpu(out->len) - 4);
+
+	if (be32_to_cpu(out->crc32) != sum) {
+		printk(KERN_NOTICE PFX "invalid checksum (%08x, "
+		       "expected %08x), using defaults !\n", sum,
+		       be32_to_cpu(out->crc32));
+		goto out_default;
+	}
+
+	printk(KERN_INFO PFX "Found valid serial infos !\n");
+	bundle_fixup(out);
+	return 0;
+
+ out_default:
+	fbxserialinfo_use_default(out);
+	bundle_fixup(out);
+	return 1;
+}
+
+void
+fbxserialinfo_get_random(unsigned char *data, unsigned int len)
+{
+	const struct fbx_serial *s;
+
+	s = arch_get_fbxserial();
+
+	if (len > sizeof (s->random_data))
+		len = sizeof (s->random_data);
+
+	memcpy(data, s->random_data, len);
+}
+EXPORT_SYMBOL(fbxserialinfo_get_random);
+
+void
+fbxserialinfo_get_mac_addr(unsigned char *data)
+{
+	const struct fbx_serial *s;
+
+	s = arch_get_fbxserial();
+	memcpy(data, s->mac_addr_base, MAC_ADDR_SIZE);
+}
+EXPORT_SYMBOL(fbxserialinfo_get_mac_addr);
diff -Nruw linux-2.6.32.27-fbx/net/fbxatm./Kconfig linux-2.6.32.27-fbx/net/fbxatm/Kconfig
--- linux-2.6.32.27-fbx/net/fbxatm./Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32.27-fbx/net/fbxatm/Kconfig	2011-01-06 02:17:56.872064521 +0100
@@ -0,0 +1,28 @@
+menuconfig FBXATM
+	tristate "Freebox Asynchronous Transfer Mode (ATM)"
+
+if FBXATM
+
+config FBXATM_REMOTE
+	bool
+
+choice
+	prompt "mode"
+	default FBXATM_STACK
+
+config FBXATM_STACK
+	bool "standard"
+
+config FBXATM_REMOTE_STUB
+	bool "remote stub"
+	select FBXATM_REMOTE
+
+endchoice
+
+config FBXATM_REMOTE_DRIVER
+	tristate "remote fbxatm driver"
+	depends on FBXATM_STACK
+	select FBXATM_REMOTE
+	default n
+
+endif
